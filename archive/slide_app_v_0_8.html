<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SlideApp v0.8 ‚Äî Sandbox Safe</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>"">
  <style>
    :root { --bg-1:#0f172a;--bg-2:#1e293b;--text:#e2e8f0;--muted:#94a3b8;--primary:#7c3aed;--accent:#22d3ee;--card:#111827cc;--radius:18px;--shadow:0 10px 30px rgba(0,0,0,0.25);} 
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;color:var(--text);background:linear-gradient(120deg,var(--bg-1),var(--bg-2));overflow:hidden;height:100vh;display:flex}
    .bg-gradient{position:fixed;inset:0;z-index:-2;background:linear-gradient(45deg,#0f172a,#1e293b,#111827,#0b1220,#1f2937,#0f172a);background-size:400% 400%;animation:moveGradient 30s ease-in-out infinite;filter:saturate(1.1)}
    #bg-canvas{position:fixed;inset:0;z-index:-1;display:none}
    @keyframes moveGradient{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
    .deck{position:relative;flex:1;height:100vh;overflow:hidden}
    .deck-header{position:absolute;top:14px;left:24px;right:24px;display:flex;align-items:center;justify-content:space-between;z-index:5}
    .brand{display:flex;align-items:center;gap:12px;padding:8px 12px;background:rgba(17,24,39,.55);border-radius:999px;box-shadow:var(--shadow)}
    .brand-badge{height:28px;width:28px;border-radius:8px;background:linear-gradient(135deg,var(--primary),var(--accent))}
    .brand-name{font-weight:700}
    .deck-tools{display:flex;gap:8px;align-items:center}
    .btn{cursor:pointer;padding:6px 10px;border-radius:8px;color:var(--text);background:rgba(17,24,39,.55);border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);font-size:12px}
    .slides{position:absolute;inset:0;display:grid;place-items:center;padding:64px 72px 80px 72px}
    .slide{position:absolute;inset:72px;display:grid;place-items:center;background:linear-gradient(180deg,rgba(17,24,39,.75),rgba(17,24,39,.55));border-radius:var(--radius);box-shadow:var(--shadow);opacity:0;transform:translate3d(60px,0,0) scale(.98);transition:all 0.6s cubic-bezier(0.4, 0, 0.2, 1);backdrop-filter:blur(8px);padding:48px;overflow:auto}
    .slide.active{opacity:1;transform:translate3d(0,0,0) scale(1);z-index:2}
    .slide.prev{opacity:0;transform:translate3d(-50px,0,0) scale(.98);z-index:1}
    .slide.slide-in-right{opacity:0;transform:translate3d(100px,0,0) scale(.95)}
    .slide.slide-in-left{opacity:0;transform:translate3d(-100px,0,0) scale(.95)}
    .slide.slide-out-left{opacity:0;transform:translate3d(-100px,0,0) scale(.95)}
    .slide.slide-out-right{opacity:0;transform:translate3d(100px,0,0) scale(.95)}
    .md{width:min(1100px,92%)}
  .md ul,.md ol{padding-left:20px;margin:16px 0}
  .md li{margin:8px 0}
  .md ul li{list-style-type:disc}
  .md ol li{list-style-type:decimal}
    .md blockquote{border-left:4px solid var(--accent);padding-left:16px;margin:16px 0;font-style:italic;color:var(--muted)}
    .md img{max-width:100%;height:auto;border-radius:8px;margin:16px 0}
    .md a{color:var(--accent);text-decoration:none}
    .md a:hover{text-decoration:underline}
  /* Headings hierarchy */
  .md h1{font-size:clamp(28px,3.2vw,40px);line-height:1.2;margin:0 0 12px;font-weight:800}
  .md h2{font-size:clamp(22px,2.4vw,30px);line-height:1.25;margin:18px 0 10px;font-weight:700}
  .md h3{font-size:clamp(18px,1.9vw,24px);line-height:1.3;margin:16px 0 8px;font-weight:700;color:var(--text)}
  /* Tables */
  .md table{width:100%;border-collapse:collapse;margin:16px 0;border:1px solid rgba(255,255,255,.08);border-radius:8px;overflow:hidden}
  .md th,.md td{padding:10px 12px;border:1px solid rgba(255,255,255,.08)}
  .md thead th{background:rgba(255,255,255,.06);font-weight:700}
  .md tbody tr:nth-child(odd) td{background:rgba(255,255,255,.03)}
  /* Columns shortcode */
  .md .cols{display:flex;gap:24px;align-items:flex-start}
  .md .cols .col{flex:1;min-width:0}
  @media (max-width: 820px){.md .cols{flex-direction:column}}
    pre{background:rgba(0,0,0,.35);padding:10px;border-radius:8px;overflow:auto}
    code{font-family:monospace}
  .deck-footer{position:absolute;left:24px;right:24px;bottom:18px;display:flex;align-items:center;justify-content:space-between;z-index:5}
  /* UI visibility modes */
  .ui-hidden .deck-header,.ui-hidden .deck-footer{opacity:0;pointer-events:none;transition:opacity .25s ease}
  .ui-auto .deck-header,.ui-auto .deck-footer{opacity:0;pointer-events:none;transition:opacity .25s ease}
  .ui-auto.ui-showing .deck-header,.ui-auto.ui-showing .deck-footer{opacity:1;pointer-events:auto}
    .progress{flex:1;height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden}
    .progress>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--primary),var(--accent))}
    @media print{body{overflow:visible;background:white;color:black}.deck-header,.deck-footer,.bg-gradient,#bg-canvas{display:none!important}.slide{position:static;opacity:1;transform:none;page-break-after:always;box-shadow:none;background:white;color:black}.notes{display:none!important}}
  .thumbs{width:140px;background:#0b1220;overflow-y:auto;padding:8px;display:flex;flex-direction:column;gap:8px;transition:width .25s ease}
  .thumbs.collapsed{width:0;padding:8px 0;overflow:hidden}
  /* Overlay drawer styles */
  .thumbs.overlay{position:fixed;left:0;top:0;bottom:0;width:260px;transform:translateX(-100%);transition:transform .25s ease;z-index:16;padding:16px 12px;background:#0b1220;box-shadow:4px 0 24px rgba(0,0,0,.4)}
  .thumbs.overlay.open{transform:translateX(0)}
  #scrim{position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:14}
    .thumb{cursor:pointer;padding:6px;background:rgba(255,255,255,.05);border-radius:6px;font-size:12px;color:var(--muted)}
    .thumb.active{background:rgba(124,58,237,.4);color:white}
    .notes{position:absolute;bottom:0;left:0;right:0;background:rgba(0,0,0,0.95);color:#ffffff;padding:20px 24px;font-size:16px;font-weight:500;display:none;z-index:10;max-height:30%;overflow:auto;border-top:3px solid var(--accent);box-shadow:0 -4px 20px rgba(0,0,0,0.5)}
    .notes.show{display:block}
  /* Config modal */
  #cfgOverlay{position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);display:none;z-index:30}
  #cfgModal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:min(420px,92%);background:#0b1220;color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31}
  #cfgModal header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08)}
  #cfgModal main{padding:14px}
  #cfgModal label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
  #cfgModal input[type="text"]{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.1);background:#0f172a;color:var(--text)}
  #cfgModal input[type="color"]{width:54px;height:32px;padding:0;border:1px solid rgba(255,255,255,.1);border-radius:8px;background:transparent}
  #cfgModal .row{display:flex;gap:10px;align-items:center}
  #cfgModal footer{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08)}
  </style>
</head>
<body>
  <div class="bg-gradient"></div>
  <canvas id="bg-canvas"></canvas>
  <div id="scrim"></div>
  <div class="thumbs" id="thumbs"></div>
  <div class="deck">
    <div class="deck-header">
      <div class="brand"><div class="brand-badge"></div><div class="brand-name">SlideApp</div></div>
    <div class="deck-tools">
  <button class="btn" id="uiBtn" title="Toggle UI visibility">üëÅÔ∏è UI</button>
        <input type="file" id="fileInput" class="btn" accept=".md,.markdown,.txt" title="Load Markdown" />
  <button class="btn" id="styleBtn" title="Style settings">üé® Style</button>
  <button class="btn" id="bgBtn" title="Toggle Background">üåå Background</button>
        <button class="btn" id="notesBtn">üìù Notes</button>
  <button class="btn" id="fsBtn" title="Toggle Fullscreen">‚õ∂ Fullscreen</button>
        <button class="btn" onclick="window.print()">üìÑ PDF</button>
      </div>
    </div>
    <main class="slides" id="slides"></main>
    <footer class="deck-footer">
      <div><button class="btn" onclick="prev()">‚óÄ</button><button class="btn" onclick="next()">‚ñ∂</button></div>
      <div class="progress"><span id="progress"></span></div>
      <div id="slideNo">0/0</div>
    </footer>
    <div class="notes" id="notes"></div>
  </div>
  <!-- Config Modal -->
  <div id="cfgOverlay"></div>
  <div id="cfgModal" role="dialog" aria-modal="true" aria-labelledby="cfgTitle">
    <header>
      <strong id="cfgTitle">Style Settings</strong>
      <button class="btn" id="cfgClose">‚úï</button>
    </header>
    <main>
      <label for="cfgName">Brand name</label>
      <input id="cfgName" type="text" placeholder="SlideApp" />
      <label>Presets</label>
      <div id="presetRow" class="row" style="margin-bottom:6px"></div>
      <div class="row">
        <div style="flex:1">
          <label for="cfgPrimary">Primary color</label>
          <input id="cfgPrimary" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgAccent">Accent color</label>
          <input id="cfgAccent" type="color" />
        </div>
      </div>
    </main>
    <footer>
      <button class="btn" id="cfgReset" title="Reset to defaults">‚Ü∫ Reset</button>
      <button class="btn" id="cfgSave">Save</button>
    </footer>
  </div>
  <script>
  // CONFIG ‚Äî Customize your deck here. Values persist in localStorage under 'slideapp.config'.
  // Edit brand.name, brand.primary, brand.accent. To reset to these defaults, clear localStorage for this key.
  const CONFIG_KEY = 'slideapp.config';
  const DEFAULT_CONFIG = { brand: { name: 'SlideApp', primary: '#7c3aed', accent: '#22d3ee' } };
  // Load saved config (if any) with sane defaults
  let CONFIG = DEFAULT_CONFIG;
  try {
    const saved = localStorage.getItem(CONFIG_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      CONFIG = { ...DEFAULT_CONFIG, ...parsed, brand: { ...DEFAULT_CONFIG.brand, ...(parsed?.brand||{}) } };
    }
  } catch {}
  // Expose for quick runtime tweaks (optional)
  window.CONFIG = CONFIG;

  const slidesRoot=document.getElementById('slides');
  const thumbsRoot=document.getElementById('thumbs');
    const notesEl=document.getElementById('notes');
    const bgCanvas=document.getElementById('bg-canvas');
    const ctx=bgCanvas.getContext('2d');
    let current=0,slidesHTML=[],themeIndex=0;
    // Background modes: 'gradient' (CSS), 'particles' (canvas), 'off'
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    let bgMode = localStorage.getItem('bgMode') || (prefersReduced ? 'off' : 'gradient');
    let rafId = null;
    let particles = [];
    let particleColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();

    function persistConfig(){
      try{ localStorage.setItem(CONFIG_KEY, JSON.stringify(CONFIG)); } catch{}
    }

    function applyConfig(){
      const name = CONFIG?.brand?.name || 'SlideApp';
      const primary = CONFIG?.brand?.primary || DEFAULT_CONFIG.brand.primary;
      const accent = CONFIG?.brand?.accent || DEFAULT_CONFIG.brand.accent;
      const brandEl = document.querySelector('.brand-name');
      if(brandEl) brandEl.textContent = name;
      document.documentElement.style.setProperty('--primary', primary);
      document.documentElement.style.setProperty('--accent', accent);
      // ensure particles pick up accent color
      particleColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    }

    function setBgButtonLabel(){
      const btn = document.getElementById('bgBtn');
      if(!btn) return;
      btn.textContent = bgMode === 'gradient' ? 'üåå Background' : bgMode === 'particles' ? '‚ú® Particles' : 'üö´ Background Off';
      btn.title = 'Toggle Background (current: ' + bgMode + ')';
    }

    function resizeCanvas(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      bgCanvas.width = Math.floor(window.innerWidth * dpr);
      bgCanvas.height = Math.floor(window.innerHeight * dpr);
      bgCanvas.style.width = window.innerWidth + 'px';
      bgCanvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function initParticles(){
      const count = Math.min(120, Math.floor((window.innerWidth * window.innerHeight) / 15000));
      particles = Array.from({length: count}, () => ({
        x: Math.random()*window.innerWidth,
        y: Math.random()*window.innerHeight,
        vx: (Math.random()-0.5)*0.6,
        vy: (Math.random()-0.5)*0.6,
        r: Math.random()*1.8 + 0.6,
      }));
    }

    function drawParticles(){
      ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
      ctx.fillStyle = particleColor || '#22d3ee';
      // draw and move
      for(const p of particles){
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
        p.x += p.vx; p.y += p.vy;
        if(p.x < -10) p.x = window.innerWidth+10; if(p.x > window.innerWidth+10) p.x = -10;
        if(p.y < -10) p.y = window.innerHeight+10; if(p.y > window.innerHeight+10) p.y = -10;
      }
      // subtle connections
      ctx.strokeStyle = particleColor + '55'; // alpha via hex
      ctx.lineWidth = 0.5;
      for(let i=0;i<particles.length;i++){
        for(let j=i+1;j<particles.length;j++){
          const a=particles[i], b=particles[j];
          const dx=a.x-b.x, dy=a.y-b.y; const d=dx*dx+dy*dy;
          if(d < 110*110){
            ctx.globalAlpha = 1 - (Math.sqrt(d)/110);
            ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
          }
        }
      }
      ctx.globalAlpha = 1;
      rafId = requestAnimationFrame(drawParticles);
    }

    function startParticles(){
      if(prefersReduced) return; // respect motion preference
      cancelParticles();
      resizeCanvas();
      initParticles();
      bgCanvas.style.display = 'block';
      document.querySelector('.bg-gradient').style.display = 'none';
      rafId = requestAnimationFrame(drawParticles);
    }

    function cancelParticles(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    }

    function setBackgroundMode(mode){
      bgMode = mode;
      localStorage.setItem('bgMode', bgMode);
      setBgButtonLabel();
      if(bgMode === 'off'){
        cancelParticles();
        bgCanvas.style.display = 'none';
        document.querySelector('.bg-gradient').style.display = 'none';
      } else if(bgMode === 'gradient'){
        cancelParticles();
        bgCanvas.style.display = 'none';
        document.querySelector('.bg-gradient').style.display = 'block';
      } else if(bgMode === 'particles'){
        document.querySelector('.bg-gradient').style.display = 'none';
        startParticles();
      }
    }

    function cycleBackground(){
      const order = ['gradient','particles','off'];
      const idx = order.indexOf(bgMode);
      const next = order[(idx+1)%order.length];
      setBackgroundMode(next);
    }

    window.addEventListener('resize', ()=>{
      if(bgMode==='particles'){
        resizeCanvas();
        initParticles();
      }
    });


    function parseFrontmatter(text){
      const fm={};
      
      console.log('Parsing frontmatter for text:', text.substring(0, 100));
      
      // Check if text starts with frontmatter
      if(text.trim().startsWith('---')){
        const lines = text.split('\n');
        let endIndex = -1;
        
        console.log('Found frontmatter start, lines:', lines.slice(0, 5));
        
        // Find the closing ---
        for(let i = 1; i < lines.length; i++) {
          if(lines[i].trim() === '---') {
            endIndex = i;
            console.log('Found frontmatter end at line:', i);
            break;
          }
        }
        
        if(endIndex > 0) {
          // Parse frontmatter lines - improved parsing
          let currentKey = null;
          let currentValue = [];
          
          for(let i = 1; i < endIndex; i++) {
            const line = lines[i];
            
            // Check if this line starts a new key-value pair
            if(line.includes(':') && !line.startsWith(' ') && !line.startsWith('\t')) {
              // Save previous key-value pair if exists
              if(currentKey) {
                fm[currentKey.toLowerCase()] = currentValue.join(' ').trim();
              }
              
              // Start new key-value pair
              const colonIndex = line.indexOf(':');
              currentKey = line.substring(0, colonIndex).trim();
              currentValue = [line.substring(colonIndex + 1).trim()];
            } else if(currentKey) {
              // This is a continuation of the current value
              currentValue.push(line.trim());
            }
          }
          
          // Don't forget the last key-value pair
          if(currentKey) {
            fm[currentKey.toLowerCase()] = currentValue.join(' ').trim();
          }
          
          // Return body without frontmatter
          const body = lines.slice(endIndex + 1).join('\n').trim();
          console.log('Parsed fm:', fm, 'body:', body.substring(0, 50));
          return {fm, body};
        }
      }
      
      console.log('No frontmatter found, returning original text');
      return {fm:{}, body:text.trim()};
    }

    function sanitizeHTML(html) {
      // Basic sanitization - remove dangerous elements and attributes
      const temp = document.createElement('div');
      temp.innerHTML = html;
      
      // Remove script tags and event handlers
      const scripts = temp.querySelectorAll('script');
      scripts.forEach(script => script.remove());
      
      const elements = temp.querySelectorAll('*');
      elements.forEach(el => {
        // Remove all event handler attributes
        Array.from(el.attributes).forEach(attr => {
          if (attr.name.startsWith('on')) {
            el.removeAttribute(attr.name);
            return;
          }
          // Allow safe image sources (http, https, data:image)
          if (el.tagName.toLowerCase()==='img' && attr.name==='src'){
            const v = (attr.value||'').trim();
            const ok = /^https?:\/\//i.test(v) || /^data:image\//i.test(v);
            if(!ok){ el.removeAttribute('src'); }
          }
        });
      });
      
      return temp.innerHTML;
    }

    function parseMarkdown(md, opts={allowColumns:true}){
      // First handle code blocks to protect them from other processing
      md=md.replace(/```(\w+)?\n([\s\S]*?)```/g,(m,lang,code)=>`<pre><code>${code.replace(/</g,'&lt;')}</code></pre>`);
      
      // Custom columns shortcode
      if(opts.allowColumns){
        const lines = md.split('\n');
        const out = [];
        for(let i=0;i<lines.length;i++){
          if(/^:::\s*columns\b/i.test(lines[i].trim())){
            const block = [];
            i++;
            while(i<lines.length && lines[i].trim()!==':::'){
              block.push(lines[i]); i++;
            }
            // split columns by lines that are exactly ':::col'
            const cols = [];
            let buf=[];
            for(const ln of block){
              if(ln.trim().toLowerCase()===':::col'){
                cols.push(buf.join('\n')); buf=[];
              } else {
                buf.push(ln);
              }
            }
            cols.push(buf.join('\n'));
            // render each column content (no nested columns to avoid recursion loops)
            const htmlCols = cols.map(c=>`<div class="col">${parseMarkdown(c.trim(), {allowColumns:false})}</div>`).join('');
            out.push(`<div class="cols">${htmlCols}</div>`);
            continue;
          }
          out.push(lines[i]);
        }
        md = out.join('\n');
      }
      
      // Handle headings
      md=md.replace(/^# (.*)$/gm,'<h1>$1</h1>').replace(/^## (.*)$/gm,'<h2>$1</h2>').replace(/^### (.*)$/gm,'<h3>$1</h3>');
      
      // Handle blockquotes
      md = md.replace(/^> (.*)$/gm, '<blockquote>$1</blockquote>');
      
  // Handle images BEFORE links so the link regex doesn't consume image syntax
  md = md.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%;height:auto;border-radius:8px;margin:16px 0;">');

  // Handle links (after images)
  md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      
      // Handle tables (GFM style): header | separator | rows
      (function(){
        const lines = md.split('\n');
        const out = [];
        let i = 0;
        function splitRow(line){
          let s = line.trim();
          if (s.startsWith('|')) s = s.slice(1);
          if (s.endsWith('|')) s = s.slice(0,-1);
          return s.split('|').map(c=>c.trim());
        }
        function isSep(line){
          let s = line.trim();
          if (s.startsWith('|')) s = s.slice(1);
          if (s.endsWith('|')) s = s.slice(0,-1);
          const parts = s.split('|').map(p=>p.trim());
          if (parts.length===0) return false;
          return parts.every(p=>/^:?-{3,}:?$/.test(p));
        }
        function alignFrom(token){
          token = token.trim();
          const left = token.startsWith(':'), right = token.endsWith(':');
          if (left && right) return 'center';
          if (right) return 'right';
          return 'left';
        }
        while (i < lines.length){
          const line = lines[i];
          const next = lines[i+1];
          if (line && line.includes('|') && next && isSep(next)){
            const headers = splitRow(line);
            const aligns = splitRow(next).map(alignFrom);
            i += 2; // consume header and separator
            const rows = [];
            while (i < lines.length){
              const r = lines[i];
              if (!r || !r.includes('|')) break;
              if (isSep(r)) break; // another table, stop here
              rows.push(splitRow(r));
              i++;
            }
            const colCount = Math.max(headers.length, aligns.length, ...rows.map(r=>r.length));
            const getAlign = idx => (aligns[idx]||'left');
            let html = '<table><thead><tr>';
            for (let c=0;c<colCount;c++){
              const h = headers[c]||'';
              html += `<th style="text-align:${getAlign(c)}">${h}</th>`;
            }
            html += '</tr></thead><tbody>';
            for (const row of rows){
              html += '<tr>';
              for (let c=0;c<colCount;c++){
                const val = row[c]||'';
                html += `<td style="text-align:${getAlign(c)}">${val}</td>`;
              }
              html += '</tr>';
            }
            html += '</tbody></table>';
            out.push(html);
            continue;
          }
          out.push(line);
          i++;
        }
        md = out.join('\n');
      })();
      
  // Handle lists (unordered and ordered)
      const lines = md.split('\n');
      let listType = null; // 'ul' | 'ol' | null
      const result = [];
      const ulRe = /^[\*\-]\s+(.+)$/;
      const olRe = /^\d+\.\s+(.+)$/;

      function open(type){ result.push(type==='ul' ? '<ul>' : '<ol>'); listType = type; }
      function close(){ if(listType){ result.push(listType==='ul' ? '</ul>' : '</ol>'); listType = null; } }

      for (let line of lines) {
        const ulMatch = line.match(ulRe);
        const olMatch = line.match(olRe);

        if (ulMatch) {
          if (listType !== 'ul') { close(); open('ul'); }
          result.push(`<li>${ulMatch[1]}</li>`);
          continue;
        }
        if (olMatch) {
          if (listType !== 'ol') { close(); open('ol'); }
          result.push(`<li>${olMatch[1]}</li>`);
          continue;
        }
        // Not a list item; close any open list before adding the line
        close();
        result.push(line);
      }
      close();
      md = result.join('\n');
      
      // Handle bold and italic
      md=md.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
      md=md.replace(/\*([^*\n]+)\*/g,'<em>$1</em>');
      
      return md;
    }

    function splitSlides(md){
      // Robust line-by-line parser that treats '---' as:
      // - frontmatter start/end when at the beginning of a slide
      // - slide separator AND next slide's frontmatter start, so we must not drop it
      const slides = [];
      const lines = md.split('\n');
      // Strip BOM if present on first line
      if (lines.length && /\uFEFF/.test(lines[0])) {
        lines[0] = lines[0].replace(/^\uFEFF/, '');
      }
      let currentSlide = [];
      let inFrontmatter = false;
      let atSlideStart = true; // we're at the start of a new slide

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isDash = line.trim() === '---';
        const isBlank = line.trim() === '';

        // Ignore leading blank lines before any real content/frontmatter
        if (atSlideStart && !inFrontmatter && isBlank) {
          continue; // keep atSlideStart true
        }

        if (isDash) {
          if (inFrontmatter) {
            // End of frontmatter
            currentSlide.push(line);
            inFrontmatter = false;
            atSlideStart = false;
            continue;
          }

          if (atSlideStart) {
            // Start of frontmatter for this (new) slide
            currentSlide.push(line);
            inFrontmatter = true;
            atSlideStart = false;
            continue;
          }

          // Slide separator encountered mid-slide: close current and start new
          if (currentSlide.length > 0) {
            const content = currentSlide.join('\n').trim();
            if (content) slides.push(content);
          }

          // IMPORTANT: treat this same '---' as the beginning of the next slide's frontmatter
          currentSlide = ['---'];
          inFrontmatter = true;
          atSlideStart = false;
          continue;
        }

        // Regular content line
        currentSlide.push(line);
        // Once we add content, we're no longer at the very start
        if (atSlideStart) atSlideStart = false;
      }

      // Add the final slide if any content collected
      if (currentSlide.length > 0) {
        const content = currentSlide.join('\n').trim();
        if (content) slides.push(content);
      }

      console.log('Split into slides:', slides.length);

      return slides.map((slideText, index) => {
        const { fm, body } = parseFrontmatter(slideText);
        console.log(`Slide ${index}:`, {
          raw: slideText.substring(0, 100),
          fm,
          body: body.substring(0, 100)
        });
        return { html: `<div class='md'>${parseMarkdown(body)}</div>`, fm };
      });
    }

    function renderSlides(list){
      slidesRoot.innerHTML=''; thumbsRoot.innerHTML='';
      if(!Array.isArray(list) || list.length===0){
        current = 0; document.getElementById('progress').style.width='0%';
        document.getElementById('slideNo').textContent='0/0';
        return;
      }
      list.forEach((obj,i)=>{
        const node=document.createElement('section'); node.className='slide'; 
        // Sanitize before setting innerHTML
        node.innerHTML=sanitizeHTML(obj.html); 
        slidesRoot.append(node);
        const thumb=document.createElement('div'); thumb.className='thumb';
        const t=(obj.fm.title||'').toString().trim();
        thumb.textContent=t||`Slide ${i+1}`; thumb.onclick=()=>setActive(i); thumbsRoot.append(thumb);
      });
      setActive(0);
    }

    function setActive(i, direction = 'none'){
      const all=[...document.querySelectorAll('.slide')];
      all.forEach(s=>s.classList.remove('active','prev','slide-in-right','slide-in-left','slide-out-left','slide-out-right'));
      
      // Add directional transition classes only if we have a valid current slide and direction
      if (direction === 'next' && typeof current !== 'undefined' && all[current]) {
        all[current].classList.add('slide-out-left');
      } else if (direction === 'prev' && typeof current !== 'undefined' && all[current]) {
        all[current].classList.add('slide-out-right');
      }
      
      if(all[i]) {
        if (direction === 'next') {
          all[i].classList.add('slide-in-right');
          setTimeout(() => all[i].classList.remove('slide-in-right'), 10);
        } else if (direction === 'prev') {
          all[i].classList.add('slide-in-left');
          setTimeout(() => all[i].classList.remove('slide-in-left'), 10);
        }
        all[i].classList.add('active');
      }
      if(all[i-1]) all[i-1].classList.add('prev');
      
      current=i;
      document.getElementById('progress').style.width=((i+1)/all.length*100)+'%';
      document.getElementById('slideNo').textContent=`${i+1}/${all.length}`;
      const thumbs=[...document.querySelectorAll('.thumb')];
      thumbs.forEach((t,j)=>t.classList.toggle('active',j===i));
      
      // Add safety check for slidesHTML
      if (slidesHTML[i] && slidesHTML[i].fm) {
        const notes = slidesHTML[i].fm.notes || '';
        console.log(`Setting notes for slide ${i}:`, notes);
        notesEl.textContent = notes;
        if (!notes) {
          notesEl.textContent = `[No notes for slide ${i+1}]`;
        }
      } else {
        notesEl.textContent = `[No slide data available]`;
      }
      location.hash = `/${i+1}`;
    }

    function next(){if(current<slidesHTML.length-1)setActive(++current, 'next')}
    function prev(){if(current>0)setActive(--current, 'prev')}

    document.addEventListener('keydown',e=>{if(e.key==='ArrowRight'||e.key===' ')next();if(e.key==='ArrowLeft')prev();if(e.key.toLowerCase()==='n')toggleNotes();});

    // Mobile touch support
    let touchStartX = 0;
    let touchEndX = 0;

    document.addEventListener('touchstart', e => {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });

    document.addEventListener('touchend', e => {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    }, { passive: true });

    function handleSwipe() {
      const threshold = 50; // minimum distance for swipe
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > threshold) {
        if (diff > 0) {
          next(); // swipe left = next slide
        } else {
          prev(); // swipe right = previous slide  
        }
      }
    }

    document.getElementById('fileInput').addEventListener('change',async e=>{
      const f=e.target.files[0]; 
      if(!f) return;
      
      try {
        // Validate file size (max 5MB)
        if (f.size > 5 * 1024 * 1024) {
          alert('File too large. Maximum size is 5MB.');
          return;
        }
        
        // Validate file type
        const validTypes = ['text/markdown', 'text/plain', 'application/octet-stream'];
        if (!validTypes.includes(f.type) && !f.name.match(/\.(md|markdown|txt)$/i)) {
          alert('Please select a valid Markdown file (.md, .markdown, .txt)');
          return;
        }
        
        const text = await f.text();
        
        if (!text.trim()) {
          alert('File appears to be empty.');
          return;
        }
        
        slidesHTML = splitSlides(text);
        
        if (slidesHTML.length === 0) {
          alert('No slides found in the file.');
          return;
        }
        
        renderSlides(slidesHTML);
      } catch (error) {
        console.error('Error loading file:', error);
        alert('Error loading file. Please try again.');
      }
    });

  const THEMES=[{name:'Indigo/Cyan',primary:'#7c3aed',accent:'#22d3ee'},{name:'Red/Amber',primary:'#ef4444',accent:'#f59e0b'},{name:'Emerald/Blue',primary:'#10b981',accent:'#3b82f6'}];

    document.getElementById('notesBtn').addEventListener('click',toggleNotes);
  // Style modal wiring (replaces theme/brand)
  const styleBtn = document.getElementById('styleBtn');
    const cfgOverlay = document.getElementById('cfgOverlay');
    const cfgModal = document.getElementById('cfgModal');
    const cfgName = document.getElementById('cfgName');
    const cfgPrimary = document.getElementById('cfgPrimary');
    const cfgAccent = document.getElementById('cfgAccent');
  const presetRow = document.getElementById('presetRow');
  let cfgSnapshot = null;
    function openCfg(){
      cfgSnapshot = { brand: { ...(CONFIG.brand||{}) } };
      // populate
      cfgName.value = CONFIG?.brand?.name || DEFAULT_CONFIG.brand.name;
      // try to parse current CSS var values if not present in CONFIG
      const currentPrimary = CONFIG?.brand?.primary || getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
      const currentAccent = CONFIG?.brand?.accent || getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      try{ cfgPrimary.value = toColorHex(currentPrimary); }catch{ cfgPrimary.value = '#7c3aed'; }
      try{ cfgAccent.value = toColorHex(currentAccent); }catch{ cfgAccent.value = '#22d3ee'; }
      // build presets if empty
      if(presetRow && !presetRow.hasChildNodes()){
        THEMES.forEach((t,idx)=>{
          const btn=document.createElement('button');
          btn.className='btn';
          btn.style.display='flex';
          btn.style.alignItems='center';
          btn.style.gap='6px';
          btn.title=t.name;
          const sw1=document.createElement('span'); sw1.style.width='14px'; sw1.style.height='14px'; sw1.style.borderRadius='4px'; sw1.style.background=t.primary;
          const sw2=document.createElement('span'); sw2.style.width='14px'; sw2.style.height='14px'; sw2.style.borderRadius='4px'; sw2.style.background=t.accent;
          const label=document.createElement('span'); label.textContent=t.name; label.style.fontSize='11px'; label.style.color='var(--muted)';
          btn.append(sw1,sw2,label);
          btn.addEventListener('click',()=>{
            cfgPrimary.value = t.primary; cfgAccent.value = t.accent;
            // live preview
            document.documentElement.style.setProperty('--primary',t.primary);
            document.documentElement.style.setProperty('--accent',t.accent);
            particleColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
          });
          presetRow.append(btn);
        });
      }
      cfgOverlay.style.display='block';
      cfgModal.style.display='block';
    }
    function closeCfg(){ cfgOverlay.style.display='none'; cfgModal.style.display='none'; }
    function toColorHex(v){
      // supports already-hex or rgb(a)
      if(/^#/.test(v)) return v;
      const m = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if(m){
        const r = Number(m[1]).toString(16).padStart(2,'0');
        const g = Number(m[2]).toString(16).padStart(2,'0');
        const b = Number(m[3]).toString(16).padStart(2,'0');
        return `#${r}${g}${b}`;
      }
      return v || '#000000';
    }
    function saveCfg(){
      CONFIG.brand = {
        name: cfgName.value?.trim() || DEFAULT_CONFIG.brand.name,
        primary: cfgPrimary.value || DEFAULT_CONFIG.brand.primary,
        accent: cfgAccent.value || DEFAULT_CONFIG.brand.accent
      };
      persistConfig();
      applyConfig();
      closeCfg();
    }
    // live preview on color change
    cfgPrimary?.addEventListener('input', ()=>{
      document.documentElement.style.setProperty('--primary', cfgPrimary.value);
    });
    cfgAccent?.addEventListener('input', ()=>{
      document.documentElement.style.setProperty('--accent', cfgAccent.value);
      particleColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    });
    function resetCfg(){
      CONFIG = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      persistConfig();
      applyConfig();
      closeCfg();
    }
  styleBtn?.addEventListener('click', openCfg);
    cfgOverlay?.addEventListener('click', closeCfg);
    document.getElementById('cfgClose')?.addEventListener('click', closeCfg);
    document.getElementById('cfgSave')?.addEventListener('click', saveCfg);
    document.getElementById('cfgReset')?.addEventListener('click', resetCfg);
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && cfgModal.style.display==='block'){ closeCfg(); }});
  // keyboard shortcut to open style modal
  document.addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='t' && cfgModal.style.display!=='block'){ openCfg(); }});
    // UI visibility modes: 'show' | 'auto' | 'hide'
    const uiBtn=document.getElementById('uiBtn');
    const uiKey='uiMode';
    let uiMode = localStorage.getItem(uiKey) || 'auto';
    let uiTimer=null;
    function applyUiMode(){
      document.body.classList.remove('ui-hidden','ui-auto','ui-showing');
      if(uiMode==='hide'){
        document.body.classList.add('ui-hidden');
        uiBtn.textContent='üëÅÔ∏è Hidden';
      } else if(uiMode==='show'){
        uiBtn.textContent='üëÅÔ∏è Shown';
      } else {
        document.body.classList.add('ui-auto','ui-showing');
        uiBtn.textContent='üëÅÔ∏è Auto';
        scheduleUiHide();
      }
    }
    function cycleUi(){
      uiMode = uiMode==='auto' ? 'show' : uiMode==='show' ? 'hide' : 'auto';
      localStorage.setItem(uiKey, uiMode);
      applyUiMode();
    }
    function scheduleUiHide(){
      if(uiTimer) clearTimeout(uiTimer);
      uiTimer=setTimeout(()=>{
        if(uiMode==='auto'){
          document.body.classList.remove('ui-showing');
        }
      }, 1800);
    }
    uiBtn.addEventListener('click',cycleUi);
    // show on activity
    ['mousemove','mousedown','touchstart','keydown'].forEach(evt=>{
      document.addEventListener(evt,()=>{
        if(uiMode==='auto'){
          document.body.classList.add('ui-showing');
          scheduleUiHide();
        }
      }, {passive:true});
    });
  const bgBtnEl = document.getElementById('bgBtn');
  if (bgBtnEl){ bgBtnEl.addEventListener('click', cycleBackground); }
    // Fullscreen toggle
    const fsBtn=document.getElementById('fsBtn');
    if(fsBtn){fsBtn.addEventListener('click',toggleFullscreen);}    
    document.addEventListener('fullscreenchange',()=>{
      fsBtn.textContent = document.fullscreenElement ? '‚õ∂ Exit Fullscreen' : '‚õ∂ Fullscreen';
    });
    function toggleFullscreen(){
      if(!document.fullscreenElement){document.documentElement.requestFullscreen?.();}
      else{document.exitFullscreen?.();}
    }
    // Drawer (thumbs) toggle
    const drawerKey='thumbsCollapsed';
    const drawerBtn=document.createElement('button');
    drawerBtn.className='btn';
    drawerBtn.id='drawerBtn';
    drawerBtn.title='Toggle Slides List';
    drawerBtn.textContent='üß≠ Slides';
    document.querySelector('.deck-tools').prepend(drawerBtn);
    const scrimEl=document.getElementById('scrim');
    function isOverlay(){ return window.innerWidth < 1024; }
    function setDrawerUI(){
      const collapsed = localStorage.getItem(drawerKey)==='1';
      const open = localStorage.getItem('drawerOpen')==='1';
      const overlay = isOverlay();
      thumbsRoot.classList.remove('collapsed','overlay','open');
      if(overlay){
        thumbsRoot.classList.add('overlay');
        if(open){thumbsRoot.classList.add('open');}
        scrimEl.style.display = open ? 'block' : 'none';
        drawerBtn.textContent = 'üß≠ Slides';
        drawerBtn.title = open ? 'Hide slides' : 'Show slides';
      } else {
        thumbsRoot.classList.toggle('collapsed',collapsed);
        scrimEl.style.display = 'none';
        drawerBtn.textContent = 'üß≠ Slides';
        drawerBtn.title = collapsed ? 'Show slides' : 'Hide slides';
      }
    }
    function toggleDrawer(){
      if(isOverlay()){
        const open = !(localStorage.getItem('drawerOpen')==='1');
        localStorage.setItem('drawerOpen', open ? '1' : '0');
      } else {
        const collapsed = !(localStorage.getItem(drawerKey)==='1');
        localStorage.setItem(drawerKey, collapsed ? '1' : '0');
      }
      setDrawerUI();
    }
    drawerBtn.addEventListener('click',toggleDrawer);
    scrimEl.addEventListener('click',()=>{localStorage.setItem('drawerOpen','0'); setDrawerUI();});
    window.addEventListener('resize', setDrawerUI);
  // initialize background mode at startup
  setBgButtonLabel();
    // Respect reduced motion: if particles requested but user prefers reduced, fall back
  if (prefersReduced && bgMode === 'particles') bgMode = 'gradient';
  setBackgroundMode(bgMode);
  // Apply CONFIG after initial styles are ready
  applyConfig();
  // keyboard shortcut: 'b' to toggle background
    document.addEventListener('keydown', (e)=>{ 
      const k=e.key.toLowerCase();
  if(k==='b') cycleBackground();
  if(k==='f') toggleFullscreen();
      if(k==='s') toggleDrawer();
      if(k==='u') cycleUi();
    });
    // Initialize drawer UI from persisted state
    setDrawerUI();
    // Initialize UI visibility mode
    applyUiMode();
    function toggleNotes(){notesEl.classList.toggle('show');}

  // Removed legacy particle helpers in favor of unified background system above

    // Support hash deep-linking
    window.addEventListener('hashchange',()=>{
      const m=location.hash.match(/#\/(\d+)/); 
      if(m){
        const idx=parseInt(m[1])-1; 
        if(idx>=0 && idx<slidesHTML.length) setActive(idx);
      } 
    });

    // Simple test demo with extensive notes to test scrolling
    const DEMO_MD = `---
title: Test Slide with Long Notes
notes: These are extensive speaker notes to test the scrolling functionality. Lorem ipsum dolor sit amet consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium totam rem aperiam eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.
---

# Hello World

This should work without frontmatter showing.

---
title: Slide with Bullet Points
notes: Key talking points for this slide - Enhanced markdown support with lists links images and blockquotes - Mobile touch gestures and cross-platform compatibility - Content security and XSS prevention measures - Error handling and file validation features - Smooth transitions and improved user experience - Single-file architecture benefits - Backwards compatibility with existing presentations - Accessibility features that were added to improve usability
---

## Second Slide

* This slide has bullet points
* Multiple items in a list  
* **Bold text** and *italic text*
* Links and other markdown features

---
title: Slide with Structured Notes  
notes: INTRODUCTION - Welcome the audience and introduce the presentation topic. MAIN POINTS - Technical Architecture including single-file design philosophy and no external dependencies. Feature Set covers enhanced markdown parsing mobile-responsive design theme switching and speaker notes functionality. Implementation Details include content sanitization file validation error handling and smooth animations. CONCLUSION - Summarize key benefits and invite audience questions. TIMING - Spend 3 minutes per main point and reserve 5 minutes for questions.
---

## Third Slide

**Bold text** and *italic text* work great.

> This is a blockquote to test enhanced markdown support.

---
title: Final Slide Notes
notes: WRAP-UP SECTION - Thank the audience for their attention and participation. Recap the main achievements including enhanced security better user experience mobile support and comprehensive markdown features. Mention that source code is available for experimentation and customization. Provide contact information for follow-up questions. Ask for feedback about the presentation and features. End with positive remarks about the future of web-based presentation tools.
---

## Final Slide

Thank you for testing the enhanced SlideApp!

Use the Notes button to see extensive speaker notes with scrolling.`;

    console.log('Starting SlideApp...');
    console.log('Raw DEMO_MD:', DEMO_MD);
    slidesHTML=splitSlides(DEMO_MD);
    console.log('Parsed slides:', slidesHTML.length);
    console.log('First slide HTML:', slidesHTML[0]?.html);
    renderSlides(slidesHTML);
  </script>
</body>
</html>
