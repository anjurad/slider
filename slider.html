<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SlideApp v0.9.1 ‚Äî Optimised & Secure</title>
  <!-- Favicon (fixed stray quote) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>">
  <link rel="stylesheet" href="assets/app.css">
    <script>
      // Global helper for test-driven deterministic behavior.
      // Usage: if (window.__isDeterministicTestMode && window.__isDeterministicTestMode()) { ... }
      try{
        window.__isDeterministicTestMode = function(){
          try{
            if (window.__SLIDEAPP_TEST_DETERMINISTIC === true) return true;
            if (window.location && window.location.search){ const p = new URLSearchParams(window.location.search); if (p.get('deterministicTest') === '1') return true; }
          }catch(e){}
          return false;
        };
      }catch(e){}
    </script>
</head>
<body>
  <!-- Optional shared core for theming helpers (provides window.ThemeCore) -->
  <script src="src/shared/theme-core.js"></script>
  <!-- Centralized config schema (provides window.ConfigSchema) -->
  <script src="src/config/schema.js"></script>
  <!-- Optional runtime theming helpers (no behavior change if absent) -->
  <script src="src/runtime/theme.js"></script>
  <!-- Particles runtime: provides start/stop/resize for canvas effects -->
  <script src="src/runtime/particles.js"></script>
  <!-- Toast util -->
  <script src="src/ui/toast.js"></script>
  <!-- Background toggle helper -->
  <script src="src/ui/backgroundToggle.js"></script>
  <!-- Notes controller -->
  <script src="src/ui/notes.js"></script>
  <!-- Drawer controller -->
  <script src="src/ui/drawer.js"></script>
  <!-- Overlay controller -->
  <script src="src/ui/overlay.js"></script>
  <script src="src/ui/styleModal.js"></script>
  <div class="bg-gradient"></div>
  <canvas id="bg-canvas"></canvas>
  <div id="scrim"></div>
  <div class="thumbs" id="thumbs"></div>

  <div class="deck">
    <div class="deck-header">
  <div class="brand"><div class="brand-badge"></div><div class="brand-name" id="appName">SlideApp</div></div>
      <div class="deck-tools">
        <button class="btn" id="uiBtn" title="Toggle UI visibility" aria-label="Toggle UI">üëÅÔ∏è UI</button>
        <button class="btn" id="decksBtn" style="display:none" title="Open Decks" aria-label="Open Decks">üìö Decks</button>
        <input type="file" id="fileInput" class="btn" accept=".md,.markdown,.txt" title="Load Markdown" aria-label="Load Markdown" />
        <button class="btn" id="styleBtn" title="Style settings" aria-label="Style">üé® Style</button>
        <button class="btn" id="validateBtn" title="Validate deck frontmatter" aria-label="Validate">üîé Validate</button>
        <button class="btn" id="tocBtn" title="Table of contents" aria-label="Table of contents">üìë TOC</button>
  <button class="btn" id="overlayBtn" title="Toggle title/subtitle overlay" aria-label="Overlay">üè∑Ô∏è Title</button>
        <button class="btn" id="bgBtn" title="Toggle Background" aria-label="Background">üåå Background</button>
        <button class="btn" id="notesBtn" aria-label="Notes">üìù Notes</button>
        <button class="btn" id="fsBtn" title="Toggle Fullscreen" aria-label="Fullscreen">‚õ∂ Fullscreen</button>
        <button class="btn" onclick="window.print()" aria-label="Print to PDF">üìÑ PDF</button>
        <button class="btn" id="drawerBtn" title="Slide thumbnails" aria-label="Slide thumbnails">üß≠ Slides</button>
      </div>
    </div>

    <main class="slides" id="slides" role="region" aria-live="polite" aria-label="Slide 1 of N"></main>
    <footer class="deck-footer">
      <div><button class="btn" id="btnPrev" aria-label="Previous slide">‚óÄ</button><button class="btn" id="btnNext" aria-label="Next slide">‚ñ∂</button></div>
      <div class="progress"><span id="progress"></span></div>
      <div id="slideNo">0/0</div>
    </footer>
    <div class="notes" id="notes"></div>
    <!-- Toast notification -->
    <div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true"></div>
  </div>

  <!-- Style Config Modal -->
  <div id="cfgOverlay"></div>
  <div id="cfgModal" role="dialog" aria-modal="true" aria-labelledby="cfgTitle">
    <header>
      <strong id="cfgTitle">Style Settings</strong>
      <button class="btn" id="cfgClose" aria-label="Close" type="button">‚úï</button>
    </header>
    <main>
      <label for="cfgName">App name</label>
      <input id="cfgName" type="text" placeholder="SlideApp" />
      <label>Presets</label>
      <div id="presetRow" class="row" style="margin-bottom:6px"></div>
      <div class="row">
        <div style="flex:1">
          <label for="cfgPrimary">Primary color</label>
          <input id="cfgPrimary" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgAccent">Accent color</label>
          <input id="cfgAccent" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:6px; gap:12px; align-items:flex-end;">
        <div style="flex:1">
          <label for="cfgTextColor">General text color</label>
          <input id="cfgTextColor" type="color" />
        </div>
        <div style="flex:1">
          <label>Buttons</label>
          <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
            <label style="font-size:12px;">Text</label>
            <select id="cfgBtnTextMode" class="btn" style="padding:6px 8px; min-width:96px;">
              <option value="auto">Auto</option>
              <option value="custom">Custom</option>
            </select>
            <input id="cfgBtnTextColor" type="color" />
            <label style="font-size:12px; margin-left:8px;">Fill</label>
            <select id="cfgBtnFill" class="btn" style="padding:6px 8px; min-width:120px;">
              <option value="solid">Solid</option>
              <option value="outline">Outline</option>
            </select>
            <label style="font-size:12px; margin-left:8px;" for="cfgBtnBorderWidth">Border width <span id="cfgBtnBorderWidthVal" aria-hidden="true"></span></label>
            <input id="cfgBtnBorderWidth" type="range" min="1" max="6" step="1" style="width:140px;" />
          </div>
        </div>
      </div>
      <div class="row" style="margin-top:8px; gap:8px;">
        <div style="flex:1">
          <label for="cfgAppBg1">App background start</label>
          <input id="cfgAppBg1" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgAppBg2">App background end</label>
          <input id="cfgAppBg2" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:8px; gap:8px;">
        <div style="flex:1">
          <label for="cfgSlideBg1">Slide background start</label>
          <input id="cfgSlideBg1" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgSlideBg2">Slide background end</label>
          <input id="cfgSlideBg2" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:8px; align-items: flex-end; gap: 10px;">
        <div style="flex:1">
          <label for="cfgSlideOpacity">Slide background opacity <span id="cfgSlideOpacityVal" aria-hidden="true"></span></label>
          <input id="cfgSlideOpacity" type="range" min="0" max="100" step="1" />
        </div>
        <div>
          <button class="btn" id="btnClearOpacity" title="Make background fully transparent">Clear</button>
        </div>
      </div>

      <label style="margin-top:10px">Config (external)</label>
      <div class="row" style="gap:8px; align-items:center; flex-wrap:nowrap; overflow-x:auto;">
        <div style="flex:0 0 auto;">
          <label for="cfgConfigUrl" style="display:block; font-size:12px;">Load from URL</label>
          <input id="cfgConfigUrl" type="text" placeholder="https://example.com/slideapp-config.json" style="width:360px; max-width:60vw;" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgLoadUrl">Load</button>
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgImportBtn">Import JSON</button>
          <input id="cfgImportFile" type="file" accept="application/json,.json" style="display:none" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgExport">Export</button>
        </div>
      </div>
      <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
          <input id="cfgPersistConfig" type="checkbox" /> Persist config to this browser
        </label>
        <span style="font-size:12px; opacity:.85;">When off, changes apply for this session only.</span>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:center; flex-wrap: wrap;">
    <label style="margin:0; font-size:12px;">UI visibility when OFF</label>
        <div style="display:flex; gap:10px; align-items:center;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgHideSlidesWithUi" type="checkbox" /> Hide slides panel
          </label>
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgHideProgressWithUi" type="checkbox" /> Hide progress bar
          </label>
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgSlideOutline" type="checkbox" /> Slide outline
          </label>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:center; flex-wrap: wrap;">
        <div style="flex:1">
          <label for="cfgOutlineWidth">Outline width <span id="cfgOutlineWidthVal" aria-hidden="true"></span></label>
          <input id="cfgOutlineWidth" type="range" min="0" max="8" step="1" />
        </div>
        <div style="flex:1">
          <label style="display:block; font-size:12px;">Deck restore</label>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
            <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
              <input id="cfgRememberDeck" type="checkbox" /> Remember last deck (persist)
            </label>
            <button class="btn" id="cfgForgetDeck" title="Forget stored deck">Forget deck</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-end; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgOverlayTitleOn" type="checkbox" /> Show slide title (overlay)
          </label>
          <div style="display:flex; gap:6px; align-items:center; margin-top:6px; flex-wrap: wrap;">
            <label style="font-size:12px;">Position</label>
            <span id="cfgOverlayPosHint" style="display:none; font-size:12px; opacity:.8;">Enable overlay to change</span>
            <div id="cfgOverlayPos" role="group" aria-label="Title position" style="display:flex; gap:6px;">
              <button type="button" class="btn" data-pos="tl">TL</button>
              <button type="button" class="btn" data-pos="tr">TR</button>
              <button type="button" class="btn" data-pos="bl">BL</button>
              <button type="button" class="btn" data-pos="br">BR</button>
            </div>
          </div>
          <label for="cfgTitleSize">Title size <span id="cfgTitleSizeVal" aria-hidden="true"></span></label>
          <input id="cfgTitleSize" type="range" min="12" max="64" step="1" />
        </div>
        <div style="flex:1; min-width:210px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgOverlaySubtitleOn" type="checkbox" /> Show subtitle (if present)
          </label>
          <label for="cfgSubtitleSize">Subtitle size <span id="cfgSubtitleSizeVal" aria-hidden="true"></span></label>
          <input id="cfgSubtitleSize" type="range" min="10" max="48" step="1" />
          <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
            <label style="font-size:12px;">Subtitle color</label>
            <select id="cfgSubtitleColor" class="btn" style="padding:6px 8px;">
              <option value="primary">Primary</option>
              <option value="accent">Accent</option>
            </select>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-start; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label style="display:block; font-size:12px;">Content position</label>
          <div id="cfgContentPos" role="group" aria-label="Content position" style="display:grid; grid-template-columns: repeat(3, auto); gap:6px; width:max-content;">
            <button type="button" class="btn" data-pos="tl">TL</button>
            <button type="button" class="btn" data-pos="tm">TM</button>
            <button type="button" class="btn" data-pos="tr">TR</button>
            <button type="button" class="btn" data-pos="ml">ML</button>
            <button type="button" class="btn" data-pos="mm">MM</button>
            <button type="button" class="btn" data-pos="mr">MR</button>
            <button type="button" class="btn" data-pos="bl">BL</button>
            <button type="button" class="btn" data-pos="bm">BM</button>
            <button type="button" class="btn" data-pos="br">BR</button>
          </div>
          <span style="display:block; font-size:12px; opacity:.8; margin-top:4px;">Affects Markdown block position inside the slide.</span>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-start; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label for="cfgFontPrimary">Primary font (headings/title)</label>
          <input id="cfgFontPrimary" type="text" placeholder="Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif" />
        </div>
        <div style="flex:1; min-width:210px;">
          <label for="cfgFontSecondary">Secondary font (body/subtitle)</label>
          <input id="cfgFontSecondary" type="text" placeholder="Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif" />
        </div>
      </div>
    </main>
    <footer>
      <button class="btn" id="cfgReset" title="Reset to defaults" type="button">‚Ü∫ Reset</button>
      <button class="btn" id="cfgSave" type="button">Save</button>
    </footer>
  </div>
  <!-- Validation modal -->
  <div id="valOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:30"></div>
  <div id="valModal" role="dialog" aria-modal="true" aria-labelledby="valTitle" style="position:fixed;top:40px;bottom:40px;left:40px;right:40px;width:auto;max-width:none;background:linear-gradient(135deg,var(--app-bg1, #0b1220),var(--app-bg2, #0f172a));color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31;flex-direction:column">
    <header style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);flex:0 0 auto">
      <h3 id="valTitle" style="margin:0;font-weight:600">Deck Validation</h3>
      <button class="btn" id="valClose">Close</button>
    </header>
    <main id="valBody" style="padding:14px;overflow:auto;flex:1 1 auto;font-size:14px;line-height:1.4"></main>
    <footer style="display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);flex:0 0 auto;background:linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));backdrop-filter:blur(4px)">
      <button class="btn" id="valOk">OK</button>
    </footer>
  </div>
  <div id="tocOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:30"></div>
  <div id="tocModal" role="dialog" aria-modal="true" aria-labelledby="tocTitle" style="position:fixed;top:40px;bottom:40px;left:40px;right:40px;width:auto;max-width:none;background:linear-gradient(135deg,var(--app-bg1, #0b1220),var(--app-bg2, #0f172a));color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31;flex-direction:column">
    <header style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);flex:0 0 auto">
      <h3 id="tocTitle" style="margin:0;font-weight:600">Table of Contents</h3>
      <button class="btn" id="tocClose">Close</button>
    </header>
    <main id="tocBody" style="padding:14px;overflow:auto;flex:1 1 auto;font-size:14px;line-height:1.4"></main>
    <footer style="display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);flex:0 0 auto;background:linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));backdrop-filter:blur(4px)">
      <button class="btn" id="tocOk">OK</button>
    </footer>
  </div>

  <script>
  const DEBUG=false; const dlog=(...a)=>{ if(DEBUG) console.log(...a); };

  // ===== UI elements =====
  const slidesRoot=document.getElementById('slides');
  const thumbsRoot=document.getElementById('thumbs');
  const notesEl=document.getElementById('notes');
  const appNameEl=document.getElementById('appName');
  const drawerBtn=document.getElementById('drawerBtn');
  const scrimEl=document.getElementById('scrim');

  // ===== Background (particles/gradient/off) =====
  const bgCanvas=document.getElementById('bg-canvas'); const ctx = bgCanvas.getContext('2d');
  let bgMode = localStorage.getItem('bgMode')||'gradient';
  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  // Particle runtime now lives in src/runtime/particles.js and is exposed via window.Particles.
  // Legacy in-file particle state removed to avoid duplication; runtime manages its own state.

  // Helper to rebuild overlays on all current slides using CONFIG and per-slide frontmatter
  function rebuildOverlays(tempPos){
    try{
      if(window.OverlayCtrl && typeof window.OverlayCtrl.rebuildOverlays==='function'){
        return window.OverlayCtrl.rebuildOverlays(tempPos);
      }
    }catch(e){}
    // Fallback (should rarely run): no-op if controller missing
    try{
      const slides = [...document.querySelectorAll('.slide')];
      slides.forEach(s => { s.querySelector('.slide-overlay')?.remove(); });
    }catch(e){}
  }

  // Particle lifecycle is implemented in `src/runtime/particles.js` and exposed via window.Particles
  // Delegate resize handling to the runtime; runtime is expected to manage canvas sizing.
  function resizeCanvas(){ try{ if(window && window.Particles && typeof window.Particles.resize === 'function') window.Particles.resize(); }catch{} }
  function setBgButtonLabel(){
    if(window.BackgroundToggle && typeof window.BackgroundToggle.setBgButtonLabel==='function'){
      window.BackgroundToggle.setBgButtonLabel(bgMode);
    } else {
      document.getElementById('bgBtn').textContent = (bgMode==='gradient'?'üåå Background':bgMode==='particles'?'‚ú® Particles':'‚õî Background Off');
    }
  }
  function setBackgroundMode(mode){
    bgMode = mode;
    if(window.BackgroundToggle && typeof window.BackgroundToggle.setBackgroundMode==='function'){
      window.BackgroundToggle.setBackgroundMode(mode, { canvas: bgCanvas, particles: (window.Particles||null), prefersReduced });
    } else {
      try{ localStorage.setItem('bgMode', bgMode); }catch{}
      setBgButtonLabel();
      if (bgMode === 'off'){
        try{ if(window && window.Particles && typeof window.Particles.stop === 'function') window.Particles.stop(); }catch{}
        bgCanvas.style.display = 'none';
        document.querySelector('.bg-gradient').style.display = 'none';
      } else if (bgMode === 'gradient'){
        try{ if(window && window.Particles && typeof window.Particles.stop === 'function') window.Particles.stop(); }catch{}
        bgCanvas.style.display = 'none';
        document.querySelector('.bg-gradient').style.display = 'block';
      } else {
        document.querySelector('.bg-gradient').style.display = 'none';
        bgCanvas.style.display = 'block';
        try{ if(window && window.Particles && typeof window.Particles.start === 'function') window.Particles.start({ prefersReduced }); }catch{}
      }
    }
  }
  const cycleBackground=()=>{ 
    if(window.BackgroundToggle && typeof window.BackgroundToggle.cycleBackground==='function'){
      const next = window.BackgroundToggle.cycleBackground(bgMode);
      setBackgroundMode(next);
    } else {
      const order=['gradient','particles','off']; setBackgroundMode(order[(order.indexOf(bgMode)+1)%order.length]);
    }
    try{ showToast(`Background: ${bgMode}`);}catch{}
  };
  let resizeTimer=null; window.addEventListener('resize',()=>{ if(bgMode!=='particles') return; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ try{ if(window && window.Particles && typeof window.Particles.resize === 'function') window.Particles.resize(); }catch{} },120); });

  // ===== Config & Theme =====
  const CONFIG = JSON.parse(localStorage.getItem('slideapp.config')||'{}');
  // Expose CONFIG globally so UI modules (e.g., Style modal) operate on the same object
  try{ window.CONFIG = CONFIG; }catch{}
  // Whether to persist config changes to localStorage (default: true for backward-compat)
  let PERSIST_CONFIG = (()=>{ try{ const v = localStorage.getItem('slideapp.config.persist'); if(v===null) return true; return v==='1' || String(v).toLowerCase()==='true'; }catch{} return true; })();
  try{ window.PERSIST_CONFIG = PERSIST_CONFIG; }catch{}
  // Baseline opacity for T-key toggle: use last saved value from persisted config; fallback to 1 (100%).
  let BASE_OPACITY = (()=>{ try{ const saved=JSON.parse(localStorage.getItem('slideapp.config')||'{}'); const v=saved && typeof saved.slideOpacity==='number' ? saved.slideOpacity : undefined; if(typeof v==='number' && isFinite(v)) return Math.max(0, Math.min(1, v)); }catch{} return 1; })();
  try{ window.BASE_OPACITY = BASE_OPACITY; }catch{}
  // Back-compat: migrate legacy brand -> appName if needed (do not delete brand to avoid breaking older versions)
  if(typeof CONFIG.appName !== 'string' && typeof CONFIG.brand === 'string'){
    CONFIG.appName = CONFIG.brand;
  }
  const PRESETS=[
  // Default preset (used when no saved config exists)
  {name:'Default', primary:'#01B4E1', accent:'#64FFFC', textColor:'#e2e8f0', group:'default', appBg1:'#0f172a', appBg2:'#1e293b', slideBg1:'#111827', slideBg2:'#111827'},
  // Dark presets (order shown in modal)
  {name:'Dark 1', primary:'#01B4E1', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#0f1723', appBg2:'#111827', slideBg1:'#111827', slideBg2:'#111827'},
  {name:'Dark 2', primary:'#232337', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#0b1220', appBg2:'#111827', slideBg1:'#0f1723', slideBg2:'#111827'},
  {name:'Dark 3', primary:'#01B4E1', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#000000', appBg2:'#0b0b0b', slideBg1:'#000000', slideBg2:'#0b0b0b'},
  // Light presets
  {name:'Light 1', primary:'#086384', accent:'#64FFFC', textColor:'#0b1220', group:'light', appBg1:'#f8fafc', appBg2:'#eef2ff', slideBg1:'#ffffff', slideBg2:'#f8fafc'},
  {name:'Light 2', primary:'#50677B', accent:'#01B4E1', textColor:'#0b1220', group:'light', appBg1:'#f8fafc', appBg2:'#ffffff', slideBg1:'#ffffff', slideBg2:'#f7fbff'},
  {name:'Light 3', primary:'#01B4E1', accent:'#50677B', textColor:'#0b1220', group:'light', appBg1:'#ffffff', appBg2:'#ffffff', slideBg1:'#ffffff', slideBg2:'#ffffff'}
  ];

  // If no theme values in saved CONFIG, apply the Default preset (non-persistent) so the UI shows a consistent base
  (function applyDefaultIfMissing(){
    try{
      const hasAny = (typeof CONFIG.primary === 'string' && CONFIG.primary.trim()) || (typeof CONFIG.accent === 'string' && CONFIG.accent.trim()) || (typeof CONFIG.appBg1 === 'string' && CONFIG.appBg1.trim()) || (typeof CONFIG.textColor === 'string' && CONFIG.textColor.trim());
      if(!hasAny){
        const def = PRESETS.find(p=>p.name==='Default');
        if(def){
          CONFIG.primary = def.primary; CONFIG.accent = def.accent; CONFIG.textColor = def.textColor; CONFIG.appBg1 = def.appBg1; CONFIG.appBg2 = def.appBg2; CONFIG.slideBg1 = def.slideBg1; CONFIG.slideBg2 = def.slideBg2;
        }
      }
    }catch(e){}
  })();
  // Default outline setting: on when not present
  if(typeof CONFIG.slideBorderOn !== 'boolean') CONFIG.slideBorderOn = true;
  // Default outline width (px)
  if(typeof CONFIG.slideBorderWidth !== 'number') CONFIG.slideBorderWidth = 3;
  // Overlay & typography defaults (with migration from previous keys)
  if(typeof CONFIG.overlayOn !== 'boolean'){
    if(typeof CONFIG.overlayTitleOn === 'boolean') CONFIG.overlayOn = CONFIG.overlayTitleOn; else CONFIG.overlayOn = false;
  }
  if(typeof CONFIG.overlayPos !== 'string'){
    if(typeof CONFIG.overlayTitlePos === 'string') CONFIG.overlayPos = CONFIG.overlayTitlePos; else CONFIG.overlayPos = 'tl';
  }
  if(typeof CONFIG.overlayTitleSize !== 'number') CONFIG.overlayTitleSize = (typeof CONFIG.overlayTitleSize==='number'?CONFIG.overlayTitleSize:22);
  if(typeof CONFIG.overlaySubtitleOn !== 'boolean') CONFIG.overlaySubtitleOn = (typeof CONFIG.overlaySubtitleOn==='boolean'?CONFIG.overlaySubtitleOn:true);
  if(typeof CONFIG.overlaySubtitleSize !== 'number') CONFIG.overlaySubtitleSize = (typeof CONFIG.overlaySubtitleSize==='number'?CONFIG.overlaySubtitleSize:16);
  // Subtitle color option: 'primary' | 'accent'
  if(typeof CONFIG.overlaySubtitleColor !== 'string') CONFIG.overlaySubtitleColor = 'primary';
  // Clean legacy keys
  delete CONFIG.overlayTitleOn; delete CONFIG.overlayTitlePos;
  if(typeof CONFIG.fontPrimary !== 'string') CONFIG.fontPrimary = 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
  // Content position default
  if(typeof CONFIG.contentPos !== 'string') CONFIG.contentPos = 'tl';

  // ---- External config: schema, validation, merge, persistence ----
  const CONFIG_KEYS = (window.ConfigSchema && window.ConfigSchema.KEY_SET) ? window.ConfigSchema.KEY_SET : new Set();

  function sanitizeConfig(input){
    try{ if(window.ConfigSchema && typeof window.ConfigSchema.sanitizeConfig==='function'){ return window.ConfigSchema.sanitizeConfig(input); } }catch{}
    return {};
  }

  function mergeConfig(incoming, mode){
    const safe = sanitizeConfig(incoming);
    if(mode==='replace'){
      for(const k of Array.from(CONFIG_KEYS)) delete CONFIG[k];
    }
    Object.assign(CONFIG, safe);
    try{ if(window.Theme && typeof window.Theme.applyConfig==='function'){ window.Theme.applyConfig(CONFIG); } else { applyConfig(); } }catch{}
    return safe;
  }

  async function loadConfigFromUrl(url){
    try{
      const res = await fetch(url, { credentials: 'omit' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      const applied = mergeConfig(data, 'merge');
      if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} }
      try{ showToast('Config loaded'); }catch{}
      return applied;
    }catch(err){ try{ showToast('Failed to load config'); }catch{} console.error('Config load failed', err); return {}; }
  }

  function exportConfigBlob(){
    const data = sanitizeConfig(CONFIG);
    const blob = new Blob([JSON.stringify(data,null,2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='slideapp-config.json'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250);
  }

  // postMessage API: { type:'slider.config', action:'set|merge|replace', config:{...} }
  window.addEventListener('message', (ev)=>{
    try{
      const msg = ev.data || {};
      if(!msg || msg.type!=='slider.config') return;
      const action = (msg.action||'merge').toLowerCase();
      const cfg = msg.config || {};
      const mode = (action==='replace' || (action==='set' && msg.mode==='replace')) ? 'replace' : 'merge';
      const applied = mergeConfig(cfg, mode);
      if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} }
      ev.source && ev.source.postMessage && ev.source.postMessage({ type:'slider.config.result', ok:true, applied }, '*');
    }catch(e){ try{ ev.source && ev.source.postMessage && ev.source.postMessage({ type:'slider.config.result', ok:false, error:String(e&&e.message||e) }, '*'); }catch{} }
  });
  if(typeof CONFIG.fontSecondary !== 'string') CONFIG.fontSecondary = 'Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  // Opacity control: 100 equals default look (0.75/0.55); 0 is fully transparent
  function setSlideOpacity(val, persist = true){
    let v = Number(val);
    if(!isFinite(v)) v = 100;
  // Normalize to integer percent first to avoid float drift when values come from saved decimal * 100
  v = Math.round(Math.max(0, Math.min(100, v)));
  const dec = v / 100;
    const base1 = 0.75, base2 = 0.55;
  const o1 = (base1 * dec).toFixed(3);
  const o2 = (base2 * dec).toFixed(3);
    
  // Set the CSS variables that are used in the .slide background
    // Prefer configured slideBg colors if present (stored as #rrggbb)
    try{
      // Prefer runtime computation for derived slide background vars when available
      if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
        try{
          const outcome = window.Theme.computeApplyConfigOutcome({ slideBg1: CONFIG.slideBg1, slideBg2: CONFIG.slideBg2, slideOpacity: dec });
          if(outcome && outcome.cssVars){
            if(typeof outcome.cssVars['--slide-bg1'] === 'string') document.documentElement.style.setProperty('--slide-bg1', outcome.cssVars['--slide-bg1']);
            if(typeof outcome.cssVars['--slide-bg2'] === 'string') document.documentElement.style.setProperty('--slide-bg2', outcome.cssVars['--slide-bg2']);
          }
        }catch(err){
          // fall back to legacy local computation below
          const s1 = (typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) ? normalizeHex(CONFIG.slideBg1) : null;
          const s2 = (typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) ? normalizeHex(CONFIG.slideBg2) : null;
          if(s1){ const c = hexToRgb(s1); if(c) document.documentElement.style.setProperty('--slide-bg1', `rgba(${c.r},${c.g},${c.b},${o1})`); else document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); } else { document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); }
          if(s2){ const c = hexToRgb(s2); if(c) document.documentElement.style.setProperty('--slide-bg2', `rgba(${c.r},${c.g},${c.b},${o2})`); else document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); } else { document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
        }
      } else {
        const s1 = (typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) ? normalizeHex(CONFIG.slideBg1) : null;
        const s2 = (typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) ? normalizeHex(CONFIG.slideBg2) : null;
        if(s1){ const c = hexToRgb(s1); if(c) document.documentElement.style.setProperty('--slide-bg1', `rgba(${c.r},${c.g},${c.b},${o1})`); else document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); } else { document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); }
        if(s2){ const c = hexToRgb(s2); if(c) document.documentElement.style.setProperty('--slide-bg2', `rgba(${c.r},${c.g},${c.b},${o2})`); else document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); } else { document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
      }
    }catch(e){ document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
  // Also scale blur and shadow so 0% is truly clear
  const blurPx = (8 * dec).toFixed(2) + 'px';
  // scale the alpha of the existing shadow; base shadow is rgba(0,0,0,0.25)
  const shadowAlpha = (0.25 * dec).toFixed(3);
  const shadow = `0 10px 30px rgba(0,0,0,${shadowAlpha})`;
  document.documentElement.style.setProperty('--slide-blur', blurPx);
  document.documentElement.style.setProperty('--slide-shadow', shadow);
    
    // persist in CONFIG unless caller asked not to
    if(persist !== false){ CONFIG.slideOpacity = dec; }
  return dec;
  }
  window.setSlideOpacity = setSlideOpacity;

  // Helper: normalize hex string to #rrggbb or empty string
  function normalizeHex(input){
    try{
      if(!input) return '';
      let s = String(input).trim().replace(/['"]/g,'');
      if(!s) return '';
      if(!s.startsWith('#')) s = '#'+s;
      const m = s.slice(1);
      if(/^[0-9a-f]{3}$/i.test(m)) return '#'+m.split('').map(c=>c+c).join('').toLowerCase();
      if(/^[0-9a-f]{6}$/i.test(m)) return '#'+m.toLowerCase();
    }catch{}
    return '';
  }

  function hexToRgb(hex){
    try{
      const h = normalizeHex(hex);
      if(!h) return null;
      const v = h.slice(1);
      return { r: parseInt(v.slice(0,2),16), g: parseInt(v.slice(2,4),16), b: parseInt(v.slice(4,6),16) };
    }catch{ return null; }
  }

  // Return '#000000' or '#ffffff' for best contrast against the provided hex color.
  function bestContrastForHex(hex){
    try{
      const rgb = hexToRgb(hex);
      if(!rgb) return '#000000';
      // Relative luminance (sRGB)
      const srgb = [rgb.r, rgb.g, rgb.b].map(c=>{
        const s = c/255;
        return s <= 0.03928 ? s/12.92 : Math.pow((s+0.055)/1.055, 2.4);
      });
      const L = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
      // Use white for dark backgrounds (low L), black for light backgrounds
      return (L < 0.5) ? '#ffffff' : '#000000';
    }catch(e){ return '#000000'; }
  }

  // Thumbnails are styled via CSS variables; no JS inline styling required.

  function applyConfig(){
    // Prefer runtime Theme helper to compute and apply vars when available.
    // Call the runtime shim early; existing inline logic remains as a safe fallback
    // (idempotent) until parity is proven.
    try{
      if(window.Theme && typeof window.Theme.applyConfig === 'function'){
        try{
          // Capture outcome to help debug overwrite issues where the runtime
          // compute returns a value but the page-level apply path later
          // ends up with a different CSS var in the DOM.
          const __theme_outcome = window.Theme.applyConfig(CONFIG);
          try{
            const __computed_text = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
            // (debug instrumentation removed) capture remained for historical debugging but not exposed in CI
          }catch(logErr){ console.log('[THEME_DEBUG] applyConfig logging failed', String(logErr)); }
        }catch(e){}
      }
    }catch(e){}

    // Prefer runtime Theme helper to compute vars consistently when available
    let primaryVal, accentVal, textVal, btnTextVal;
    try{
      if(window.Theme && typeof window.Theme.computeThemeCssVars === 'function'){
        const vars = window.Theme.computeThemeCssVars({
          primary: CONFIG.primary,
          accent: CONFIG.accent,
          textColor: CONFIG.textColor,
          btnTextColor: CONFIG.btnTextColor,
          slideOpacity: CONFIG.slideOpacity
        }) || {};
        primaryVal = CONFIG.primary || vars['--primary'] || getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        accentVal  = CONFIG.accent  || vars['--accent']  || getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
        textVal    = CONFIG.textColor || vars['--text'] || getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        btnTextVal = CONFIG.btnTextColor || vars['--btn-text'] || textVal;
      }
    }catch{}
  if(!primaryVal){ primaryVal = CONFIG.primary||getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(); }
  if(!accentVal){  accentVal  = CONFIG.accent ||getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(); }
  // Theme.applyConfig handles derived CSS variables (btn-bg, btn-text, --text, etc.).
  // Ensure brand-badge reflects computed vars (no inline CSS set here).
  try{ const bb = document.querySelector('.brand-badge'); if(bb) bb.style.removeProperty('background'); }catch(e){}
    // No-op: if runtime Theme helper exists, exercise it without modifying behavior
    try{ if(window.Theme && typeof window.Theme.computeThemeCssVars === 'function'){ window.Theme.computeThemeCssVars({
      primary: CONFIG.primary, accent: CONFIG.accent, textColor: CONFIG.textColor, btnTextColor: CONFIG.btnTextColor, slideOpacity: CONFIG.slideOpacity
    }); } }catch{}
  appNameEl.textContent = (CONFIG.appName||CONFIG.brand||'SlideApp');
  // Keep document.title in sync; deck name takes precedence when present
  try{
    const deckNm = (window.__deckAppName && String(window.__deckAppName).trim()) || '';
    const cfgNm = (CONFIG.appName||CONFIG.brand||'SlideApp');
    document.title = (deckNm || cfgNm || 'SlideApp').toString();
  }catch{}
  // Apply app background colors and effect color if configured
    try{
  // Theme.applyConfig will set app background/effect/text CSS vars.
    }catch{}
    // Refresh bg-gradient visibility to reflect current bgMode preference
  try{ if(bgMode === 'gradient'){ document.querySelector('.bg-gradient').style.display = 'block'; bgCanvas.style.display='none'; } else if(bgMode === 'particles'){ document.querySelector('.bg-gradient').style.display='none'; bgCanvas.style.display='block'; if(window && window.Particles && typeof window.Particles.start === 'function') window.Particles.start({ prefersReduced }); } else { document.querySelector('.bg-gradient').style.display='none'; bgCanvas.style.display='none'; } }catch{}
    // If slide background colors changed, update computed slide CSS vars immediately
    try{
      // If CONFIG.slideBg1/2 are set, prefer runtime helper to compute rgba with current opacity; fall back to direct hex assignment
      try{
        if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
          const outcome = window.Theme.computeApplyConfigOutcome({ slideBg1: CONFIG.slideBg1, slideBg2: CONFIG.slideBg2, slideOpacity: CONFIG.slideOpacity });
          if(outcome && outcome.cssVars){
            if(typeof outcome.cssVars['--slide-bg1'] === 'string') document.documentElement.style.setProperty('--slide-bg1', outcome.cssVars['--slide-bg1']);
            else if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim());
            if(typeof outcome.cssVars['--slide-bg2'] === 'string') document.documentElement.style.setProperty('--slide-bg2', outcome.cssVars['--slide-bg2']);
            else if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim());
          }
        } else {
          if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()){
            document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim());
          }
          if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()){
            document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim());
          }
        }
      }catch(e){ if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim()); if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim()); }
    }catch{}
    // apply slide opacity if present; prefer runtime shim when available
    if(typeof CONFIG.slideOpacity === 'number'){
      try{
        if(window.Theme && typeof window.Theme.setSlideOpacity === 'function'){
          // Theme.setSlideOpacity accepts decimal 0..1 or percentage; pass decimal
          window.Theme.setSlideOpacity(CONFIG.slideOpacity);
        }else{
          // fallback: legacy call expects percent
          setSlideOpacity(CONFIG.slideOpacity * 100, false);
        }
      }catch(e){}
    }
  // Apply outline visibility
  document.body.classList.toggle('border-off', CONFIG.slideBorderOn===false);
  // Apply outline width, typography and overlay sizes via runtime helper when available.
  try{
    const partial = {
      slideBorderWidth: (typeof CONFIG.slideBorderWidth === 'number' && isFinite(CONFIG.slideBorderWidth)) ? Math.max(0, Math.min(20, Math.round(CONFIG.slideBorderWidth))) : 3,
      fontPrimary: CONFIG.fontPrimary || undefined,
      fontSecondary: CONFIG.fontSecondary || undefined,
      overlayTitleSize: (typeof CONFIG.overlayTitleSize === 'number') ? Math.max(12, Math.min(64, Math.round(CONFIG.overlayTitleSize))) : undefined,
      overlaySubtitleSize: (typeof CONFIG.overlaySubtitleSize === 'number') ? Math.max(10, Math.min(48, Math.round(CONFIG.overlaySubtitleSize))) : undefined
    };
    // Prefer runtime helper to apply outline/font/overlay sizes. If it throws, apply a minimal fallback
    try{
      if(window.Theme && typeof window.Theme.applyFontOutline === 'function'){
        window.Theme.applyFontOutline(partial);
      } else {
        // minimal fallback: apply outline width only
        const w = partial.slideBorderWidth;
        try{ document.documentElement.style.setProperty('--outline-w', `${w}px`); }catch{}
      }
    }catch(e){ try{ document.documentElement.style.setProperty('--outline-w', `${partial.slideBorderWidth}px`); }catch{} }
  }catch(e){
    // Best-effort fallback in case of errors
    try{ const w = (typeof CONFIG.slideBorderWidth === 'number' && isFinite(CONFIG.slideBorderWidth)) ? CONFIG.slideBorderWidth : 3; document.documentElement.style.setProperty('--outline-w', `${Math.max(0, Math.min(20, Math.round(w)))}px`); }catch{}
    try{ document.documentElement.style.setProperty('--font-primary', CONFIG.fontPrimary||'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'); }catch{}
    try{ document.documentElement.style.setProperty('--font-secondary', CONFIG.fontSecondary||'Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif'); }catch{}
    try{ const ts = Math.max(12, Math.min(64, Math.round(CONFIG.overlayTitleSize||22))); document.documentElement.style.setProperty('--title-size', `${ts}px`);}catch{}
    try{ const ss = Math.max(10, Math.min(48, Math.round(CONFIG.overlaySubtitleSize||16))); document.documentElement.style.setProperty('--subtitle-size', `${ss}px`);}catch{}
  }
  // Thumbnails are CSS-driven; no explicit JS refresh required here.
  // Ensure active thumbnail gradient reflects current theme in engines where computed style may not resolve CSS vars reliably
  try{ updateActiveThumbGradient(); }catch{}
  }
    // Also apply text color to specific UI elements (immediate effect)
  try{
    // Let CSS handle color via variables; ensure derived --muted exists for label contrast
    const currentText = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || getComputedStyle(document.documentElement).getPropertyValue('--text');
    try{
      // Prefer runtime computation for derived vars when available
      if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
        try{
          const outcome = window.Theme.computeApplyConfigOutcome({ textColor: currentText });
          if(outcome && outcome.cssVars && typeof outcome.cssVars['--muted'] === 'string'){
            document.documentElement.style.setProperty('--muted', outcome.cssVars['--muted']);
          }
        }catch(e){ /* fallthrough to local computation below */ }
      } else {
        // compute a simple muted fallback based on luminance of --text when it's a hex; otherwise keep existing --muted
        const rgb = hexToRgb(currentText);
        if(rgb){
          const lin = (c)=>{ const s=c/255; return s<=0.03928? s/12.92 : Math.pow((s+0.055)/1.055, 2.4); };
          const L = 0.2126*lin(rgb.r) + 0.7152*lin(rgb.g) + 0.0722*lin(rgb.b);
          if(L > 0.5){ document.documentElement.style.setProperty('--muted', 'rgba(11,18,32,0.55)'); }
          else { document.documentElement.style.setProperty('--muted', 'rgba(255,255,255,0.55)'); }
        }
      }
    }catch(e){}
    // Clear inline colors so CSS variables control visuals; remove inline style.color where present
  [...document.querySelectorAll('.thumb, .deck-header .btn, .deck-footer .btn, #drawerBtn, #bgBtn, #notesBtn, #cfgModal .btn')].forEach(el=>{ el.style.removeProperty('color'); });
    // Ensure brand-badge text color follows vars
    try{ const bb=document.querySelector('.brand-badge'); if(bb) bb.style.removeProperty('color'); }catch{}
  }catch{}

  // ===== Markdown + Front-matter =====
  function parseFrontmatter(text){
      const fm={};
      const src = text.replace(/\r\n?/g,'\n');
      const trimmedStart = src.trimStart();
      // Only treat a leading --- block as frontmatter
      if(!trimmedStart.startsWith('---')) return { fm:{}, body: src.trim() };
      const lines = trimmedStart.split('\n');
      let endIndex=-1;
      for(let i=1;i<lines.length;i++){
        const rawLine = lines[i];
        const t = rawLine.trim();
        // Only treat a closing fence if it starts at the true line start (no leading indentation).
        // This prevents indented '---' inside a multiline frontmatter value (for example in notes)
        // from being interpreted as the end of the frontmatter block.
        if((rawLine.startsWith('---') || rawLine.startsWith('...')) && (t==='---' || t==='...')){ endIndex=i; break; }
      }
      if(endIndex<=0) return { fm:{}, body: src.trim() };
      // Parse key: value lines between the fences, allow leading spaces and continuations
      let key=null, val=[];
      for(let i=1;i<endIndex;i++){
        const raw=lines[i];
        const m = raw.match(/^\s*([^:\s][^:]*)\s*:\s*(.*)$/);
        if(m){
          // Commit previous key
          if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
          key = m[1].trim();
          val = [ (m[2]||'').trim() ];
        } else if(key){
          val.push(raw.trim());
        }
      }
      if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
      const body = lines.slice(endIndex+1).join('\n').trim();
      return { fm, body };
    }

  function escapeHtml(s){return s.replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));}

  function parseMarkdown(md, opts={allowColumns:true}){
      // Extract code fences into placeholders so inner backticks don't get processed
      // Support fences like ``` or ~~~ with optional language info; preserve leading newline
      const CODE_BLOCKS = [];
      md = md.replace(/(^|\n)(`{3,}|~{3,})([^\n]*)\n([\s\S]*?)\n\2(?:\n|$)/g, (m, pre, fence, info, code) => {
        const lang = (info||'').trim().split(/\s+/)[0];
        const cls = lang ? ` class="lang-${escapeHtml(lang)}"` : '';
        const html = `${pre}<pre><code${cls}>${escapeHtml(code)}</code></pre>`;
        const key = `@@CODE_BLOCK_${CODE_BLOCKS.length}@@`;
        CODE_BLOCKS.push(html);
        return key;
      });

      // Handle inline code (safe now that code fences are placeholders)
      md = md.replace(/`([^`]+)`/g, (m, code) => `<code>${escapeHtml(code)}</code>`);
      // Strikethrough
      md = md.replace(/~~([^~\n]+)~~/g, '<del>$1</del>');
      
      // Custom shortcodes (columns, admonitions)
      if(opts.allowColumns){
        const lines = md.split('\n');
        const out = [];
        for(let i = 0; i < lines.length; i++){
          const cur = lines[i].trim();
          if(/^:::\s*columns\b/i.test(cur)){
            const block = [];
            i++; // skip the :::columns line
            while(i < lines.length && lines[i].trim() !== ':::'){
              block.push(lines[i]);
              i++;
            }
            // Parse columns separated by :::col
            const cols = [];
            let buf = [];
            for(const ln of block){
              if(ln.trim().toLowerCase() === ':::col'){
                cols.push(buf.join('\n'));
                buf = [];
              } else {
                buf.push(ln);
              }
            }
            cols.push(buf.join('\n')); // last column
            const htmlCols = cols.map(c => `<div class="col">${parseMarkdown(c.trim(), {allowColumns:false})}</div>`).join('');
            out.push(`<div class="cols">${htmlCols}</div>`);
            continue;
          } else if(/^:::\s*(note|tip|warning)\b/i.test(cur)){
            const kind = cur.split(/\s+/)[1].toLowerCase();
            const block = [];
            i++;
            while(i < lines.length && lines[i].trim() !== ':::'){
              block.push(lines[i]);
              i++;
            }
            const inner = parseMarkdown(block.join('\n').trim(), {allowColumns:false});
            const title = kind.charAt(0).toUpperCase() + kind.slice(1);
            out.push(`<div class="admonition ${kind}"><div class="admonition-title">${title}</div><div class="admonition-body">${inner}</div></div>`);
            continue;
          }
          out.push(lines[i]);
        }
        md = out.join('\n');
      }
      
      // Handle headings with ids for anchors
      const slug = (s)=>s.toLowerCase().trim().replace(/<[^>]+>/g,'').replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-');
      md=md.replace(/^# (.*)$/gm,(m,t)=>`<h1 id="${slug(t)}">${t}</h1>`)
           .replace(/^## (.*)$/gm,(m,t)=>`<h2 id="${slug(t)}">${t}</h2>`)
           .replace(/^### (.*)$/gm,(m,t)=>`<h3 id="${slug(t)}">${t}</h3>`);
      
      // Handle blockquotes
      md = md.replace(/^> (.*)$/gm, '<blockquote>$1</blockquote>');
      
  // Handle images BEFORE links so the link regex doesn't consume image syntax
  md = md.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%;height:auto;border-radius:8px;margin:16px 0;">');

  // Handle links (after images)
  md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      
      // Handle tables (GFM style): header | separator | rows
      (function(){
        const lines = md.split('\n');
        const out = [];
        let i = 0;
        function splitRow(line){
          let s = line.trim();
          if(s.startsWith('|')) s = s.slice(1);
          if(s.endsWith('|')) s = s.slice(0, -1);
          return s.split('|').map(c => c.trim());
        }
        function isSep(line){
          let s = line.trim();
          if(s.startsWith('|')) s = s.slice(1);
          if(s.endsWith('|')) s = s.slice(0, -1);
          const parts = s.split('|').map(p => p.trim());
          return parts.length > 0 && parts.every(p => /^:?-{3,}:?$/.test(p));
        }
        function alignFrom(token){
          token = token.trim();
          const left = token.startsWith(':');
          const right = token.endsWith(':');
          if(left && right) return 'center';
          if(right) return 'right';
          return 'left';
        }
        while (i < lines.length) {
          const line = lines[i];
          const nextLine = lines[i+1];
          
          if (line && line.includes('|') && nextLine && isSep(nextLine)) {
            const headers = splitRow(line);
            const aligns = splitRow(nextLine).map(alignFrom);
            i += 2; // skip header and separator
            
            const rows = [];
            while (i < lines.length) {
              const row = lines[i];
              if (!row || !row.includes('|') || isSep(row)) break;
              rows.push(splitRow(row));
              i++;
            }
            
            const colCount = Math.max(headers.length, aligns.length, ...rows.map(r => r.length));
            const getAlign = (idx) => aligns[idx] || 'left';
            
            let html = '<table><thead><tr>';
            for (let c = 0; c < colCount; c++) {
              html += `<th style="text-align:${getAlign(c)}">${headers[c] || ''}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            for (const row of rows) {
              html += '<tr>';
              for (let c = 0; c < colCount; c++) {
                html += `<td style="text-align:${getAlign(c)}">${row[c] || ''}</td>`;
              }
              html += '</tr>';
            }
            html += '</tbody></table>';
            
            out.push(html);
            continue;
          }
          
          out.push(line);
          i++;
        }
        md = out.join('\n');
      })();
      
  // Handle lists (unordered and ordered)
      const lines = md.split('\n');
      let listType = null; // 'ul' | 'ol' | null
      const result = [];
      const ulRe = /^[\*\-]\s+(.+)$/;
      const olRe = /^\d+\.\s+(.+)$/;

      function open(type){ result.push(type==='ul' ? '<ul>' : '<ol>'); listType = type; }
      function close(){ if(listType){ result.push(listType==='ul' ? '</ul>' : '</ol>'); listType = null; } }

      for (let line of lines) {
        const ulMatch = line.match(ulRe);
        const olMatch = line.match(olRe);

        if (ulMatch) {
          if (listType !== 'ul') {
            close();
            open('ul');
          }
          const task = ulMatch[1].match(/^\[( |x|X)\]\s+(.*)$/);
          if(task){
            const checked = /x/i.test(task[1]);
            const txt = task[2];
            result.push(`<li class="task">${checked? '‚òë' : '‚òê'} ${txt}</li>`);
          } else {
            result.push(`<li>${ulMatch[1]}</li>`);
          }
          continue;
        }
        
        if (olMatch) {
          if (listType !== 'ol') {
            close();
            open('ol');
          }
          result.push(`<li>${olMatch[1]}</li>`);
          continue;
        }
        
        // Not a list item; close any open list before adding the line
        close();
        result.push(line);
      }
      close();
      md = result.join('\n');
      
      // Handle bold and italic
      md=md.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
      md=md.replace(/\*([^*\n]+)\*/g,'<em>$1</em>');
      
  // Handle paragraphs: split by double newlines, but avoid wrapping existing block elements
      md = md.split(/\n{2,}/).map(chunk => {
        const trimmed = chunk.trim();
        if (!trimmed) return '';

        // If this chunk is a code block placeholder (we stored them as @@CODE_BLOCK_n@@),
        // return it as-is so it remains a top-level block element and isn't wrapped in <p>.
        if (/^@@CODE_BLOCK_\d+@@$/.test(trimmed)) {
          return trimmed;
        }

        // Don't wrap block-level elements
        if (/^\s*<(h\d|ul|ol|pre|blockquote|p|table|div|img)/i.test(trimmed)) {
          return trimmed;
        }

        // Wrap in paragraph
        return `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
      }).join('\n');
  // Restore code blocks placeholders
  md = md.replace(/@@CODE_BLOCK_(\d+)@@/g, (m, idx) => CODE_BLOCKS[Number(idx)] || '');
      
      return md;
    }

  function splitSlides(md){
      // Normalize newlines and strip BOM
      md = md.replace(/\r\n?/g,'\n');
      if(md.startsWith('\uFEFF')) md = md.slice(1);
      // Extract deck-level frontmatter at file start and remove it from md
      let __deckFM = {};
      try{
        const lead = md.trimStart();
        if(lead.startsWith('---\n')){
          const m = lead.match(/^---\n([\s\S]*?)\n(---|\.\.\.)\s*(\n|$)/);
          if(m){
            const block = m[1] || '';
            const fm = {};
            let key=null, val=[];
            for(const raw of block.split('\n')){
              const mm = raw.match(/^\s*([^:\s][^:]*)\s*:\s*(.*)$/);
              if(mm){ if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); } key=mm[1].trim(); val=[(mm[2]||'').trim()]; }
              else if(key){ val.push(raw.trim()); }
            }
            if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
            // Only treat as deck-level FM if it includes known deck keys; otherwise
            // leave content intact (e.g., when the leading block is just slide text like title/notes).
            const keys = Object.keys(fm).map(k=>k.toLowerCase());
            const hasKnown = keys.some(k => (
              k==='app-name' || k==='appname' || k==='brand' ||
              k==='primary' || k==='accent' || k==='textcolor' || k==='text-color' || k==='text' ||
              k==='theme-primary' || k==='theme-accent' || k==='theme-text' ||
              k==='background' || k==='effect-color' || k==='ui' ||
              k==='font-primary' || k==='font-secondary' ||
              k==='opacity' || k==='slideopacity' || k==='appbg1' || k==='app-bg1' || k==='appbg2' || k==='app-bg2' ||
              k.startsWith('defaults-')
            ));
            if(hasKnown){
              __deckFM = fm;
              md = lead.slice(m[0].length);
            }
          }
        }
      }catch{}
      const lines = md.split('\n');
      const slides=[];
      let buf=[];
      let atSlideStart=true; // true until a non-empty, non-whitespace line is seen in current slide
      let inFM=false; // inside frontmatter block at the start of the slide

      // Helper: line is just a row of 4+ hyphens (common for HR or separators in notes/messages)
      const isHr = (t)=>/^-{4,}$/.test(t);
      // Track fenced code blocks so we don't split on '---' inside them
      let inFence = false; // ``` or ~~~
      let fenceToken = '';
      function fenceToggles(t){
        const m = t.match(/^(```+|~~~+)/);
        if(!m) return false;
        const token = m[1].startsWith('`') ? '```' : '~~~';
        if(!inFence){ inFence=true; fenceToken=token; return true; }
        if(inFence && token===fenceToken){ inFence=false; fenceToken=''; return true; }
        return false;
      }
      // Track HTML comments and simple HTML blocks (<pre|code|script|style>) so --- inside
      // them doesn't act as a slide separator/frontmatter fence
      let inHtmlComment=false;
      let inHtmlBlock=false; // pre/code/script/style
      const htmlBlockStart=/^(<\s*(pre|code|script|style)\b)/i;
      const htmlBlockEnd=/<\s*\/\s*(pre|code|script|style)\s*>/i;
      function commentToggle(line){
        const hasOpen = line.includes('<!--');
        const hasClose = line.includes('-->');
        if(hasOpen && !hasClose){ inHtmlComment=true; return true; }
        if(hasClose && inHtmlComment){ inHtmlComment=false; return true; }
        return false;
      }
      function htmlBlockToggle(t){
        if(htmlBlockStart.test(t) && !inHtmlBlock){ inHtmlBlock=true; return true; }
        if(inHtmlBlock && htmlBlockEnd.test(t)){ inHtmlBlock=false; return true; }
        return false;
      }
      // Helper: when we see a '---' not at true start, detect if a frontmatter block follows soon
      function looksLikeFrontmatter(startIdx){
        // Look ahead up to 40 lines for a closing '---'
        let sawKeyLine=false;
        let fence=false, token='';
        let hComment=false, hBlock=false;
        for(let j=startIdx+1; j<Math.min(lines.length, startIdx+41); j++){
          const raw = lines[j];
          const tj = raw.trim();
          // Skip regions inside code fences in the lookahead
          const fm = tj.match(/^(```+|~~~+)/);
          if(fm){ const tok=fm[1].startsWith('`')?'```':'~~~'; if(!fence){ fence=true; token=tok; continue; } if(tok===token){ fence=false; token=''; continue; } }
          // HTML comments / blocks
          if(raw.includes('<!--') && !raw.includes('-->')){ hComment=true; continue; }
          if(raw.includes('-->') && hComment){ hComment=false; continue; }
          if(htmlBlockStart.test(tj) && !hBlock){ hBlock=true; continue; }
          if(hBlock && htmlBlockEnd.test(tj)){ hBlock=false; continue; }
          if(fence || hComment || hBlock) continue;
          if(tj==='---' || tj==='...'){ return sawKeyLine; }
          if(!tj) continue;
          // a simple key: value detector (no leading indentation required)
          if(/^[^\s][^:]*:\s*.*$/.test(tj)) sawKeyLine = true;
        }
        return false;
      }

      const pushSlide=()=>{
        const content = buf.join('\n').trim();
        if(content) slides.push(content);
        buf=[]; atSlideStart=true; inFM=false;
      };

      for(let i=0; i<lines.length; i++){
  const line = lines[i];
  const t = line.trim();
  // Track fenced code regions globally so separators inside are ignored
  if(fenceToggles(t)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
  // Track HTML comments / simple HTML blocks; ignore separators within
  if(commentToggle(line)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
  if(htmlBlockToggle(t)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
        if(inFM){
          buf.push(line);
    if(t==='---' || t==='...'){ inFM=false; }
          continue;
        }
  if(t==='---' && !inFence && !inHtmlComment && !inHtmlBlock){
          // If at the true start of a slide, this opens frontmatter
          if(atSlideStart){ inFM=true; buf.push(line); continue; }
          // If not at start and a valid frontmatter block follows, end current slide
          // and immediately start a new slide with frontmatter (consume this fence for the next slide)
          if(looksLikeFrontmatter(i)){
            pushSlide();
            buf=[]; atSlideStart=true; inFM=true; buf.push(line); // FM start for next slide
            continue;
          }
          // Otherwise this is just a slide separator
          pushSlide();
          continue;
        }
        // Ignore leading HR lines at a fresh slide start (they often come from pasted separators)
        if(atSlideStart && isHr(t)){
          // do not mark start as non-start, simply skip
          continue;
        }
        buf.push(line);
        if(t!=='') atSlideStart=false;
      }
      // Last slide
      pushSlide();

      dlog(`splitSlides: found ${slides.length} slides`);
      // Map to renderable objects
      const __mapped = slides.map((slideContent)=>{
        const { fm, body } = parseFrontmatter(slideContent);
        // Extract notes fenced as ```notes
        let processedBody = body;
        const noteMatches = [...processedBody.matchAll(/```notes\n([\s\S]*?)```/g)];
        for(const m of noteMatches){ fm.notes = (fm.notes? fm.notes+'\n\n' : '') + m[1].trim(); processedBody = processedBody.replace(m[0],''); }
        return { html: `<div class="md">${parseMarkdown(processedBody.trim())}</div>`, fm };
      });
      try{
        if(__mapped.length > 0 && __deckFM && Object.keys(__deckFM).length){
          __mapped[0].fm = Object.assign({}, __deckFM, __mapped[0].fm || {});
        }
        Object.defineProperty(__mapped, 'deckFM', { value: __deckFM, enumerable: false });
      }catch{}
      return __mapped;
    }

  // ===== Sanitizer (allow-list + safe href/src) =====
  function sanitizeHTML(html){ const ALLOWED=new Set(['class','href','src','alt','title','target','rel','style','id']); const SAFE_STYLE_PROPS=new Set(['display','gap','align-items','justify-content','flex','flex-grow','flex-shrink','flex-basis','min-width','max-width','min-height','max-height','width','height','border-radius','box-shadow','color','background','background-color','margin','margin-left','margin-right','margin-top','margin-bottom','padding','padding-left','padding-right','padding-top','padding-bottom','text-align','font-size','line-height','opacity']); const temp=document.createElement('div'); temp.innerHTML=html; temp.querySelectorAll('script,style,iframe,object,embed').forEach(n=>n.remove()); temp.querySelectorAll('*').forEach(el=>{ [...el.attributes].forEach(a=>{ const n=a.name.toLowerCase(); if(n.startsWith('on') || !ALLOWED.has(n)) { el.removeAttribute(a.name); return; } if(n==='style'){ const cleaned=[]; const parts=(a.value||'').split(';'); for(const part of parts){ const [kRaw,...vParts]=part.split(':'); if(!kRaw) continue; const k=kRaw.trim().toLowerCase(); const v=vParts.join(':').trim(); if(!v) continue; if(SAFE_STYLE_PROPS.has(k)){ cleaned.push(`${k}: ${v}`); } } if(cleaned.length){ el.setAttribute('style', cleaned.join('; ')); } else { el.removeAttribute('style'); } } }); if(el.tagName.toLowerCase()==='img'){ const v=(el.getAttribute('src')||'').trim(); const ok=/^https?:\/\//i.test(v)||/^data:image\//i.test(v); if(!ok) el.removeAttribute('src'); }
    if(el.tagName.toLowerCase()==='a'){ let href=(el.getAttribute('href')||'').trim(); // normalize bare links
      if(/^www\./i.test(href)) href='https://'+href; if(/^\/\//.test(href)) href='https:'+href; // update attribute
      if(href) el.setAttribute('href', href);
      const safe=/^(https?:|mailto:|tel:|#)/i.test(href); if(!safe) el.removeAttribute('href'); if(!href.startsWith('#')){ el.setAttribute('target','_blank'); el.setAttribute('rel','noopener'); } } }); return temp.innerHTML; }

  // ===== Render & Navigation =====
  let current=0, slidesHTML=[];
  try{ window.slidesHTML = slidesHTML; }catch{}
  function renderSlides(list){ slidesRoot.innerHTML=''; thumbsRoot.innerHTML=''; if(!Array.isArray(list)||!list.length){ current=0; document.getElementById('progress').style.width='0%'; document.getElementById('slideNo').textContent='0/0'; return; } list.forEach((obj,i)=>{ const node=document.createElement('section'); node.className='slide';
    // Per-slide background override via front matter: slidebg1/slidebg2 (hex)
    try{
      const fm = obj?.fm || {};
      const hRe = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;
      const unq = (s)=> s.replace(/^['"]|['"]$/g,'');
      const raw1 = (fm.slidebg1 || fm['slide-bg1'] || '').toString().trim();
      const raw2 = (fm.slidebg2 || fm['slide-bg2'] || '').toString().trim();
      const b1 = unq(raw1);
      const b2 = unq(raw2);
      const c1 = hRe.test(b1) ? b1 : null;
      const c2 = hRe.test(b2) ? b2 : null;
      if(c1 || c2){
        const left = c1 || 'var(--slide-bg1)';
        const right = c2 || 'var(--slide-bg2)';
        node.style.background = `linear-gradient(180deg, ${left}, ${right})`;
        // Mark override for testing/inspection
        try{
          node.setAttribute('data-slide-bg-override', '1');
          if(c1) node.setAttribute('data-slidebg1', c1);
          if(c2) node.setAttribute('data-slidebg2', c2);
        }catch{}
  }
    }catch{}
  node.innerHTML=sanitizeHTML(obj.html);
  // Wrap content in a scroll container so overlay and outline are not clipped
  try{
    const wrap = document.createElement('div');
    wrap.className = 'content-scroll';
    // Move all current children into the wrapper (e.g., .md)
    while(node.firstChild){ wrap.appendChild(node.firstChild); }
    node.appendChild(wrap);
    // Apply content position: per-slide FM > deck FM (merged into first slide fm) > CONFIG > default (tl)
    try{
      const fm = obj?.fm || {};
      const raw = String(fm['content-pos'] || fm.contentpos || (slidesHTML?.deckFM?.['content-pos']) || CONFIG.contentPos || 'tl').toLowerCase();
      const map = { t:{y:'flex-start'}, m:{y:'center'}, b:{y:'flex-end'} };
      const mapx = { l:'flex-start', m:'center', r:'flex-end' };
      let y='flex-start', x='flex-start';
      if(/^[tmb][lmr]$/.test(raw)){
        const row = raw[0]; const col = raw[1];
        y = (map[row]?.y) || 'flex-start';
        x = mapx[col] || 'flex-start';
      }
      wrap.style.setProperty('--content-x', x);
      wrap.style.setProperty('--content-y', y);
    }catch{}
  }catch{}
  // Enhance headings with anchor links
  try{
    const hs = node.querySelectorAll('h1[id],h2[id],h3[id]');
    hs.forEach(h=>{
      if(h.querySelector('.anchor-link')) return;
      const id = h.getAttribute('id');
      if(!id) return;
      const a = document.createElement('a');
      a.className='anchor-link'; a.href = '#'+id; a.title = 'Copy link'; a.textContent = '#';
      a.addEventListener('click', (e)=>{
        try{
          e.preventDefault();
          const base = location.href.split('#')[0];
          const url = base + '#' + id;
          if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(url); showToast && showToast('Link copied'); }
          else { location.hash = id; }
        }catch{}
      });
      h.appendChild(a);
    });
  }catch{}
  slidesRoot.append(node);
  const thumb=document.createElement('div');
  thumb.className='thumb';
  const t=(obj.fm.title||'').toString().trim();
  thumb.textContent = t || `Slide ${i+1}`;
  // Accessibility: keyboard focus and activation
  thumb.setAttribute('tabindex','0');
  thumb.setAttribute('role','button');
  thumb.setAttribute('aria-label', t ? `Slide ${i+1}: ${t}` : `Slide ${i+1}`);
  thumb.onclick = () => setActive(i);
  thumb.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); setActive(i); } });
  // Thumbnails are styled via CSS using --app-bg1/2 and other CSS vars. No inline styles needed.
      thumbsRoot.append(thumb); }); setActive(0); 
    // Apply current opacity to newly rendered slides
    if(typeof CONFIG.slideOpacity==='number'){ 
      try{
        if(window.Theme && typeof window.Theme.setSlideOpacity === 'function'){
          window.Theme.setSlideOpacity(CONFIG.slideOpacity);
        }else{
          setSlideOpacity(CONFIG.slideOpacity * 100);
        }
      }catch(e){}
    }
  // Build overlays via controller
  try{ rebuildOverlays(); }catch(e){}
  }

  function setActive(i, direction = 'none'){
    const all = [...document.querySelectorAll('.slide')];
    all.forEach(s => s.classList.remove('active', 'prev', 'slide-in-right', 'slide-in-left', 'slide-out-left', 'slide-out-right'));
    
    if (all[i]) {
      if (direction === 'next') {
        all[i].classList.add('slide-in-right');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            all[i].classList.remove('slide-in-right');
          });
        });
      } else if (direction === 'prev') {
        all[i].classList.add('slide-in-left');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            all[i].classList.remove('slide-in-left');
          });
        });
      }
      
      all[i].classList.add('active');
      all[i].setAttribute('tabindex', '-1');
      all[i].focus({ preventScroll: true });
      try{
        const sc = all[i].querySelector('.content-scroll');
        if(sc) sc.scrollTop = 0;
      }catch{}
    }
    
    if (all[i - 1]) all[i - 1].classList.add('prev');
    
    current = i;
    document.getElementById('progress').style.width = ((i + 1) / all.length * 100) + '%';
    document.getElementById('slideNo').textContent = `${i + 1}/${all.length}`;
    
    const thumbs = [...document.querySelectorAll('.thumb')];
    thumbs.forEach((t, j) => t.classList.toggle('active', j === i));
  // Ensure computed backgroundImage on the active thumb reflects the theme gradient (WebKit compat for tests)
    try{
      const cs = getComputedStyle(document.documentElement);
      const primary = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accent = (CONFIG.accent && String(CONFIG.accent).trim()) || (cs.getPropertyValue('--accent')||'').trim();
      thumbs.forEach((t, j)=>{
        if(j === i){
          const grad = `linear-gradient(135deg, ${primary}, ${accent})`;
      // Use !important to win over stylesheet !important and ensure getComputedStyle reflects the gradient
      try{ t.style.setProperty('background-image', grad, 'important'); }catch{ t.style.backgroundImage = grad; }
      try{ t.style.setProperty('background', grad, 'important'); }catch{ t.style.background = grad; }
        } else {
      t.style.removeProperty('background-image');
      t.style.removeProperty('background');
        }
      });
    }catch{}
  // Thumbnails are CSS-driven; no inline style toggling required here.
    
    const notesMd = slidesHTML[i]?.fm?.notes || '';
    notesEl.innerHTML = notesMd ? sanitizeHTML(`<div class="md">${parseMarkdown(notesMd, {allowColumns: false})}</div>`) : `<em>[No notes for slide ${i + 1}]</em>`;
    
    try {
      history.replaceState(null, '', `#/${i + 1}`);
    } catch {}
    
    slidesRoot.setAttribute('aria-label', `Slide ${i + 1} of ${all.length}`);
  // As a final step, enforce active thumb gradient for engines with odd computed style timing
  try{ updateActiveThumbGradient(/*retry*/true); }catch{}
  }

  const next=()=>{ if(current<slidesHTML.length-1) setActive(++current,'next'); };
  const prev=()=>{ if(current>0) setActive(--current,'prev'); };

  // Update the active thumbnail's backgroundImage gradient to match current theme
  function updateActiveThumbGradient(retry=false){
    try{
      const active = document.querySelector('.thumb.active');
      if(!active) return;
      const cs = getComputedStyle(document.documentElement);
      // Normalize theme colors to rgb(r,g,b) to match computed style shape in tests
      function toRgbStr(val){
        if(!val) return '';
        const s = String(val).trim();
        // Already rgb(a)
        if(/^rgba?\(/i.test(s)) return s;
        // Hex -> rgb
        const h = (s.startsWith('#') ? s : ('#'+s)).toLowerCase();
        const m3 = /^#([0-9a-f]{3})$/i.exec(h);
        const m6 = /^#([0-9a-f]{6})$/i.exec(h);
        let r,g,b;
        if(m3){
          const v=m3[1]; r=parseInt(v[0]+v[0],16); g=parseInt(v[1]+v[1],16); b=parseInt(v[2]+v[2],16);
        } else if(m6){
          const v=m6[1]; r=parseInt(v.slice(0,2),16); g=parseInt(v.slice(2,4),16); b=parseInt(v.slice(4,6),16);
        }
        if(r==null||g==null||b==null) return s;
        return `rgb(${r},${g},${b})`;
      }
      const primaryRaw = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accentRaw  = (CONFIG.accent  && String(CONFIG.accent ).trim()) || (cs.getPropertyValue('--accent') ||'').trim();
      const primary = toRgbStr(primaryRaw);
      const accent  = toRgbStr(accentRaw);
      if(primary && accent){
        const grad = `linear-gradient(135deg, ${primary}, ${accent})`;
        const apply = ()=>{
          // Temporarily disable background transition so computed style reflects immediately after navigation
          try{
            active.style.setProperty('transition-property', 'transform, box-shadow, border-color', 'important');
          }catch{}
          try{ active.style.setProperty('background-image', grad, 'important'); }catch{ active.style.backgroundImage = grad; }
          try{ active.style.setProperty('background', grad, 'important'); }catch{ active.style.background = grad; }
          // Restore transition properties on next microtask
          try{ setTimeout(()=>{ active.style.removeProperty('transition-property'); }, 0); }catch{}
          try{ document.documentElement.style.setProperty('--thumb-active-bg', grad); }catch{}
          // Also enforce via a dynamic stylesheet so computed styles consistently reflect the gradient across engines
          try{
            let tag = document.getElementById('thumb-active-style');
            const css = `.thumb.active{background:${grad} !important;background-image:${grad} !important;}`;
            if(!tag){
              tag = document.createElement('style');
              tag.id = 'thumb-active-style';
              tag.setAttribute('data-owned','slideapp');
              tag.textContent = css;
              document.head.appendChild(tag);
            } else {
              tag.textContent = css;
            }
          }catch{}
        };
        apply();
        // Retry on next frame and shortly after to win races with transitions/layout
        if(retry){
          try{ requestAnimationFrame(()=>{ apply(); setTimeout(apply, 60); }); }catch{}
        }
      }
    }catch{}
  }

  // Ensure the CSS var used by .thumb.active reflects current CONFIG immediately
  function setThumbActiveBgFromConfig(){
    try{
      const cs = getComputedStyle(document.documentElement);
      const primaryRaw = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accentRaw  = (CONFIG.accent  && String(CONFIG.accent ).trim()) || (cs.getPropertyValue('--accent') ||'').trim();
      if(primaryRaw && accentRaw){
        const grad = `linear-gradient(135deg, ${primaryRaw}, ${accentRaw})`;
        document.documentElement.style.setProperty('--thumb-active-bg', grad);
      }
    }catch{}
  }

  document.getElementById('btnPrev').addEventListener('click',prev);
  document.getElementById('btnNext').addEventListener('click',next);
  function toggleNotes(){
    if(window.NotesCtrl && typeof window.NotesCtrl.toggleNotes==='function'){
      const now = window.NotesCtrl.toggleNotes(notesEl, (state)=>{ try{ showToast(state ? 'Notes: shown' : 'Notes: hidden'); }catch{} });
      return now;
    }
    const now = notesEl.classList.toggle('show'); try{ showToast(now ? 'Notes: shown' : 'Notes: hidden'); }catch{}; return now;
  }
  document.getElementById('notesBtn').addEventListener('click',toggleNotes);
  document.getElementById('bgBtn').addEventListener('click',cycleBackground);
  function toggleFullscreen(){ const el=document.documentElement; if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }
  document.getElementById('fsBtn').addEventListener('click',(e)=>{ e.preventDefault(); toggleFullscreen(); });

  // Respect focus: don't hijack keys inside inputs/contenteditable
  function toggleOutline(){
    CONFIG.slideBorderOn = !(CONFIG.slideBorderOn===true) ? true : false; // invert
    document.body.classList.toggle('border-off', CONFIG.slideBorderOn===false);
    try{ showToast(CONFIG.slideBorderOn===false ? 'Outline: hidden' : 'Outline: shown'); }catch{}
    // sync Style checkbox if open
    try{ const cb=document.getElementById('cfgSlideOutline'); if(cb) cb.checked = (CONFIG.slideBorderOn!==false); }catch{}
  }
  document.addEventListener('keydown',e=>{ const tag=(e.target&&e.target.tagName||'').toLowerCase(); if(tag==='input'||tag==='textarea'||e.target.isContentEditable) return; if(e.key==='ArrowRight'||e.key===' ') next(); if(e.key==='ArrowLeft') prev(); const k=e.key.toLowerCase(); if(k==='b') cycleBackground(); if(k==='n') toggleNotes(); if(k==='s') toggleDrawer(); if(k==='f'){ e.preventDefault(); toggleFullscreen(); } if(k==='u'){ e.preventDefault(); cycleUi(); } if(k==='p'){ e.preventDefault(); toggleProgress(); } if(k==='t'){ e.preventDefault(); toggleOpacity(); } if(k==='o'){ e.preventDefault(); toggleOutline(); } if(k==='y'){ e.preventDefault(); const b=document.getElementById('overlayBtn'); if(b) b.click(); } });

  // Drawer thumbnails (overlay on small screens)
  const drawerKey='drawerCollapsed'; const isOverlay=()=>innerWidth<1024;
  function setDrawerUI(){
    if(window.DrawerCtrl && typeof window.DrawerCtrl.setDrawerUI==='function'){
      window.DrawerCtrl.setDrawerUI({ thumbsRoot, drawerBtn, scrimEl, isOverlayFn: isOverlay });
    } else {
      const collapsed=localStorage.getItem(drawerKey)==='1'; const open=localStorage.getItem('drawerOpen')==='1'; const overlay=isOverlay(); thumbsRoot.classList.remove('collapsed','overlay','open'); if(overlay){ thumbsRoot.classList.add('overlay'); if(open) thumbsRoot.classList.add('open'); scrimEl.style.display = open ? 'block' : 'none'; drawerBtn.textContent='üß≠ Slides'; drawerBtn.title = open?'Hide slides':'Show slides'; } else { thumbsRoot.classList.toggle('collapsed',collapsed); scrimEl.style.display='none'; drawerBtn.textContent='üß≠ Slides'; drawerBtn.title = collapsed?'Show slides':'Hide slides'; }
    }
  }
  function toggleDrawer(){
    if(window.DrawerCtrl && typeof window.DrawerCtrl.toggleDrawer==='function'){
      window.DrawerCtrl.toggleDrawer({ thumbsRoot, drawerBtn, scrimEl, isOverlayFn: isOverlay }, (open, overlay)=>{ try{ showToast(overlay ? (open ? 'Slides: opened' : 'Slides: hidden') : (open ? 'Slides: shown' : 'Slides: hidden')); }catch{} });
    } else {
      if(isOverlay()){ const open=!(localStorage.getItem('drawerOpen')==='1'); localStorage.setItem('drawerOpen', open?'1':'0'); setDrawerUI(); try{ showToast(open ? 'Slides: opened' : 'Slides: hidden'); }catch{} } else { const collapsed=!(localStorage.getItem(drawerKey)==='1'); localStorage.setItem(drawerKey, collapsed?'1':'0'); setDrawerUI(); try{ showToast(collapsed ? 'Slides: hidden' : 'Slides: shown'); }catch{} }
    }
  }
  // Enhance: allow toggling slides while UI is off by overriding hide-slides class when opening
  (function enhanceDrawerToggle(){
    const origToggle = toggleDrawer;
    window.toggleDrawer = function(){
      const overlay = isOverlay();
      // Determine current intent: will result be open or closed?
      let willOpen = false;
      if(overlay){
        const open = !(localStorage.getItem('drawerOpen')==='1');
        willOpen = open; // toggled state after click
      } else {
        const currentlyCollapsed = (localStorage.getItem(drawerKey)==='1');
        willOpen = currentlyCollapsed; // toggling will open when currently collapsed
      }
      // If UI is off and slides are configured to hide, remove hide-slides when opening
      const hideSlidesCfg = (CONFIG.hideSlidesWithUi !== false);
      if(document.body.classList.contains('ui-off') && hideSlidesCfg){
        if(willOpen){
          document.body.classList.remove('hide-slides');
        }
      }
      // Perform original toggle
      origToggle();
      // If closing while UI off and configured to hide, re-apply hide-slides
      if(document.body.classList.contains('ui-off') && hideSlidesCfg){
        if(!willOpen){
          document.body.classList.add('hide-slides');
        }
      }
    }
  })();
  drawerBtn.addEventListener('click',toggleDrawer); scrimEl.addEventListener('click',()=>{localStorage.setItem('drawerOpen','0'); setDrawerUI();}); window.addEventListener('resize', setDrawerUI);

  // UI visibility (header/footer on/off)
  function readUiMode(){
    const raw = localStorage.getItem('uiMode');
    if(raw === null) return 0;
    const v = String(raw).toLowerCase().trim();
    if(v === '1' || v === 'true') return 1;
    if(v === '0' || v === 'false') return 0;
    return 0; // sanitize unknown legacy values
  }
  let uiMode = readUiMode();
  function setUiButtonState(){
    const b=document.getElementById('uiBtn');
    if(!b) return;
    const on = uiMode === 1;
    b.setAttribute('aria-pressed', on ? 'true':'false');
    b.title = on ? 'Show UI' : 'Hide UI';
    b.textContent = on ? 'üëÅÔ∏è UI (off)' : 'üëÅÔ∏è UI';
  }
  function applyUiMode(){
    // Inline styles for backward compatibility, plus body class for robustness
    const on = uiMode === 1;
    document.querySelector('.deck-header').style.display= on ? 'none':'flex';
    document.body.classList.toggle('ui-off', on);
  // Clear any temporary progress overrides when UI mode changes
  document.body.classList.remove('progress-on','progress-off');
    const hideSlides = (CONFIG.hideSlidesWithUi !== false);
    const hideProgress = (CONFIG.hideProgressWithUi !== false);
    document.body.classList.toggle('hide-slides', on && hideSlides);
    document.body.classList.toggle('hide-progress', on && hideProgress);
    // When hiding slides, ensure overlay closed
    if(on && hideSlides){
      localStorage.setItem('drawerOpen','0');
      thumbsRoot.classList.remove('open');
      scrimEl.style.display='none';
    }
    // If UI is turned off, ensure drawer overlay is considered closed
    if(on){
      localStorage.setItem('drawerOpen','0');
    }
    setUiButtonState();
  }
  function cycleUi(){ uiMode = uiMode===1 ? 0 : 1; localStorage.setItem('uiMode', uiMode ? '1':'0'); applyUiMode(); try{ showToast(uiMode===1 ? 'UI: hidden' : 'UI: shown'); }catch{} }
  (function bindUiButton(){
    const b=document.getElementById('uiBtn');
    if(!b) return;
    const handler=(e)=>{ e.preventDefault(); e.stopPropagation(); cycleUi(); };
    b.addEventListener('click', handler);
    b.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' || e.key===' '){ handler(e); }
    });
  })();

  // Style modal
  if (window.StyleModal && typeof window.StyleModal.init === 'function') {
    window.StyleModal.init();
  }

  // File loader
  document.getElementById('fileInput').addEventListener('change',async e=>{ const f=e.target.files[0]; if(!f) return; try{
    // Test-only deterministic guard: if tests opt-in, clear persisted bgMode and prefer gradient
    try{ if(typeof window.__isDeterministicTestMode === 'function' && window.__isDeterministicTestMode()){ try{ localStorage.removeItem('bgMode'); }catch{} bgMode = 'gradient'; setBackgroundMode('gradient'); } }catch{}
  // debug hooks removed
    if(f.size > 5*1024*1024){ alert('File too large. Max 5MB.'); return; } const valid=['text/markdown','text/plain','application/octet-stream']; if(!valid.includes(f.type) && !/\.(md|markdown|txt)$/i.test(f.name)){ alert('Please select a Markdown file (.md/.markdown/.txt)'); return; } const text=await f.text(); if(!text.trim()){ alert('File appears empty.'); return; } slidesHTML=splitSlides(text); try{ window.slidesHTML = slidesHTML; }catch{} if(!slidesHTML.length){ alert('No slides found. Separate slides with a line containing only ---'); return; } renderSlides(slidesHTML);
    // Apply deck-level frontmatter settings
    try{
  const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {}));
  // Expose parsed frontmatter for debug/tests
  // debug hook removed
  // If the loaded deck does not specify a background, ensure we reset to the default
  // so we don't accidentally preserve a previous bgMode from localStorage/session.
  try{ if(!fm.background && !fm.bg){ if(typeof window.__isDeterministicTestMode === 'function' && window.__isDeterministicTestMode()){ setBackgroundMode('gradient'); } } }catch(e){}
  applyDeckFrontmatter(fm);
        // Ensure background button label reflects any programmatic change
        try{ setBgButtonLabel(); }catch{}
      }catch{}
    // Store deck for session restore; optionally persist if configured
    try{
      const payload = { deckContent: text, fileName: f.name||'', loadedAt: Date.now() };
      // Guard very large decks (~2.5MB)
      if((text||'').length <= 2.5*1024*1024){
        sessionStorage.setItem('slideapp.session.deck', JSON.stringify(payload));
        if(CONFIG.rememberLastDeck === true){
          localStorage.setItem('slideapp.persist.deck', JSON.stringify(payload));
        }
      } else {
        showToast('Deck too large to remember');
      }
    }catch{}
    try{ showToast(`Deck loaded: ${f.name||'file'}`);}catch{}
    e.target.value=''; }catch(err){ console.error('Load failed',err); alert('Failed to load file: '+(err?.message||err)); } });

  // Hash deep-link
  window.addEventListener('hashchange',()=>{ const m=location.hash.match(/#\/(\d+)/); if(m){ const idx=parseInt(m[1],10)-1; if(idx>=0 && idx<slidesHTML.length) setActive(idx); } });

  // Boot
  function setBgFromPrefs(){ setBgButtonLabel(); if(prefersReduced && bgMode==='particles') bgMode='gradient'; setBackgroundMode(bgMode); }
  async function boot(){
    // Try session restore first
    try{
      const raw = sessionStorage.getItem('slideapp.session.deck');
      if(raw){
        const data = JSON.parse(raw);
        if(data && typeof data.deckContent === 'string' && data.deckContent.trim()){
      slidesHTML = splitSlides(data.deckContent); try{ window.slidesHTML = slidesHTML; }catch{}
          renderSlides(slidesHTML);
          try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
          try{ showToast('Restored last deck (session)'); }catch{}
          return;
        }
      }
    }catch{}
    // Then try persistent restore if enabled
    try{
      if(CONFIG.rememberLastDeck === true){
        const raw = localStorage.getItem('slideapp.persist.deck');
        if(raw){
          const data = JSON.parse(raw);
          if(data && typeof data.deckContent === 'string' && data.deckContent.trim()){
            slidesHTML = splitSlides(data.deckContent); try{ window.slidesHTML = slidesHTML; }catch{}
            renderSlides(slidesHTML);
            try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
            try{ showToast('Restored last deck'); }catch{}
            return;
          }
        }
      }
    }catch{}
    // Try to load bundled sample; if it fails (file:// or missing), fall back to demo
    try{
      const res = await fetch('sample_presentation.md');
  if(res.ok){
    const text = await res.text();
    slidesHTML = splitSlides(text); try{ window.slidesHTML = slidesHTML; }catch{}
  renderSlides(slidesHTML);
  // Apply deck-level frontmatter (sample)
  try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); try{ if(!fm.background && !fm.bg){ if(typeof __isDeterministicTestMode === 'function' && __isDeterministicTestMode()){ setBackgroundMode('gradient'); } } }catch{}; applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
    return;
  }
    }catch{}
  const DEMO_MD = `---
app-name: SlideApp
theme-primary: "#01B4E1"
theme-accent: "#64FFFC"
theme-text: "#e2e8f0"
background: particles
ui: on
---

# SlideApp
Super‚Äëjazzy demos + user guide

## Quick Controls

- üé® Style: colors, overlays, backgrounds, content position (3√ó3)
- Keys: B (background) ¬∑ T (opacity) ¬∑ U (UI) ¬∑ O (outline) ¬∑ S (slides) ¬∑ N (notes)
- Presets: fast theme swaps ¬∑ Reset restores defaults

---

title: Content Position ‚Äî Deck Default (MM)
subtitle: Centered by default (deck)
---

## Centered Content
The Markdown block is anchored to the middle (MM).

Use frontmatter <code>content-pos: mm</code> (deck) or the Style UI to change.

---

title: Content Position ‚Äî TL
content-pos: tl
---

## Top‚ÄëLeft (TL)
Per‚Äëslide override via <code>content-pos: tl</code>.

---

title: Content Position ‚Äî MR
content-pos: mr
---

## Middle‚ÄëRight (MR)
Great for balancing text with visuals.

---

title: Content Position ‚Äî BR
content-pos: br
---

## Bottom‚ÄëRight (BR)
Perfect for quick callouts.

---

title: Overlays ‚Äî Deck ON
overlay: on
overlay-pos: tr
title-size: 30
overlay-subtitle: true
overlay-subtitle-size: 16
overlay-subtitle-color: accent
---

## Title & Subtitle Overlay
Overlay ON by default from here. Subtitle uses accent color.

---

title: Overlays ‚Äî Per‚ÄëSlide BL
overlay-pos: bl
title-size: 28
overlay-subtitle-size: 14
---

## Bottom‚ÄëLeft Overlay
Per‚Äëslide overlay position + sizes.

---

title: Overlay OFF here
overlay: off
---

## No Overlay
Per‚Äëslide override hides the overlay.

---

## Markdown Goodies

- Strikethrough: ~~deprecated~~ ‚Üí modern
- Task lists:
  - [ ] Collect feedback
  - [x] Ship 1.2.0
- Autolink: https://example.com

::: note
Heads up: Admonitions render with a clean style.
:::

::: tip
Pro tip: Use the TOC (üìë) to jump between sections.
:::

::: warning
Warning: Don‚Äôt overuse effects; clarity wins.
:::

## Headings & Anchors

### Getting Started
Click the ‚Äú#‚Äù to copy a direct link to this heading.

## Columns

::: columns

### Column A
- Alpha
- Beta

:::col

### Column B
1. One
2. Two

:::col

### Column C
- One
- Two

:::

## Tables

| Feature        | Basic | Pro |
|----------------|:-----:|:---:|
| Bullet Support | ‚úÖ    | ‚úÖ  |
| Code Blocks    | ‚úÖ    | ‚úÖ  |
| Tables         | ‚ùå    | ‚úÖ  |

## Shortcuts (One‚Äëhand friendly)

- Background: B cycles modes; label shows current
- Slides drawer: S toggles thumbnails (works with UI off)
- Notes panel: N toggles speaker notes
- Fullscreen: F on/off
- UI mode: U hide/show header & footer
- Progress: P toggles bar/arrows/count
- Opacity: T toggles 0% ‚áÑ saved baseline
- Outline: O toggles accent outline
- Title overlay: Y toggles title/subtitle overlay

## Image + Text (Example)
<p class="muted-lead">A clean visual + talking points layout.</p>

<div style="display:flex; gap:24px; align-items:center;">
  <div style="flex:1; min-width:0;">
    <img src="https://images.unsplash.com/photo-1482192596544-9eb780fc7f66?w=1000" alt="Dashboard preview" style="width:100%;height:auto;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25);" />
  </div>
  <div style="flex:1; min-width:0;">
    <h3>Why this layout works</h3>
    <ul>
      <li>Even balance between image and copy</li>
      <li>Great for highlights and callouts</li>
      <li>Responsive: stacks on small screens</li>
    </ul>
  </div>

</div>

---

title: Columns Shortcode Demo
subtitle: Markdown-only columns
notes: Use ::: columns with :::col separators. Pure Markdown authoring.
---

# Columns Shortcode
## Another way to do columns

::: columns

### Column A
- Alpha
- Beta
- Gamma

:::col

### Column B
1. One
2. Two
3. Three

:::col

### Column C
- One
- Two
- Three
- Four

:::

---

title: Table Example
subtitle: GFM tables with alignment
notes: Demonstrates table rendering with alignment.
---

## Feature Comparison

| Feature        | Basic | Pro | Enterprise |
|----------------|:-----:|:---:|:----------:|
| Bullet Support | ‚úÖ    | ‚úÖ  | ‚úÖ         |
| Code Blocks    | ‚úÖ    | ‚úÖ  | ‚úÖ         |
| Tables         | ‚ùå    | ‚úÖ  | ‚úÖ         |
| Notes Panel    | ‚úÖ    | ‚úÖ  | ‚úÖ         |

---

title: Embedded SVG (Offline)
subtitle: Inline SVG data URI
notes: Inline SVG data URI for offline testing.
---

![Embedded SVG](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='220' height='120'><rect width='100%25' height='100%25' rx='12' fill='%230ea5e9'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='white' font-size='18'>Embedded SVG</text></svg>)

---

title: Code & Formatting
subtitle: Blocks, inline, and emphasis
notes: Demo of code blocks and emphasis styles.
---

## Code Sample

<pre><code>function greet(name){
  return 'Hello, ' + name + '!';
}
console.log(greet('World'));</code></pre>

- Supports <strong>bold</strong> and <em>italic</em> and <code>inline code</code>

---

title: Print & Accessibility
subtitle: Clean PDFs and reduced motion
notes: Print strips backgrounds and UI for clean PDFs; reduced motion is respected.
---

## Print & Accessibility

- Print to PDF via the üìÑ PDF button
- Print removes backgrounds and UI for clarity
- Respects ‚ÄúReduce motion‚Äù and falls back to Gradient

---

title: Title & Subtitle Overlay
subtitle: Titles on slides, your way
notes: Overlay shows the slide title (frontmatter or fallback) and an optional subtitle. Toggle globally via toolbar, hotkey, or Style. Override per slide with frontmatter.
---

## Overlay quick guide

- Toggle overlay: Toolbar "üè∑Ô∏è Title" button or press Y
- Style options: Position TL/TR/BL/BR; Title size; Subtitle on/off; Subtitle size; Subtitle color (Primary/Accent); Fonts (primary/secondary)
- Per-slide overrides (frontmatter):
  - overlay: on|off ‚Äî show/hide overlay
  - overlaypos: tl|tr|bl|br ‚Äî position
  - titlesize: 12..64 ¬∑ subtitlesize: 10..48
  - title: and subtitle: values
- Deck-level defaults (frontmatter):
  - overlay, overlaypos, overlaysubtitle, overlaysubtitlesize, overlaysubtitlecolor, primaryfont, secondaryfont

Pro tip: Keep subtitles concise; they‚Äôre intentionally thinner for hierarchy.

Tip: Subtitle is intentionally thinner than the title for hierarchy.

---

title: Front matter reference
subtitle: Deck-level and per-slide keys
notes: Quick reference listing all supported front matter keys, including aliases and accepted ranges. Boolean-like values are case-insensitive; strings are trimmed; numeric values are clamped to valid ranges.
---
::: columns

### Deck-level (whole deck)

- background | bg: gradient | particles | off
- appname | app-name | brand: string (sets app/brand label)
- primary | color: hex color (#RGB or #RRGGBB)
- accent: hex color (#RGB or #RRGGBB)
- appbg1 | app-bg1 | app-bg-1: hex color ‚Äî app background start
- appbg2 | app-bg2 | app-bg-2: hex color ‚Äî app background end
- effectcolor | effect-color: hex color ‚Äî particles/efffect accent
- opacity | slideopacity: percentage (e.g., 75 or "75%") or decimal 0..1 (e.g., 0.75)
- primaryfont: string (font family name)
- secondaryfont: string (font family name)
- overlay | titleoverlay: on | off | true | false | 1 | 0
- overlaypos | titleposition: tl | tr | bl | br
- titlesize: integer, clamped 12..64 (px)
- overlaysubtitle | subtitleenabled: on | off | true | false | 1 | 0
- overlaysubtitlesize | subtitlesize: integer, clamped 10..48 (px)
- overlaysubtitlecolor: primary | accent
- ui: on | show | true | 1 (show UI) or off | hide | false | 0 (hide UI)

:::col

### Per-slide (single slide)

- overlay: on | off | true | false | 1 | 0
- overlaypos: tl | tr | bl | br
- titlesize: integer, clamped 12..64 (px)
- subtitlesize: integer, clamped 10..48 (px)
- title: string (used for overlay and thumbnails)
- subtitle: string (shown if non-empty and subtitle is enabled)
- slidebg1 | slide-bg1: hex color ‚Äî slide background start (overrides)
- slidebg2 | slide-bg2: hex color ‚Äî slide background end (overrides)

:::

Notes:
- Boolean-like values are case-insensitive; strings are trimmed
- Values outside ranges are clamped to the stated mins/maxes

Everything else in front matter is ignored by the app.`;
    slidesHTML = splitSlides(DEMO_MD); try{ window.slidesHTML = slidesHTML; }catch{}
    renderSlides(slidesHTML);
  // Apply deck-level frontmatter if present
  try{ const fm = slidesHTML[0]?.fm || {}; applyDeckFrontmatter(fm); }catch{}
  }

  // Initialize everything
  // Toast helper
  // showToast moved to src/ui/toast.js; global showToast kept for back-compat

  // Announce fullscreen changes
  document.addEventListener('fullscreenchange',()=>{ showToast(document.fullscreenElement?'Entered fullscreen':'Exited fullscreen'); });

  async function maybeLoadConfigFromQuery(){
    try{
      const sp = new URLSearchParams(location.search);
      const url = sp.get('config');
      if(url && url.trim()){
        await loadConfigFromUrl(url.trim());
      }
    }catch(e){ console.warn('Query config load failed', e); }
  }

  // Static Site Mode helpers
  let __manifest = null;
  async function loadManifest(){
    try{
      const tryUrls = ['slides.json','content/slides.json'];
      for(const u of tryUrls){
        try{
          const res = await fetch(u, { credentials: 'omit' });
          if(res.ok){ const json = await res.json(); if(json && Array.isArray(json.decks)) return json; }
        }catch{}
      }
    }catch{}
    return null;
  }
  async function loadDeckFromPath(path){
    try{
      const res = await fetch(path, { credentials: 'omit' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      slidesHTML = splitSlides(text); try{ window.slidesHTML = slidesHTML; }catch{}
      // Apply deck-level frontmatter BEFORE rendering so initial UI + active thumb use correct theme
      try{
        const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {}));
        applyDeckFrontmatter(fm);
        // Pre-set the active thumb gradient var from CONFIG to avoid first-frame mismatch
        try{ setThumbActiveBgFromConfig(); }catch{}
        try{ setBgButtonLabel(); }catch{}
      }catch{}
      renderSlides(slidesHTML);
      // Ensure active thumbnail gradient matches theme immediately after first render
      try{ setThumbActiveBgFromConfig(); updateActiveThumbGradient(true); }catch{}
      // Update URL param without reload
      try{
        const url = new URL(location.href);
        url.searchParams.set('deck', path);
        history.replaceState(null,'',url.toString());
      }catch{}
      try{ showToast('Deck loaded'); }catch{}
    }catch(err){ console.error('Deck load failed', err); alert('Failed to load deck: '+(err?.message||err)); }
  }
  function showDeckPicker(){
    try{
      if(!__manifest || !Array.isArray(__manifest.decks) || __manifest.decks.length===0) return;
      // Build simple picker modal
      let overlay = document.getElementById('deckPickerOverlay');
      let modal = document.getElementById('deckPickerModal');
      if(!overlay){
        overlay = document.createElement('div'); overlay.id='deckPickerOverlay'; overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,0.35)'; overlay.style.zIndex='40'; overlay.style.display='none';
        document.body.appendChild(overlay);
      }
      if(!modal){
        modal = document.createElement('div'); modal.id='deckPickerModal'; modal.style.position='fixed'; modal.style.top='50%'; modal.style.left='50%'; modal.style.transform='translate(-50%,-50%)'; modal.style.width='min(520px, 92vw)'; modal.style.maxHeight='70vh'; modal.style.overflow='auto'; modal.style.background='var(--card)'; modal.style.border='1px solid rgba(255,255,255,0.12)'; modal.style.borderRadius='12px'; modal.style.boxShadow='var(--shadow)'; modal.style.padding='16px'; modal.style.zIndex='41'; modal.style.display='none';
        const h = document.createElement('div'); h.style.fontWeight='700'; h.style.margin='0 0 10px 0'; h.textContent='Select a Deck'; modal.appendChild(h);
        const list = document.createElement('div'); list.id='deckPickerList'; list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='8px'; modal.appendChild(list);
        const close = document.createElement('button'); close.className='btn'; close.textContent='Close'; close.style.marginTop='12px'; close.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; };
        modal.appendChild(close);
        document.body.appendChild(modal);
        overlay.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; };
      }
      const list = modal.querySelector('#deckPickerList');
      list.innerHTML='';
      __manifest.decks.forEach(it=>{
        const btn=document.createElement('button'); btn.className='btn'; btn.textContent=(it.title||it.path||'Deck'); btn.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; loadDeckFromPath(it.path); };
        list.appendChild(btn);
      });
      overlay.style.display='block'; modal.style.display='flex'; modal.style.flexDirection='column';
    }catch(e){ console.warn('Deck picker failed', e); }
  }

  (async function init() {
    dlog('SlideApp v0.91 initializing...');
    setDrawerUI(); 
  applyUiMode();
    setBgFromPrefs(); 
    await maybeLoadConfigFromQuery();
    applyConfig(); 
    // Try Static Site Mode (opt-in) via query (?static=1 or ?deck=...) or GitHub Pages host; otherwise fall back
    try{
      const sp = new URLSearchParams(location.search);
      const deckParam = (sp.get('deck')||'').trim();
      const staticParam = (sp.get('static')||'').trim();
      const onPages = /\.github\.io$/i.test(location.hostname);
      const enableStatic = !!deckParam || staticParam === '1' || onPages;
      if(enableStatic){
        if(deckParam){
          await loadDeckFromPath(deckParam);
        } else {
          __manifest = await loadManifest();
          if(__manifest && Array.isArray(__manifest.decks) && __manifest.decks.length){
            // Show Decks button
            try{ const b=document.getElementById('decksBtn'); if(b){ b.style.display='inline-block'; b.onclick=()=>showDeckPicker(); } }catch{}
            if(__manifest.decks.length===1){
              await loadDeckFromPath(__manifest.decks[0].path);
            } else {
              showDeckPicker();
            }
          } else {
            await boot();
          }
        }
      } else {
        await boot();
      }
    }catch(e){ console.warn('Static mode bootstrap failed, falling back', e); await boot(); }
    dlog('SlideApp initialization complete.');
  })();

  // Opacity toggle (T key): 0% <-> last saved opacity (baseline)
  function toggleOpacity(){
    try{
      // Determine current value from CONFIG (decimal 0..1) and compute baseline from persisted settings
      let dec = (typeof CONFIG.slideOpacity === 'number' && isFinite(CONFIG.slideOpacity)) ? CONFIG.slideOpacity : 1;
      let base = (typeof BASE_OPACITY === 'number' && isFinite(BASE_OPACITY)) ? BASE_OPACITY : 1;
      if(base <= 0) base = 1; // guard against degenerate baseline of 0
      const pct = Math.round(dec * 100);
      const nextPct = pct > 0 ? 0 : Math.round(base * 100);
      setSlideOpacity(nextPct);
      // Sync Style modal controls if present
      const slider = document.getElementById('cfgSlideOpacity');
      const readout = document.getElementById('cfgSlideOpacityVal');
      if(slider){ slider.value = String(nextPct); }
      if(readout){ readout.textContent = `(${nextPct}%)`; }
      // Toast
      try{ showToast(nextPct===0 ? 'Opacity: clear' : `Opacity: ${nextPct}%`); }catch{}
    }catch{}
  }

  // Progress visibility toggle (P key)
  function toggleProgress(){
    try{
      const body = document.body;
      const prog = document.querySelector('.deck-footer .progress');
      if(!prog) return;
      const hasOn = body.classList.contains('progress-on');
      const hasOff = body.classList.contains('progress-off');
      if(hasOn){
        body.classList.remove('progress-on');
        body.classList.add('progress-off');
        try{ showToast('Progress: hidden'); }catch{}
        return;
      }
      if(hasOff){
        body.classList.remove('progress-off');
        body.classList.add('progress-on');
        try{ showToast('Progress: shown'); }catch{}
        return;
      }
      // Default state: determine current visibility and flip
      const visible = getComputedStyle(prog).display !== 'none';
      if(visible){
        body.classList.add('progress-off');
        try{ showToast('Progress: hidden'); }catch{}
      } else {
        body.classList.add('progress-on');
        try{ showToast('Progress: shown'); }catch{}
      }
    }catch{}
  }

  // ===== Overlay toggle button =====
  (function bindOverlayToggle(){
    const btn = document.getElementById('overlayBtn');
    if(!btn) return;
  const rebuild = ()=>{ rebuildOverlays(); };
    const setLabel=()=>{ btn.textContent = CONFIG.overlayOn===true ? 'üè∑Ô∏è Title (on)' : 'üè∑Ô∏è Title'; };
    setLabel();
    btn.addEventListener('click',()=>{
  CONFIG.overlayOn = !(CONFIG.overlayOn===true);
  // Do not auto-persist full CONFIG here; Save in the Style modal is the explicit persistence action.
      setLabel();
      rebuild();
      try{ showToast(CONFIG.overlayOn ? 'Overlay: shown' : 'Overlay: hidden'); }catch{}
      // Sync Style checkbox if open
  try{ const cb=document.getElementById('cfgOverlayTitleOn'); if(cb) cb.checked = (CONFIG.overlayOn===true); }catch{}
      // If Style modal is open, also update position buttons disabled state and hint
      try{
        const posWrap=document.getElementById('cfgOverlayPos');
        const posHint=document.getElementById('cfgOverlayPosHint');
        const ts=document.getElementById('cfgTitleSize');
        const ss=document.getElementById('cfgSubtitleSize');
        const cbSub=document.getElementById('cfgOverlaySubtitleOn');
        const sc=document.getElementById('cfgSubtitleColor');
        if(posWrap){
          const disable = !(CONFIG.overlayOn===true);
          [...posWrap.querySelectorAll('button')].forEach(b=>{ if(disable){ b.setAttribute('disabled',''); b.setAttribute('aria-disabled','true'); } else { b.removeAttribute('disabled'); b.setAttribute('aria-disabled','false'); } });
          if(posHint){ posHint.style.display = disable ? 'inline' : 'none'; }
          if(ts) ts.disabled = disable;
          if(ss) ss.disabled = disable;
          if(cbSub) cbSub.disabled = disable;
          if(sc) sc.disabled = disable;
        }
      }catch{}
  });

  // ===== In-app Deck Validator =====
  (function initValidator(){
    const valOverlay = document.getElementById('valOverlay');
    const valModal = document.getElementById('valModal');
    const valBody = document.getElementById('valBody');
    const open = () => { valOverlay.style.display='block'; valModal.style.display='flex'; };
    const close = () => { valOverlay.style.display='none'; valModal.style.display='none'; };
    document.getElementById('valClose').addEventListener('click', close);
    document.getElementById('valOk').addEventListener('click', close);
    document.getElementById('validateBtn').addEventListener('click', ()=>{
      const warnings = (()=>{
        const allowedDeck = new Set([
          'app-name','appname','brand',
          'theme-primary','theme-accent','theme-text','primary','accent','textcolor','text-color','text',
          'background','effect-color','effectcolor','effect','ui','font-primary','font-secondary','primaryfont','secondaryfont',
          'defaults-overlay','defaults-overlay-pos','defaults-title-size','defaults-subtitle-size','defaults-slide-opacity','defaults-slide-bg1','defaults-slide-bg2',
          'appbg1','appbg2','app-bg1','app-bg2','app-bg-1','app-bg-2','opacity','slideopacity',
          // Newer deck-level keys
          'content-pos','overlay-subtitle-size','overlay-subtitle-color','overlaysubtitlecolor','overlaysubtitle','subtitleenabled',
          'button-text-color','btn-text-color','button-fill'
        ]);
        const allowedSlide = new Set([
          'title','subtitle','notes','overlay','overlay-pos','overlaypos','title-size','titlesize','subtitle-size','subtitlesize','slide-bg1','slide-bg2','slidebg1','slidebg2',
          // New per-slide keys
          'content-pos','overlay-subtitle','overlay-subtitle-size','overlay-subtitle-color','overlaysubtitle','overlaysubtitlecolor'
        ]);
        const migrate = new Map(Object.entries({
          primary:'theme-primary', accent:'theme-accent', textcolor:'theme-text', 'text-color':'theme-text', text:'theme-text', effectcolor:'effect-color', effect:'effect-color', appname:'app-name', brand:'app-name', appbg1:'defaults-slide-bg1', 'app-bg1':'defaults-slide-bg1', 'app-bg-1':'defaults-slide-bg1', appbg2:'defaults-slide-bg2', 'app-bg2':'defaults-slide-bg2', 'app-bg-2':'defaults-slide-bg2', slideopacity:'defaults-slide-opacity', opacity:'defaults-slide-opacity', primaryfont:'font-primary', secondaryfont:'font-secondary', overlaypos:'overlay-pos', titlesize:'title-size', subtitlesize:'subtitle-size', slidebg1:'slide-bg1', slidebg2:'slide-bg2'
        }));
        const isHex=(s)=>/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test((s||'').toString().trim().replace(/^['"]|['"]$/g,''));
        const isBg=(s)=>['gradient','particles','off'].includes((s||'').toString().trim().toLowerCase());
        const isBool=(s)=>/^(on|off|show|hide|true|false|1|0)$/i.test((s||'').toString().trim());
        const isPos=(s)=>['tl','tr','bl','br'].includes((s||'').toString().trim().toLowerCase());
        const isContentPos=(s)=>/^[tmb][lmr]$/i.test((s||'').toString().trim());
        const isSubtitleColor=(s)=>/^(accent|primary)$/i.test((s||'').toString().trim());
        const isButtonFill=(s)=>/^(solid|outline)$/i.test((s||'').toString().trim());
        const clamp=(n,lo,hi)=>{ n=Number(n); if(!isFinite(n)) return null; return Math.max(lo, Math.min(hi, n)); };
        const parseOpacity=(raw)=>{ const s=(raw||'').toString().trim(); if(!s) return null; if(/%$/.test(s)) return clamp(parseFloat(s),0,100); const num=parseFloat(s); if(!isFinite(num)) return null; if(num<=1) return clamp(num*100,0,100); return clamp(num,0,100); };
        const out=[];
        try{
          const deckFM = (Array.isArray(slidesHTML) && slidesHTML.length) ? (slidesHTML[0]?.fm || {}) : {};
          for(const [kRaw,v] of Object.entries(deckFM)){
            const k = String(kRaw).trim().toLowerCase();
            if(!allowedDeck.has(k)){
              const sug = migrate.get(k);
              out.push(`Deck: unknown key '${kRaw}'${sug? ` (did you mean '${sug}'?)`: ''}`);
            }
            if(migrate.has(k)) out.push(`Deck: legacy key '${kRaw}' ‚Äî prefer '${migrate.get(k)}'`);
            switch(k){
              case 'theme-primary': case 'theme-accent': case 'theme-text':
              case 'primary': case 'accent': case 'textcolor': case 'text-color': case 'text':
              case 'effect-color': case 'effectcolor': case 'effect':
              case 'defaults-slide-bg1': case 'defaults-slide-bg2':
              case 'appbg1': case 'appbg2': case 'app-bg1': case 'app-bg2': case 'app-bg-1': case 'app-bg-2':
                if(!isHex(v)) out.push(`Deck: '${kRaw}' expects hex color, got '${v}'`);
                break;
              case 'background': if(!isBg(v)) out.push(`Deck: 'background' must be gradient|particles|off, got '${v}'`); break;
              case 'ui': if(!isBool(v)) out.push(`Deck: 'ui' must be on|off|show|hide|true|false|1|0, got '${v}'`); break;
              case 'defaults-overlay': if(!isBool(v)) out.push(`Deck: 'defaults-overlay' must be true|false|on|off|1|0, got '${v}'`); break;
              case 'defaults-overlay-pos': if(!isPos(v)) out.push(`Deck: 'defaults-overlay-pos' must be tl|tr|bl|br, got '${v}'`); break;
              case 'defaults-title-size': if(clamp(v,12,64)===null) out.push(`Deck: 'defaults-title-size' must be 12..64, got '${v}'`); break;
              case 'defaults-subtitle-size': if(clamp(v,10,48)===null) out.push(`Deck: 'defaults-subtitle-size' must be 10..48, got '${v}'`); break;
              case 'defaults-slide-opacity': case 'opacity': case 'slideopacity': if(parseOpacity(v)===null) out.push(`Deck: '${kRaw}' must be 0..100, 0..1, or a percent string, got '${v}'`); break;
              case 'content-pos': if(!isContentPos(v)) out.push(`Deck: 'content-pos' must be one of tl|tm|tr|ml|mm|mr|bl|bm|br, got '${v}'`); break;
              case 'overlay-subtitle-size': if(clamp(v,10,48)===null) out.push(`Deck: 'overlay-subtitle-size' must be 10..48, got '${v}'`); break;
              case 'overlay-subtitle-color': case 'overlaysubtitlecolor': if(!isSubtitleColor(v)) out.push(`Deck: '${kRaw}' must be primary|accent, got '${v}'`); break;
              case 'overlaysubtitle': case 'subtitleenabled': if(!isBool(v)) out.push(`Deck: '${kRaw}' must be true|false|on|off|1|0, got '${v}'`); break;
              case 'button-text-color': case 'btn-text-color': { const t=String(v).trim(); if(!/^auto$/i.test(t)){ if(!isHex(v)) out.push(`Deck: '${kRaw}' expects hex or 'auto', got '${v}'`); } break; }
              case 'button-fill': if(!isButtonFill(v)) out.push(`Deck: 'button-fill' must be solid|outline, got '${v}'`); break;
            }
          }
          // Per-slide
          (slidesHTML||[]).slice(1).forEach((s,idx)=>{
            const fm = s?.fm || {}; const n=idx+1;
            for(const [kRaw,v] of Object.entries(fm)){
              const k = String(kRaw).trim().toLowerCase();
              if(!allowedSlide.has(k)){
                const sug = migrate.get(k);
                out.push(`Slide ${n}: unknown key '${kRaw}'${sug? ` (did you mean '${sug}'?)`: ''}`);
              }
              if(migrate.has(k)) out.push(`Slide ${n}: legacy key '${kRaw}' ‚Äî prefer '${migrate.get(k)}'`);
              switch(k){
                case 'slide-bg1': case 'slide-bg2': case 'slidebg1': case 'slidebg2': if(!isHex(v)) out.push(`Slide ${n}: '${kRaw}' expects hex color, got '${v}'`); break;
                case 'overlay': if(!isBool(v)) out.push(`Slide ${n}: 'overlay' must be true|false|on|off|1|0, got '${v}'`); break;
                case 'overlay-pos': case 'overlaypos': if(!isPos(v)) out.push(`Slide ${n}: '${kRaw}' must be tl|tr|bl|br, got '${v}'`); break;
                case 'title-size': case 'titlesize': if(clamp(v,12,64)===null) out.push(`Slide ${n}: '${kRaw}' must be 12..64, got '${v}'`); break;
                case 'subtitle-size': case 'subtitlesize': if(clamp(v,10,48)===null) out.push(`Slide ${n}: '${kRaw}' must be 10..48, got '${v}'`); break;
                case 'content-pos': if(!isContentPos(v)) out.push(`Slide ${n}: 'content-pos' must be tl|tm|tr|ml|mm|mr|bl|bm|br, got '${v}'`); break;
                case 'overlay-subtitle': if(!isBool(v)) out.push(`Slide ${n}: 'overlay-subtitle' must be true|false|on|off|1|0, got '${v}'`); break;
                case 'overlay-subtitle-size': if(clamp(v,10,48)===null) out.push(`Slide ${n}: 'overlay-subtitle-size' must be 10..48, got '${v}'`); break;
                case 'overlay-subtitle-color': case 'overlaysubtitlecolor': if(!isSubtitleColor(v)) out.push(`Slide ${n}: '${kRaw}' must be primary|accent, got '${v}'`); break;
              }
            }
          });
        }catch(e){ out.push('Validator error: '+(e&&e.message)); }
        return out;
      })();
      // Render
      if(!warnings.length){ valBody.innerHTML='<p style="margin:0">‚úÖ No issues found.</p>'; }
      else {
        const list = warnings.map(w=>`<li>${w.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</li>`).join('');
        valBody.innerHTML = `<p style="margin-top:0">‚ö† Found ${warnings.length} warning(s):</p><ul style="margin:8px 0 0 18px;">${list}</ul>`;
      }
      open();
    });
  })();

  // ===== In-app TOC =====
  (function initToc(){
    const tocOverlay = document.getElementById('tocOverlay');
    const tocModal = document.getElementById('tocModal');
    const tocBody = document.getElementById('tocBody');
    function layoutPanel(){
      const wide = innerWidth >= 1280;
      if(wide){
        tocOverlay.style.display='none';
        tocModal.style.display='flex';
        tocModal.style.top='60px'; tocModal.style.bottom='20px'; tocModal.style.left='auto'; tocModal.style.right='20px'; tocModal.style.width='320px';
      } else {
        tocModal.style.top='40px'; tocModal.style.bottom='40px'; tocModal.style.left='40px'; tocModal.style.right='40px'; tocModal.style.width='auto';
      }
      return wide;
    }
    const open = () => { const wide=layoutPanel(); tocOverlay.style.display= wide ? 'none':'block'; tocModal.style.display='flex'; };
    const close = () => { tocOverlay.style.display='none'; tocModal.style.display='none'; };
    document.getElementById('tocClose').addEventListener('click', close);
    document.getElementById('tocOk').addEventListener('click', close);
    const build = ()=>{
      const items = [];
      try{
        const slides = Array.from(document.querySelectorAll('.slide'));
        slides.forEach((s, idx)=>{
          const hs = Array.from(s.querySelectorAll('h1, h2, h3'));
          hs.forEach(h=>{
            const level = h.tagName.toLowerCase();
            const text = (h.textContent||'').trim();
            items.push({ idx, level, text });
          });
        });
      }catch{}
      if(!items.length){ tocBody.innerHTML = '<p style="margin:0">No headings found.</p>'; return; }
      const rows = items.map(it=>{
        const pad = it.level==='h1'? '' : it.level==='h2'? '&nbsp;&nbsp;' : '&nbsp;&nbsp;&nbsp;&nbsp;';
        return `<div style=\"padding:4px 0; cursor:pointer;\" data-idx=\"${it.idx}\">${pad}${it.text.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</div>`;
      }).join('');
      tocBody.innerHTML = rows;
      Array.from(tocBody.children).forEach((el)=>{
        el.addEventListener('click', ()=>{ const i = Number(el.getAttribute('data-idx')); if(Number.isFinite(i)){ try{ setActive(i); }catch{} close(); }});
      });
    };
    document.getElementById('tocBtn').addEventListener('click', ()=>{ build(); open(); });
    window.addEventListener('resize', ()=>{ if(tocModal.style.display!=='none'){ open(); } });
  })();
  })();

  // ===== Deck-level frontmatter application =====
  function applyDeckFrontmatter(fm){
    if(!fm || typeof fm !== 'object') return;
  function setDocumentTitle(){
    try{
      const deckNm = (typeof window.__deckAppName === 'string' && window.__deckAppName.trim()) ? window.__deckAppName.trim() : '';
      const cfgNm = (typeof CONFIG.appName === 'string' && CONFIG.appName.trim()) ? CONFIG.appName.trim() : '';
      const title = deckNm || cfgNm || 'SlideApp';
      document.title = title;
    }catch{}
  }
  // Reset temporary progress overrides when applying a new deck's settings
  try{ document.body.classList.remove('progress-on','progress-off'); }catch{}
    // Background mode
    try{
      const bg = String(fm.background || fm.bg || '').trim().toLowerCase();
      if(bg && ['gradient','particles','off'].includes(bg)) { setBackgroundMode(bg); try{ showToast(`Deck background: ${bg}`);}catch{} }
    }catch{}
    // App name (brand legacy)
    try{
      const nm = (fm.appname || fm['app-name'] || fm.brand || '').toString().trim();
      if(nm){ CONFIG.appName = nm; CONFIG.brand = CONFIG.brand || nm; try{ window.__deckAppName = nm; }catch{} }
    }catch{}
    // Colors (hex)
    const hexRe = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;
      const strip = s=> (s||'').toString().trim().replace(/^['"]|['"]$/g,'');
      try{
        const pRaw = strip(fm.primary||fm.color|| fm['theme-primary'] || '');
        const p = normalizeHex(pRaw);
        if(p) CONFIG.primary = p;
      }catch{}
      try{
        const aRaw = strip(fm.accent|| fm['theme-accent'] || '');
        const a = normalizeHex(aRaw);
        if(a) CONFIG.accent = a;
      }catch{}
    // Theme text color
    try{
      const tRaw = strip(fm['theme-text'] || '');
      const t = normalizeHex(tRaw);
      if(t) CONFIG.textColor = t;
    }catch{}
    // App background colors (hex)
    try{
      const ab1Raw = strip(fm.appbg1 || fm['app-bg1'] || fm['app-bg-1'] || '');
      const ab1 = normalizeHex(ab1Raw);
      if(ab1) CONFIG.appBg1 = ab1;
    }catch{}
    try{
      const ab2Raw = strip(fm.appbg2 || fm['app-bg2'] || fm['app-bg-2'] || '');
      const ab2 = normalizeHex(ab2Raw);
      if(ab2) CONFIG.appBg2 = ab2;
    }catch{}
    // Defaults slide background (deck-level defaults for slides)
    try{
      const sb1Raw = strip(fm['defaults-slide-bg1'] || '');
      const sb1 = normalizeHex(sb1Raw);
      if(sb1) CONFIG.slideBg1 = sb1;
    }catch{}
    try{
      const sb2Raw = strip(fm['defaults-slide-bg2'] || '');
      const sb2 = normalizeHex(sb2Raw);
      if(sb2) CONFIG.slideBg2 = sb2;
    }catch{}
    // Effect color (hex) used by particles/gradients
    try{
      const ecRaw = strip(fm.effectcolor || fm['effect-color'] || fm.effect || '');
      const ec = normalizeHex(ecRaw);
      if(ec) CONFIG.effectColor = ec;
    }catch{}
    // Text color (legacy)
    try{
      const tcRaw = strip(fm.textcolor || fm['text-color'] || fm.text || '');
      const tc = normalizeHex(tcRaw);
      if(tc) CONFIG.textColor = tc;
    }catch{}
    // Button text color and fill
    try{
      const btcRaw = (fm['button-text-color'] || fm['btn-text-color'] || '').toString().trim();
      if(btcRaw){
        if(/^auto$/i.test(btcRaw)) CONFIG.btnTextColor = 'auto';
        else { const n = normalizeHex(btcRaw); if(n) CONFIG.btnTextColor = n; }
      }
    }catch{}
    try{
      const bfRaw = (fm['button-fill'] || '').toString().trim().toLowerCase();
      if(bfRaw && /^(solid|outline)$/.test(bfRaw)) CONFIG.btnFill = bfRaw;
    }catch{}
    // Opacity (percent 0-100 or decimal 0-1 or with %)
    let hasOpacity=false; let decOpacity=null;
    try{
      const raw = strip(fm.opacity || fm.slideopacity || fm['defaults-slide-opacity'] || '');
      if(raw){
        hasOpacity = true;
        let pct;
        if(/%$/.test(raw)){
          pct = parseFloat(raw.replace(/%/g,''));
        } else {
          const num = parseFloat(raw);
          if(isFinite(num) && num <= 1){ pct = num * 100; }
          else { pct = num; }
        }
        if(!isFinite(pct)) pct = 100;
        pct = Math.round(Math.max(0, Math.min(100, pct)));
        decOpacity = pct/100;
        CONFIG.slideOpacity = decOpacity;
      }
    }catch{}
  // Apply brand/colors and opacity via existing helper
  try{ if(window.Theme && typeof window.Theme.applyConfig === 'function'){ try{ window.Theme.applyConfig(CONFIG); }catch{} } else { applyConfig(); } }catch{}
    if(hasOpacity){
      try{ setSlideOpacity(decOpacity * 100); }catch{}
    }
  // Typography and overlays
  try{ if(typeof fm.primaryfont==='string' && fm.primaryfont.trim()) CONFIG.fontPrimary = fm.primaryfont.trim(); }catch{}
  try{ if(typeof fm['font-primary']==='string' && fm['font-primary'].trim()) CONFIG.fontPrimary = fm['font-primary'].trim(); }catch{}
  try{ if(typeof fm.secondaryfont==='string' && fm.secondaryfont.trim()) CONFIG.fontSecondary = fm.secondaryfont.trim(); }catch{}
  try{ if(typeof fm['font-secondary']==='string' && fm['font-secondary'].trim()) CONFIG.fontSecondary = fm['font-secondary'].trim(); }catch{}
  // overlay (new) and legacy + namespaced defaults-
  try{ if(typeof fm.overlay!=='undefined'){ const v=String(fm.overlay).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } else if(typeof fm.titleoverlay!=='undefined'){ const v=String(fm.titleoverlay).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } else if(typeof fm['defaults-overlay']!=='undefined'){ const v=String(fm['defaults-overlay']).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } }catch{}
  try{ const p=(fm['overlay-pos']||fm.overlaypos||fm.titleposition||fm['defaults-overlay-pos']||'').toString().toLowerCase(); if(['tl','tr','bl','br'].includes(p)) CONFIG.overlayPos=p; }catch{}
  // Content position default for deck
  try{ const c=(fm['content-pos']||fm.contentpos||'').toString().toLowerCase(); if(/^[tmb][lmr]$/.test(c)) CONFIG.contentPos = c; }catch{}
  try{ const tRaw = (typeof fm['title-size']!=='undefined') ? fm['title-size'] : (typeof fm.titlesize!=='undefined' ? fm.titlesize : fm['defaults-title-size']); const n=Math.round(Number(tRaw)); if(isFinite(n)) CONFIG.overlayTitleSize = Math.max(12, Math.min(64, n)); }catch{}
  try{ if(typeof fm.overlaysubtitle!=='undefined'){ const v=String(fm.overlaysubtitle).trim().toLowerCase(); CONFIG.overlaySubtitleOn = !(v==='false'||v==='0'||v==='off'); } else if(typeof fm.subtitleenabled!=='undefined'){ const v=String(fm.subtitleenabled).trim().toLowerCase(); CONFIG.overlaySubtitleOn = !(v==='false'||v==='0'||v==='off'); } else if(typeof fm['defaults-overlay']!=='undefined'){ /* already handled by overlayOn */ } }catch{}
  try{ const sRaw = (typeof fm['overlay-subtitle-size']!=='undefined') ? fm['overlay-subtitle-size'] : (typeof fm.subtitlesize!=='undefined' ? fm.subtitlesize : fm['defaults-subtitle-size']); const n=Math.round(Number(sRaw)); if(isFinite(n)) CONFIG.overlaySubtitleSize = Math.max(10, Math.min(48, n)); }catch{}
  try{ const c=((fm.overlaysubtitlecolor||'') || (fm['overlay-subtitle-color']||'') ).toString().toLowerCase(); if(c==='accent'||c==='primary') CONFIG.overlaySubtitleColor=c; }catch{}
    applyConfig();
  // Ensure tab title reflects deck/app precedence (deck > style config)
    try{ setDocumentTitle(); }catch{}
  // Rebuild overlays for current slides
    try{
  rebuildOverlays();
    }catch{}
    // UI mode (on/off, show/hide, 1/0, true/false)
    try{
      if(typeof fm.ui !== 'undefined'){
        let v = String(fm.ui).trim().toLowerCase();
        let on;
        if(v==='on' || v==='show' || v==='true' || v==='1'){ on = 0; } // on => ui visible => uiMode 0
        else if(v==='off' || v==='hide' || v==='false' || v==='0'){ on = 1; } // off => hide UI => uiMode 1
        if(typeof on === 'number'){
          uiMode = on; localStorage.setItem('uiMode', on ? '1':'0'); applyUiMode();
        }
      }
  }catch{}
  // Refresh background button label in case background mode was changed above
  try{ setBgButtonLabel(); }catch{}
  }

  // ===== Self-tests (non-intrusive) =====
  (function selfTests(){
    try{
      // Minimal checks to avoid heavy literals in inline script
      console.assert(typeof setSlideOpacity === 'function', 'setSlideOpacity exists');
  // Preserve current opacity (stored as decimal 0..1)
  const prev = (typeof CONFIG.slideOpacity === 'number') ? CONFIG.slideOpacity : 1;
  // Expect clamping at the low end
  const low = setSlideOpacity(-5); // -5% -> 0
  console.assert(low === 0, 'opacity clamp low');
  // Expect clamping at the high end (100%)
  const high = setSlideOpacity(100);
  console.assert(high === 1, 'opacity clamp high');
  const o1 = getComputedStyle(document.documentElement).getPropertyValue('--slide-bg1').trim();
  const o2 = getComputedStyle(document.documentElement).getPropertyValue('--slide-bg2').trim();
      console.assert(o1 && o2, 'opacity CSS vars set');
      console.log('[SlideApp tests] OK');
  // Restore previous opacity so tests don't affect UI state
  setSlideOpacity(prev * 100);
    }catch(e){ console.error('[SlideApp tests] FAIL', e); }
  })();
  </script>
</body>
</html>
