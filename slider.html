<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SlideApp v0.9.1 — Optimised & Secure</title>
  <!-- Favicon (fixed stray quote) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎬</text></svg>">
  <style>
    :root { 
  --bg-1:#0f172a;--bg-2:#1e293b;--text:#e2e8f0;--muted:#94a3b8;--primary:#01B4E1;--accent:#64FFFC;--card:#111827cc;--radius:18px;--shadow:0 10px 30px rgba(0,0,0,0.25);
      /* App background colors (configurable via front matter) */
      --app-bg1: var(--bg-1);
      --app-bg2: var(--bg-2);
      /* Effect color for particles/gradients (configurable via front matter) */
      --effect-color: var(--accent);
      /* Typography defaults (configurable) */
      --font-primary: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-secondary: Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      /* Overlay title sizes */
      --title-size: 22px; /* default */
      --subtitle-size: 16px; /* default */
    } 
    *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-primary);color:var(--text);background:linear-gradient(120deg,var(--app-bg1),var(--app-bg2));overflow:hidden;height:100vh;display:flex}
  .bg-gradient{position:fixed;inset:0;z-index:-2;background:linear-gradient(45deg,var(--app-bg1),var(--app-bg2),var(--app-bg1));background-size:400% 400%;animation:moveGradient 30s ease-in-out infinite;filter:saturate(1.1)}
    #bg-canvas{position:fixed;inset:0;z-index:-1;display:none}
    @keyframes moveGradient{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}

  .thumbs{width:220px;background:linear-gradient(180deg,var(--app-bg1, #0b1220), var(--app-bg2, #0f172a));overflow-y:auto;padding:8px;display:flex;flex-direction:column;gap:8px;border-right:1px solid rgba(255,255,255,.08)}
    .thumbs.overlay{position:fixed;left:0;top:0;bottom:0;transform:translateX(-100%);transition:transform .25s ease;z-index:14}
    .thumbs.overlay.open{transform:translateX(0)}
    .thumbs.collapsed{width:0;padding:0;border-right:none}
  /* Thumbnail visuals (CSS-driven)
     Variables:
       --thumb-radius      Border radius for thumbnails
       --thumb-padding     Padding inside each thumbnail
       --thumb-font-size   Font size used in thumbnails
       --thumb-border      Border width for thumbnail frames
       --thumb-transition  Duration for thumb transitions
       --thumb-elevation   Shadow/elevation magnitude used on hover/active
  */
  :root{ --thumb-radius:8px; --thumb-padding:8px; --thumb-font-size:12px; --thumb-border:1px; --thumb-transition:220ms; --thumb-elevation:6px; }
  .thumb{cursor:pointer;padding:var(--thumb-padding);border-radius:var(--thumb-radius);font-size:var(--thumb-font-size);color:var(--text);background:linear-gradient(180deg,var(--app-bg1, #0b1220), var(--app-bg2, #0f172a));border:var(--thumb-border) solid rgba(0,0,0,0.12);transition:transform var(--thumb-transition) ease, box-shadow var(--thumb-transition) ease, border-color var(--thumb-transition) ease, background var(--thumb-transition) ease;transform-origin:left center;display:flex;align-items:center;gap:8px}
  .thumb:hover{ transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 20px rgba(0,0,0,0.18); }
  /* Accessible focus styles for keyboard users */
  .thumb:focus{ outline: none; }
  .thumb:focus-visible{ box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent); transform: translateY(-4px) scale(1.02); }
  /* Active slide in the thumbnails reflects theme colors: subtle scale + accent outline */
  /* Use background shorthand so computed background includes our gradient for automated checks */
  /* Ensure computed backgroundImage reflects the active gradient explicitly for testing */
  .thumb.active{background:var(--thumb-active-bg, linear-gradient(135deg,var(--primary),var(--accent))) !important;background-image:var(--thumb-active-bg, linear-gradient(135deg,var(--primary),var(--accent))) !important;color:#fff;border-color:color-mix(in srgb, var(--accent) 40%, transparent);transform:translateY(-2px) scale(1.04);box-shadow:0 10px 28px color-mix(in srgb, var(--accent) 18%, rgba(0,0,0,0.18));}
  /* Slightly emphasize active thumb with an inner ring on larger displays */
  @media (min-width:720px){ .thumb.active{ outline: 2px solid color-mix(in srgb, var(--accent) 30%, transparent); outline-offset:2px; } }

    .deck{position:relative;flex:1;height:100vh;overflow:hidden}
    .deck-header{position:absolute;top:14px;left:24px;right:24px;display:flex;align-items:center;justify-content:space-between;z-index:5}
  /* Show brand as plain text (no pill) so presets like Light 1 don't create a grey rounded background */
  .brand{display:flex;align-items:center;gap:12px;padding:0;background:transparent;border-radius:0;box-shadow:none}
    .brand-badge{height:28px;width:28px;border-radius:8px;background:linear-gradient(135deg,var(--primary),var(--accent))}
    .brand-name{font-weight:700}
    .deck-tools{display:flex;gap:8px;align-items:center}
  /* Buttons use a subtle translucent overlay so text remains readable on light and dark app backgrounds */
  .btn{cursor:pointer;padding:6px 10px;border-radius:12px;color:var(--text);background:linear-gradient(rgba(255,255,255,0.02), rgba(0,0,0,0.04));border:1px solid rgba(255,255,255,.06);backdrop-filter:blur(6px);font-size:12px;line-height:1;display:inline-flex;align-items:center;min-height:32px}
  /* Keep header buttons stable regardless of drawer state */
  .deck-header .btn{ border-radius:12px; padding:8px 12px; min-height:32px; }
  /* Use CSS variables for button background so themes can update them consistently */
  :root{ --btn-bg: linear-gradient(rgba(255,255,255,0.02), rgba(0,0,0,0.04)); --btn-text: var(--text); }
  .btn{ background: var(--btn-bg); color: var(--btn-text); }

    /* Reserve space using CSS vars so we can position the frame precisely */
    :root{ --pad-top:96px; --pad-bottom:120px; --pad-side:72px }
    .slides{position:absolute;inset:0;display:block}
    body.ui-off :root{ --pad-top:24px; --pad-bottom:32px }
  /* A single framed slide that fills the padded area and scrolls internally */
  .slide{position:absolute;top:var(--pad-top);bottom:var(--pad-bottom);left:var(--pad-side);right:var(--pad-side);display:block;background:linear-gradient(180deg,var(--slide-bg1, rgba(17,24,39,.75)),var(--slide-bg2, rgba(17,24,39,.55)));border-radius:var(--radius);box-shadow:var(--slide-shadow, var(--shadow));opacity:0;transform:translate3d(60px,0,0) scale(.98);transition:all 0.6s cubic-bezier(0.4, 0, 0.2, 1);backdrop-filter:blur(var(--slide-blur, 8px));padding:0;overflow:hidden;outline:none}
  .slide .content-scroll{position:relative;height:100%;width:100%;overflow:auto;padding:56px 48px 96px 48px;display:flex;justify-content:var(--content-x, flex-start);align-items:var(--content-y, flex-start)}
  /* Slide title/subtitle overlay */
  .slide .slide-overlay{position:absolute;pointer-events:none;z-index:50;max-width:70%;display:flex;flex-direction:column;gap:4px;text-shadow:0 1px 2px rgba(0,0,0,.35)}
  .slide .slide-overlay.pos-tl{top:18px;left:24px;text-align:left}
  .slide .slide-overlay.pos-tr{top:18px;right:24px;text-align:right}
  .slide .slide-overlay.pos-bl{bottom:18px;left:24px;text-align:left}
  .slide .slide-overlay.pos-br{bottom:18px;right:24px;text-align:right}
  .slide .slide-overlay .slide-title{color:var(--primary);font-family:var(--font-primary);font-weight:800;font-size:var(--title-size);line-height:1.15;letter-spacing:-0.01em}
  .slide .slide-overlay .slide-subtitle{color:var(--primary);font-family:var(--font-secondary);font-weight:400;font-size:var(--subtitle-size);line-height:1.2;opacity:.95}
  .slide .slide-overlay .accent-subtitle{ color: var(--accent); }
  /* Theme outline around the active slide, uses accent; width configurable via --outline-w; can be disabled via body.border-off */
  .slide.active::before{content:"";position:absolute;inset:0;border-radius:var(--radius);pointer-events:none;box-shadow:inset 0 0 0 var(--outline-w, 3px) var(--accent)}
  body.border-off .slide.active::before{box-shadow:none}
    .slide.active{opacity:1;transform:translate3d(0,0,0) scale(1);z-index:2}
    .slide.prev{opacity:0;transform:translate3d(-50px,0,0) scale(.98);z-index:1}
    .slide.slide-in-right{opacity:0;transform:translate3d(100px,0,0) scale(.95)}
    .slide.slide-in-left{opacity:0;transform:translate3d(-100px,0,0) scale(.95)}
    .slide.slide-out-left{opacity:0;transform:translate3d(-100px,0,0) scale(.95)}
    .slide.slide-out-right{opacity:0;transform:translate3d(100px,0,0) scale(.95)}

.md{width:min(1100px,92%)}
  .md ul,.md ol{padding-left:20px;margin:16px 0}
  .md li{margin:8px 0}
  .md ul li{list-style-type:disc}
  .md ol li{list-style-type:decimal}
    .md blockquote{border-left:4px solid var(--accent);padding-left:16px;margin:16px 0;font-style:italic;color:var(--muted)}
    .md img{max-width:100%;height:auto;border-radius:8px;margin:16px 0}
    .md a{color:var(--accent);text-decoration:none}
    .md a:hover{text-decoration:underline}
  /* Headings hierarchy */
  .md h1{font-size:clamp(28px,3.2vw,40px);line-height:1.2;margin:0 0 12px;font-weight:800}
  .md h2{font-size:clamp(22px,2.4vw,30px);line-height:1.25;margin:18px 0 10px;font-weight:700}
  .md h3{font-size:clamp(18px,1.9vw,24px);line-height:1.3;margin:16px 0 8px;font-weight:700;color:var(--text)}
  /* Tables */
  .md table{width:100%;border-collapse:collapse;margin:16px 0;border:1px solid rgba(255,255,255,.08);border-radius:8px;overflow:hidden}
  .md th,.md td{padding:10px 12px;border:1px solid rgba(255,255,255,.08)}
  .md thead th{background:rgba(255,255,255,.06);font-weight:700}
  .md tbody tr:nth-child(odd) td{background:rgba(255,255,255,.03)}
  /* Columns shortcode */
  .md .cols{display:flex;gap:24px;align-items:flex-start}
  .md .cols .col{flex:1;min-width:0}
  @media (max-width: 820px){.md .cols{flex-direction:column}}
    pre{background:rgba(0,0,0,.35);padding:10px;border-radius:8px;overflow:auto}
    code{font-family:monospace}

    .deck-footer{position:absolute;left:24px;right:24px;bottom:18px;display:flex;align-items:center;justify-content:space-between;z-index:5}
    .progress{flex:1;height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden}
    .progress>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--primary),var(--accent))}

    .notes{position:absolute;bottom:0;left:0;right:0;background:rgba(0,0,0,.95);color:#ffffff;padding:20px 24px;font-size:16px;font-weight:500;display:none;z-index:10;max-height:30%;overflow:auto;border-top:3px solid var(--accent);box-shadow:0 -4px 20px rgba(0,0,0,0.5)}
    .notes.show{display:block}

    #scrim{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;z-index:13}

    /* Config modal */
    #cfgOverlay{position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:30}
  /* Use app background variables so the Style modal previews theme immediately */
  #cfgModal{position:fixed;top:20px;bottom:20px;left:20px;right:20px;transform:none;width:auto;max-width:none;background:linear-gradient(135deg,var(--app-bg1, #0b1220),var(--app-bg2, #0f172a));color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31;flex-direction:column}
  #cfgModal header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);flex:0 0 auto}
  #cfgModal main{padding:14px;overflow:auto;flex:1 1 auto}
  #cfgModal label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
  /* Ensure modal labels and form text follow the configured --text color */
  #cfgModal, #cfgModal *{ color: inherit; }
  #cfgModal { color: var(--text); }
  #cfgModal label{ color: var(--text); }
  :root { --admon-note:#60a5fa; --admon-tip:#34d399; --admon-warning:#fbbf24; }
  /* Admonitions */
  .admonition{border:1px solid rgba(255,255,255,0.08);border-radius:10px;margin:12px 0;overflow:hidden;background:rgba(255,255,255,0.02)}
  .admonition .admonition-title{font-weight:600;padding:8px 12px;font-size:13px;background:rgba(255,255,255,0.03);border-bottom:1px solid rgba(255,255,255,0.06)}
  .admonition .admonition-body{padding:10px 12px}
  .admonition.note .admonition-title{color:var(--admon-note)}
  .admonition.tip .admonition-title{color:var(--admon-tip)}
  .admonition.warning .admonition-title{color:var(--admon-warning)}
  /* Task lists */
  li.task{list-style:none}
  li.task::marker{content:''}
  li.task{padding-left:2px}
  /* Heading anchor hint area */
  h1[id], h2[id], h3[id]{scroll-margin-top: 80px}
  .anchor-link{margin-left:8px;opacity:.0;transition:opacity .15s ease;color:var(--muted);text-decoration:none}
  h1[id]:hover .anchor-link, h2[id]:hover .anchor-link, h3[id]:hover .anchor-link{opacity:1}
  /* Small helper for muted lead text in demo content */
  .muted-lead{color:var(--muted);margin:-6px 0 12px 0}
  #cfgModal input[type="text"]{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,0.03);color:var(--text)}
  #cfgModal input[type="color"]{width:54px;height:32px;padding:0;border:1px solid rgba(255,255,255,.18);border-radius:8px;background:transparent;color:var(--text)}
    #cfgModal .row{display:flex;gap:10px;align-items:center}
  #cfgModal footer{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);flex:0 0 auto;background:linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));backdrop-filter:blur(4px)}
  /* Active state for overlay position buttons */
  #cfgOverlayPos .btn{ min-width:44px; height:32px; box-sizing:border-box; text-align:center; padding:8px 10px; line-height:1; display:inline-flex; align-items:center; justify-content:center; white-space:nowrap; font-weight:600; }
  #cfgOverlayPos .btn.active,
  #cfgOverlayPos .btn[aria-pressed="true"]{
    border-color: var(--accent);
    box-shadow: 0 0 0 1px var(--accent) inset;
  /* Fallback then accent-derived tint for better theme consistency */
  background: rgba(255,255,255,0.04);
  background: color-mix(in srgb, var(--accent) 12%, transparent);
  }
  /* Active state for preset buttons (compact segmented control) */
  .preset-btn.active,
  .preset-btn[aria-pressed="true"]{
    border-color: var(--accent);
    /* Match overlay-position selected appearance: subtle accent tint and inset highlight */
    box-shadow: 0 0 0 1px var(--accent) inset;
    background: color-mix(in srgb, var(--accent) 12%, transparent);
    color: var(--btn-text);
  }
  /* Base style for preset buttons should match other small controls (no gradient) */
  .preset-btn{
    display:inline-block;
    padding:10px 18px;
    margin:6px 8px;
    border-radius:12px;
    background: var(--btn-bg);
    color: var(--btn-text);
    border: 2px solid rgba(255,255,255,0.06);
  }
  /* Disabled state for overlay position buttons */
  #cfgOverlayPos .btn[disabled],
  #cfgOverlayPos .btn[aria-disabled="true"]{
    opacity: .5;
    cursor: not-allowed;
    filter: grayscale(30%);
    height:32px; min-width:44px; /* keep dimensions stable when disabled */
  }
  /* Disabled style for range sliders within modal */
  #cfgModal input[type="range"][disabled]{
    opacity: .5;
    cursor: not-allowed;
    filter: grayscale(20%);
  }
  /* Disabled style for select and checkbox within modal */
  #cfgModal select[disabled],
  #cfgModal input[type="checkbox"][disabled]{
    opacity: .6;
    cursor: not-allowed;
  }

    @media print{body{overflow:visible;background:#fff;color:#000}.deck-header,.deck-footer,.bg-gradient,#bg-canvas,.thumbs,.notes{display:none!important}.slide{position:static;opacity:1;transform:none;page-break-after:always;box-shadow:none;background:#fff;color:#000}}

  /* UI visibility toggle (configurable) */
  body.ui-off .deck-header { display: none !important; }
  body.ui-off.hide-slides .thumbs { display: none !important; }
  body.ui-off.hide-slides .thumbs.overlay { transform: translateX(-100%) !important; }
  body.ui-off.hide-progress .deck-footer .progress,
  body.ui-off.hide-progress .deck-footer > div:first-child,
  body.ui-off.hide-progress .deck-footer #slideNo { display: none !important; }
  body.ui-off #scrim { display: none !important; }
  /* Progress key-toggle overrides */
  body.progress-on .deck-footer .progress,
  body.progress-on .deck-footer > div:first-child,
  body.progress-on .deck-footer #slideNo { display: block !important; }
  body.ui-off.hide-progress.progress-on .deck-footer .progress,
  body.ui-off.hide-progress.progress-on .deck-footer > div:first-child,
  body.ui-off.hide-progress.progress-on .deck-footer #slideNo { display: block !important; }
  body.progress-off .deck-footer .progress,
  body.progress-off .deck-footer > div:first-child,
  body.progress-off .deck-footer #slideNo { display: none !important; }

  /* Toast (lightweight notification) */
  .toast{position:fixed;left:28px;bottom:28px;z-index:50;display:none;padding:10px 12px;border-radius:10px;background:rgba(17,24,39,.85);border:1px solid rgba(255,255,255,.12);color:var(--text);box-shadow:var(--shadow);font-size:14px;opacity:0;transform:translateY(8px);transition:opacity .2s ease, transform .2s ease}
  .toast.show{display:block;opacity:1;transform:translateY(0)}
  .toast.no-anim{transition:none}
  </style>
    <script>
      // Global helper for test-driven deterministic behavior.
      // Usage: if (window.__isDeterministicTestMode && window.__isDeterministicTestMode()) { ... }
      try{
        window.__isDeterministicTestMode = function(){
          try{
            if (window.__SLIDEAPP_TEST_DETERMINISTIC === true) return true;
            if (window.location && window.location.search){ const p = new URLSearchParams(window.location.search); if (p.get('deterministicTest') === '1') return true; }
          }catch(e){}
          return false;
        };
      }catch(e){}
    </script>
</head>
<body>
  <!-- Optional runtime theming helpers (no behavior change if absent) -->
  <script src="src/runtime/theme.js"></script>
  <!-- Particles runtime: provides start/stop/resize for canvas effects -->
  <script src="src/runtime/particles.js"></script>
  <div class="bg-gradient"></div>
  <canvas id="bg-canvas"></canvas>
  <div id="scrim"></div>
  <div class="thumbs" id="thumbs"></div>

  <div class="deck">
    <div class="deck-header">
  <div class="brand"><div class="brand-badge"></div><div class="brand-name" id="appName">SlideApp</div></div>
      <div class="deck-tools">
        <button class="btn" id="uiBtn" title="Toggle UI visibility" aria-label="Toggle UI">👁️ UI</button>
        <button class="btn" id="decksBtn" style="display:none" title="Open Decks" aria-label="Open Decks">📚 Decks</button>
        <input type="file" id="fileInput" class="btn" accept=".md,.markdown,.txt" title="Load Markdown" aria-label="Load Markdown" />
        <button class="btn" id="styleBtn" title="Style settings" aria-label="Style">🎨 Style</button>
        <button class="btn" id="validateBtn" title="Validate deck frontmatter" aria-label="Validate">🔎 Validate</button>
        <button class="btn" id="tocBtn" title="Table of contents" aria-label="Table of contents">📑 TOC</button>
  <button class="btn" id="overlayBtn" title="Toggle title/subtitle overlay" aria-label="Overlay">🏷️ Title</button>
        <button class="btn" id="bgBtn" title="Toggle Background" aria-label="Background">🌌 Background</button>
        <button class="btn" id="notesBtn" aria-label="Notes">📝 Notes</button>
        <button class="btn" id="fsBtn" title="Toggle Fullscreen" aria-label="Fullscreen">⛶ Fullscreen</button>
        <button class="btn" onclick="window.print()" aria-label="Print to PDF">📄 PDF</button>
        <button class="btn" id="drawerBtn" title="Slide thumbnails" aria-label="Slide thumbnails">🧭 Slides</button>
      </div>
    </div>

    <main class="slides" id="slides" role="region" aria-live="polite" aria-label="Slide 1 of N"></main>
    <footer class="deck-footer">
      <div><button class="btn" id="btnPrev" aria-label="Previous slide">◀</button><button class="btn" id="btnNext" aria-label="Next slide">▶</button></div>
      <div class="progress"><span id="progress"></span></div>
      <div id="slideNo">0/0</div>
    </footer>
    <div class="notes" id="notes"></div>
    <!-- Toast notification -->
    <div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true"></div>
  </div>

  <!-- Style Config Modal -->
  <div id="cfgOverlay"></div>
  <div id="cfgModal" role="dialog" aria-modal="true" aria-labelledby="cfgTitle">
    <header>
      <strong id="cfgTitle">Style Settings</strong>
      <button class="btn" id="cfgClose" aria-label="Close">✕</button>
    </header>
    <main>
      <label for="cfgName">App name</label>
      <input id="cfgName" type="text" placeholder="SlideApp" />
      <label>Presets</label>
      <div id="presetRow" class="row" style="margin-bottom:6px"></div>
      <div class="row">
        <div style="flex:1">
          <label for="cfgPrimary">Primary color</label>
          <input id="cfgPrimary" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgAccent">Accent color</label>
          <input id="cfgAccent" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <div style="flex:1">
          <label for="cfgTextColor">General text color</label>
          <input id="cfgTextColor" type="color" />
        </div>
        <div style="flex:1">
          <label>Button text color</label>
          <div class="row" style="gap:6px; align-items:center;">
            <select id="cfgBtnTextMode" class="btn" style="padding:6px 8px; min-width:96px;">
              <option value="auto">Auto</option>
              <option value="custom">Custom</option>
            </select>
            <input id="cfgBtnTextColor" type="color" />
          </div>
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <div style="flex:1">
          <label for="cfgBtnFill">Button fill</label>
          <select id="cfgBtnFill" class="btn" style="padding:6px 8px; min-width:120px;">
            <option value="solid">Solid</option>
            <option value="outline">Outline</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:8px; gap:8px;">
        <div style="flex:1">
          <label for="cfgAppBg1">App background start</label>
          <input id="cfgAppBg1" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgAppBg2">App background end</label>
          <input id="cfgAppBg2" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:8px; gap:8px;">
        <div style="flex:1">
          <label for="cfgSlideBg1">Slide background start</label>
          <input id="cfgSlideBg1" type="color" />
        </div>
        <div style="flex:1">
          <label for="cfgSlideBg2">Slide background end</label>
          <input id="cfgSlideBg2" type="color" />
        </div>
      </div>
      <div class="row" style="margin-top:8px; align-items: flex-end; gap: 10px;">
        <div style="flex:1">
          <label for="cfgSlideOpacity">Slide background opacity <span id="cfgSlideOpacityVal" aria-hidden="true"></span></label>
          <input id="cfgSlideOpacity" type="range" min="0" max="100" step="1" />
        </div>
        <div>
          <button class="btn" id="btnClearOpacity" title="Make background fully transparent">Clear</button>
        </div>
      </div>

      <label style="margin-top:10px">Config (external)</label>
      <div class="row" style="gap:8px; align-items:center; flex-wrap:nowrap; overflow-x:auto;">
        <div style="flex:0 0 auto;">
          <label for="cfgConfigUrl" style="display:block; font-size:12px;">Load from URL</label>
          <input id="cfgConfigUrl" type="text" placeholder="https://example.com/slideapp-config.json" style="width:360px; max-width:60vw;" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgLoadUrl">Load</button>
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgImportBtn">Import JSON</button>
          <input id="cfgImportFile" type="file" accept="application/json,.json" style="display:none" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn" id="cfgExport">Export</button>
        </div>
      </div>
      <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
          <input id="cfgPersistConfig" type="checkbox" /> Persist config to this browser
        </label>
        <span style="font-size:12px; opacity:.85;">When off, changes apply for this session only.</span>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:center; flex-wrap: wrap;">
    <label style="margin:0; font-size:12px;">UI visibility when OFF</label>
        <div style="display:flex; gap:10px; align-items:center;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgHideSlidesWithUi" type="checkbox" /> Hide slides panel
          </label>
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgHideProgressWithUi" type="checkbox" /> Hide progress bar
          </label>
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgSlideOutline" type="checkbox" /> Slide outline
          </label>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:center; flex-wrap: wrap;">
        <div style="flex:1">
          <label for="cfgOutlineWidth">Outline width <span id="cfgOutlineWidthVal" aria-hidden="true"></span></label>
          <input id="cfgOutlineWidth" type="range" min="0" max="8" step="1" />
        </div>
        <div style="flex:1">
          <label style="display:block; font-size:12px;">Deck restore</label>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
            <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
              <input id="cfgRememberDeck" type="checkbox" /> Remember last deck (persist)
            </label>
            <button class="btn" id="cfgForgetDeck" title="Forget stored deck">Forget deck</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-end; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgOverlayTitleOn" type="checkbox" /> Show slide title (overlay)
          </label>
          <div style="display:flex; gap:6px; align-items:center; margin-top:6px; flex-wrap: wrap;">
            <label style="font-size:12px;">Position</label>
            <span id="cfgOverlayPosHint" style="display:none; font-size:12px; opacity:.8;">Enable overlay to change</span>
            <div id="cfgOverlayPos" role="group" aria-label="Title position" style="display:flex; gap:6px;">
              <button type="button" class="btn" data-pos="tl">TL</button>
              <button type="button" class="btn" data-pos="tr">TR</button>
              <button type="button" class="btn" data-pos="bl">BL</button>
              <button type="button" class="btn" data-pos="br">BR</button>
            </div>
          </div>
          <label for="cfgTitleSize">Title size <span id="cfgTitleSizeVal" aria-hidden="true"></span></label>
          <input id="cfgTitleSize" type="range" min="12" max="64" step="1" />
        </div>
        <div style="flex:1; min-width:210px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
            <input id="cfgOverlaySubtitleOn" type="checkbox" /> Show subtitle (if present)
          </label>
          <label for="cfgSubtitleSize">Subtitle size <span id="cfgSubtitleSizeVal" aria-hidden="true"></span></label>
          <input id="cfgSubtitleSize" type="range" min="10" max="48" step="1" />
          <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
            <label style="font-size:12px;">Subtitle color</label>
            <select id="cfgSubtitleColor" class="btn" style="padding:6px 8px;">
              <option value="primary">Primary</option>
              <option value="accent">Accent</option>
            </select>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-start; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label style="display:block; font-size:12px;">Content position</label>
          <div id="cfgContentPos" role="group" aria-label="Content position" style="display:grid; grid-template-columns: repeat(3, auto); gap:6px; width:max-content;">
            <button type="button" class="btn" data-pos="tl">TL</button>
            <button type="button" class="btn" data-pos="tm">TM</button>
            <button type="button" class="btn" data-pos="tr">TR</button>
            <button type="button" class="btn" data-pos="ml">ML</button>
            <button type="button" class="btn" data-pos="mm">MM</button>
            <button type="button" class="btn" data-pos="mr">MR</button>
            <button type="button" class="btn" data-pos="bl">BL</button>
            <button type="button" class="btn" data-pos="bm">BM</button>
            <button type="button" class="btn" data-pos="br">BR</button>
          </div>
          <span style="display:block; font-size:12px; opacity:.8; margin-top:4px;">Affects Markdown block position inside the slide.</span>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap: 12px; align-items:flex-start; flex-wrap: wrap;">
        <div style="flex:1; min-width:210px;">
          <label for="cfgFontPrimary">Primary font (headings/title)</label>
          <input id="cfgFontPrimary" type="text" placeholder="Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif" />
        </div>
        <div style="flex:1; min-width:210px;">
          <label for="cfgFontSecondary">Secondary font (body/subtitle)</label>
          <input id="cfgFontSecondary" type="text" placeholder="Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif" />
        </div>
      </div>
    </main>
    <footer>
      <button class="btn" id="cfgReset" title="Reset to defaults">↺ Reset</button>
      <button class="btn" id="cfgSave">Save</button>
    </footer>
  </div>
  <!-- Validation modal -->
  <div id="valOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:30"></div>
  <div id="valModal" role="dialog" aria-modal="true" aria-labelledby="valTitle" style="position:fixed;top:40px;bottom:40px;left:40px;right:40px;width:auto;max-width:none;background:linear-gradient(135deg,var(--app-bg1, #0b1220),var(--app-bg2, #0f172a));color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31;flex-direction:column">
    <header style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);flex:0 0 auto">
      <h3 id="valTitle" style="margin:0;font-weight:600">Deck Validation</h3>
      <button class="btn" id="valClose">Close</button>
    </header>
    <main id="valBody" style="padding:14px;overflow:auto;flex:1 1 auto;font-size:14px;line-height:1.4"></main>
    <footer style="display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);flex:0 0 auto;background:linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));backdrop-filter:blur(4px)">
      <button class="btn" id="valOk">OK</button>
    </footer>
  </div>
  <div id="tocOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);display:none;z-index:30"></div>
  <div id="tocModal" role="dialog" aria-modal="true" aria-labelledby="tocTitle" style="position:fixed;top:40px;bottom:40px;left:40px;right:40px;width:auto;max-width:none;background:linear-gradient(135deg,var(--app-bg1, #0b1220),var(--app-bg2, #0f172a));color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;box-shadow:var(--shadow);display:none;z-index:31;flex-direction:column">
    <header style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);flex:0 0 auto">
      <h3 id="tocTitle" style="margin:0;font-weight:600">Table of Contents</h3>
      <button class="btn" id="tocClose">Close</button>
    </header>
    <main id="tocBody" style="padding:14px;overflow:auto;flex:1 1 auto;font-size:14px;line-height:1.4"></main>
    <footer style="display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);flex:0 0 auto;background:linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));backdrop-filter:blur(4px)">
      <button class="btn" id="tocOk">OK</button>
    </footer>
  </div>

  <script>
  const DEBUG=false; const dlog=(...a)=>{ if(DEBUG) console.log(...a); };

  // ===== UI elements =====
  const slidesRoot=document.getElementById('slides');
  const thumbsRoot=document.getElementById('thumbs');
  const notesEl=document.getElementById('notes');
  const appNameEl=document.getElementById('appName');
  const drawerBtn=document.getElementById('drawerBtn');
  const scrimEl=document.getElementById('scrim');

  // ===== Background (particles/gradient/off) =====
  const bgCanvas=document.getElementById('bg-canvas'); const ctx = bgCanvas.getContext('2d');
  let bgMode = localStorage.getItem('bgMode')||'gradient';
  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  // Particle runtime now lives in src/runtime/particles.js and is exposed via window.Particles.
  // Legacy in-file particle state removed to avoid duplication; runtime manages its own state.

  // Helper to rebuild overlays on all current slides using CONFIG and per-slide frontmatter
  function rebuildOverlays(tempPos){
    try{
      const slides = [...document.querySelectorAll('.slide')];
        slides.forEach(s => { s.querySelector('.slide-overlay')?.remove(); });
      if(CONFIG.overlayOn===true && Array.isArray(slidesHTML) && slidesHTML.length){
          slides.forEach((slideEl, idx) => {
          const fm = slidesHTML[idx]?.fm || {};
          const slideOverlayFlag = (typeof fm.overlay !== 'undefined') ? /^(1|on|true)$/i.test(String(fm.overlay).trim()) : true;
          if(!slideOverlayFlag) return;
          const pos = (fm.overlaypos || tempPos || CONFIG.overlayPos || 'tl').toString().toLowerCase();
          const tSize = isFinite(Number(fm.titlesize)) ? Math.max(12, Math.min(64, Math.round(Number(fm.titlesize)))) : CONFIG.overlayTitleSize;
          const sSize = isFinite(Number(fm.subtitlesize)) ? Math.max(10, Math.min(48, Math.round(Number(fm.subtitlesize)))) : CONFIG.overlaySubtitleSize;
          const titleTxt = (fm.title||'').toString().trim() || `Slide ${idx+1}`;
          const subtitleTxt = (fm.subtitle||'').toString().trim();
          const wrap = document.createElement('div');
          wrap.className = `slide-overlay pos-${pos}`;
          if(tSize) wrap.style.setProperty('--title-size', `${tSize}px`);
          if(sSize) wrap.style.setProperty('--subtitle-size', `${sSize}px`);
          const tEl = document.createElement('div'); tEl.className='slide-title'; tEl.textContent = titleTxt; wrap.appendChild(tEl);
            if(CONFIG.overlaySubtitleOn===true && subtitleTxt){ const sEl=document.createElement('div'); sEl.className='slide-subtitle'; sEl.textContent=subtitleTxt; if((CONFIG.overlaySubtitleColor||'primary')==='accent'){ sEl.classList.add('accent-subtitle'); } wrap.appendChild(sEl);} 
          wrap.setAttribute('aria-hidden','true');
          slideEl.appendChild(wrap);
        });
      }
    }catch{}
  }

  // Particle lifecycle is implemented in `src/runtime/particles.js` and exposed via window.Particles
  // Delegate resize handling to the runtime; runtime is expected to manage canvas sizing.
  function resizeCanvas(){ try{ if(window && window.Particles && typeof window.Particles.resize === 'function') window.Particles.resize(); }catch{}
  }
  function setBgButtonLabel(){ document.getElementById('bgBtn').textContent = (bgMode==='gradient'?'🌌 Background':bgMode==='particles'?'✨ Particles':'⛔ Background Off'); }
  function setBackgroundMode(mode){
    bgMode = mode;
    localStorage.setItem('bgMode', bgMode);
    setBgButtonLabel();
    if (bgMode === 'off'){
      try{ if(window && window.Particles && typeof window.Particles.stop === 'function') window.Particles.stop(); }catch{}
      bgCanvas.style.display = 'none';
      document.querySelector('.bg-gradient').style.display = 'none';
    } else if (bgMode === 'gradient'){
      try{ if(window && window.Particles && typeof window.Particles.stop === 'function') window.Particles.stop(); }catch{}
      bgCanvas.style.display = 'none';
      document.querySelector('.bg-gradient').style.display = 'block';
    } else {
      document.querySelector('.bg-gradient').style.display = 'none';
      bgCanvas.style.display = 'block';
      try{ if(window && window.Particles && typeof window.Particles.start === 'function') window.Particles.start({ prefersReduced: (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) }); }catch{}
    }
  }
  const cycleBackground=()=>{ const order=['gradient','particles','off']; setBackgroundMode(order[(order.indexOf(bgMode)+1)%order.length]); try{ showToast(`Background: ${bgMode}`);}catch{} };
  let resizeTimer=null; window.addEventListener('resize',()=>{ if(bgMode!=='particles') return; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ try{ if(window && window.Particles && typeof window.Particles.resize === 'function') window.Particles.resize(); }catch{} },120); });

  // ===== Config & Theme =====
  const CONFIG = JSON.parse(localStorage.getItem('slideapp.config')||'{}');
  // Whether to persist config changes to localStorage (default: true for backward-compat)
  let PERSIST_CONFIG = (()=>{ try{ const v = localStorage.getItem('slideapp.config.persist'); if(v===null) return true; return v==='1' || String(v).toLowerCase()==='true'; }catch{} return true; })();
  // Baseline opacity for T-key toggle: use last saved value from persisted config; fallback to 1 (100%).
  let BASE_OPACITY = (()=>{ try{ const saved=JSON.parse(localStorage.getItem('slideapp.config')||'{}'); const v=saved && typeof saved.slideOpacity==='number' ? saved.slideOpacity : undefined; if(typeof v==='number' && isFinite(v)) return Math.max(0, Math.min(1, v)); }catch{} return 1; })();
  // Back-compat: migrate legacy brand -> appName if needed (do not delete brand to avoid breaking older versions)
  if(typeof CONFIG.appName !== 'string' && typeof CONFIG.brand === 'string'){
    CONFIG.appName = CONFIG.brand;
  }
  const PRESETS=[
  // Default preset (used when no saved config exists)
  {name:'Default', primary:'#01B4E1', accent:'#64FFFC', textColor:'#e2e8f0', group:'default', appBg1:'#0f172a', appBg2:'#1e293b', slideBg1:'#111827', slideBg2:'#111827'},
  // Dark presets (order shown in modal)
  {name:'Dark 1', primary:'#01B4E1', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#0f1723', appBg2:'#111827', slideBg1:'#111827', slideBg2:'#111827'},
  {name:'Dark 2', primary:'#232337', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#0b1220', appBg2:'#111827', slideBg1:'#0f1723', slideBg2:'#111827'},
  {name:'Dark 3', primary:'#01B4E1', accent:'#64FFFC', textColor:'#ffffff', group:'dark', appBg1:'#000000', appBg2:'#0b0b0b', slideBg1:'#000000', slideBg2:'#0b0b0b'},
  // Light presets
  {name:'Light 1', primary:'#086384', accent:'#64FFFC', textColor:'#0b1220', group:'light', appBg1:'#f8fafc', appBg2:'#eef2ff', slideBg1:'#ffffff', slideBg2:'#f8fafc'},
  {name:'Light 2', primary:'#50677B', accent:'#01B4E1', textColor:'#0b1220', group:'light', appBg1:'#f8fafc', appBg2:'#ffffff', slideBg1:'#ffffff', slideBg2:'#f7fbff'},
  {name:'Light 3', primary:'#01B4E1', accent:'#50677B', textColor:'#0b1220', group:'light', appBg1:'#ffffff', appBg2:'#ffffff', slideBg1:'#ffffff', slideBg2:'#ffffff'}
  ];

  // If no theme values in saved CONFIG, apply the Default preset (non-persistent) so the UI shows a consistent base
  (function applyDefaultIfMissing(){
    try{
      const hasAny = (typeof CONFIG.primary === 'string' && CONFIG.primary.trim()) || (typeof CONFIG.accent === 'string' && CONFIG.accent.trim()) || (typeof CONFIG.appBg1 === 'string' && CONFIG.appBg1.trim()) || (typeof CONFIG.textColor === 'string' && CONFIG.textColor.trim());
      if(!hasAny){
        const def = PRESETS.find(p=>p.name==='Default');
        if(def){
          CONFIG.primary = def.primary; CONFIG.accent = def.accent; CONFIG.textColor = def.textColor; CONFIG.appBg1 = def.appBg1; CONFIG.appBg2 = def.appBg2; CONFIG.slideBg1 = def.slideBg1; CONFIG.slideBg2 = def.slideBg2;
        }
      }
    }catch(e){}
  })();
  // Default outline setting: on when not present
  if(typeof CONFIG.slideBorderOn !== 'boolean') CONFIG.slideBorderOn = true;
  // Default outline width (px)
  if(typeof CONFIG.slideBorderWidth !== 'number') CONFIG.slideBorderWidth = 3;
  // Overlay & typography defaults (with migration from previous keys)
  if(typeof CONFIG.overlayOn !== 'boolean'){
    if(typeof CONFIG.overlayTitleOn === 'boolean') CONFIG.overlayOn = CONFIG.overlayTitleOn; else CONFIG.overlayOn = false;
  }
  if(typeof CONFIG.overlayPos !== 'string'){
    if(typeof CONFIG.overlayTitlePos === 'string') CONFIG.overlayPos = CONFIG.overlayTitlePos; else CONFIG.overlayPos = 'tl';
  }
  if(typeof CONFIG.overlayTitleSize !== 'number') CONFIG.overlayTitleSize = (typeof CONFIG.overlayTitleSize==='number'?CONFIG.overlayTitleSize:22);
  if(typeof CONFIG.overlaySubtitleOn !== 'boolean') CONFIG.overlaySubtitleOn = (typeof CONFIG.overlaySubtitleOn==='boolean'?CONFIG.overlaySubtitleOn:true);
  if(typeof CONFIG.overlaySubtitleSize !== 'number') CONFIG.overlaySubtitleSize = (typeof CONFIG.overlaySubtitleSize==='number'?CONFIG.overlaySubtitleSize:16);
  // Subtitle color option: 'primary' | 'accent'
  if(typeof CONFIG.overlaySubtitleColor !== 'string') CONFIG.overlaySubtitleColor = 'primary';
  // Clean legacy keys
  delete CONFIG.overlayTitleOn; delete CONFIG.overlayTitlePos;
  if(typeof CONFIG.fontPrimary !== 'string') CONFIG.fontPrimary = 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
  // Content position default
  if(typeof CONFIG.contentPos !== 'string') CONFIG.contentPos = 'tl';

  // ---- External config: schema, validation, merge, persistence ----
  const CONFIG_KEYS = new Set([
    'appName','brand','primary','accent','textColor','btnTextColor','btnFill',
    'appBg1','appBg2','slideBg1','slideBg2','slideOpacity',
    'slideBorderOn','slideBorderWidth',
    'overlayOn','overlayPos','overlayTitleSize','overlaySubtitleOn','overlaySubtitleSize','overlaySubtitleColor',
    'fontPrimary','fontSecondary',
    'rememberLastDeck','hideSlidesWithUi','hideProgressWithUi','contentPos'
  ]);

  function sanitizeConfig(input){
    const out={}; if(!input || typeof input!=='object') return out;
    const assignHex=(k)=>{ const n=normalizeHex(input[k]); if(n) out[k]=n; };
    const assignBool=(k)=>{ const v=input[k]; if(typeof v==='boolean') out[k]=v; };
    const assignNum=(k,{min,max}={})=>{ const v=Number(input[k]); if(isFinite(v)){ let n=v; if(typeof min==='number') n=Math.max(min,n); if(typeof max==='number') n=Math.min(max,n); out[k]=n; }};
    const assignStr=(k)=>{ const v=input[k]; if(typeof v==='string' && v.trim()!=='') out[k]=v.trim(); };
    // strings
    ['appName','brand','overlayPos','fontPrimary','fontSecondary'].forEach(assignStr);
    // hex colors (special-case btnTextColor: allow 'auto')
    ['primary','accent','textColor','appBg1','appBg2','slideBg1','slideBg2'].forEach(assignHex);
    if(typeof input.btnTextColor==='string'){
      const v = input.btnTextColor.trim();
      if(/^auto$/i.test(v)) out.btnTextColor = 'auto'; else { const n = normalizeHex(v); if(n) out.btnTextColor = n; }
    }
    // numbers
    assignNum('slideOpacity',{min:0,max:1});
    assignNum('slideBorderWidth',{min:0,max:8});
    assignNum('overlayTitleSize',{min:12,max:64});
    assignNum('overlaySubtitleSize',{min:10,max:48});
    // booleans
    ['slideBorderOn','overlayOn','overlaySubtitleOn','rememberLastDeck','hideSlidesWithUi','hideProgressWithUi'].forEach(assignBool);
    // enum
    if(typeof input.overlaySubtitleColor==='string' && /^(primary|accent)$/i.test(input.overlaySubtitleColor)) out.overlaySubtitleColor = input.overlaySubtitleColor.toLowerCase();
    if(typeof input.contentPos==='string' && /^(t[mlr]|m[mlr]|b[mlr])$/i.test(input.contentPos)) out.contentPos = input.contentPos.toLowerCase();
    if(typeof input.btnFill==='string' && /^(solid|outline)$/i.test(input.btnFill)) out.btnFill = input.btnFill.toLowerCase();
    return out;
  }

  function mergeConfig(incoming, mode){
    const safe = sanitizeConfig(incoming);
    if(mode==='replace'){
      for(const k of Array.from(CONFIG_KEYS)) delete CONFIG[k];
    }
    Object.assign(CONFIG, safe);
    try{ if(window.Theme && typeof window.Theme.applyConfig==='function'){ window.Theme.applyConfig(CONFIG); } else { applyConfig(); } }catch{}
    return safe;
  }

  async function loadConfigFromUrl(url){
    try{
      const res = await fetch(url, { credentials: 'omit' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      const applied = mergeConfig(data, 'merge');
      if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} }
      try{ showToast('Config loaded'); }catch{}
      return applied;
    }catch(err){ try{ showToast('Failed to load config'); }catch{} console.error('Config load failed', err); return {}; }
  }

  function exportConfigBlob(){
    const data = sanitizeConfig(CONFIG);
    const blob = new Blob([JSON.stringify(data,null,2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='slideapp-config.json'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250);
  }

  // postMessage API: { type:'slider.config', action:'set|merge|replace', config:{...} }
  window.addEventListener('message', (ev)=>{
    try{
      const msg = ev.data || {};
      if(!msg || msg.type!=='slider.config') return;
      const action = (msg.action||'merge').toLowerCase();
      const cfg = msg.config || {};
      const mode = (action==='replace' || (action==='set' && msg.mode==='replace')) ? 'replace' : 'merge';
      const applied = mergeConfig(cfg, mode);
      if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} }
      ev.source && ev.source.postMessage && ev.source.postMessage({ type:'slider.config.result', ok:true, applied }, '*');
    }catch(e){ try{ ev.source && ev.source.postMessage && ev.source.postMessage({ type:'slider.config.result', ok:false, error:String(e&&e.message||e) }, '*'); }catch{} }
  });
  if(typeof CONFIG.fontSecondary !== 'string') CONFIG.fontSecondary = 'Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  // Opacity control: 100 equals default look (0.75/0.55); 0 is fully transparent
  function setSlideOpacity(val, persist = true){
    let v = Number(val);
    if(!isFinite(v)) v = 100;
  // Normalize to integer percent first to avoid float drift when values come from saved decimal * 100
  v = Math.round(Math.max(0, Math.min(100, v)));
  const dec = v / 100;
    const base1 = 0.75, base2 = 0.55;
  const o1 = (base1 * dec).toFixed(3);
  const o2 = (base2 * dec).toFixed(3);
    
  // Set the CSS variables that are used in the .slide background
    // Prefer configured slideBg colors if present (stored as #rrggbb)
    try{
      // Prefer runtime computation for derived slide background vars when available
      if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
        try{
          const outcome = window.Theme.computeApplyConfigOutcome({ slideBg1: CONFIG.slideBg1, slideBg2: CONFIG.slideBg2, slideOpacity: dec });
          if(outcome && outcome.cssVars){
            if(typeof outcome.cssVars['--slide-bg1'] === 'string') document.documentElement.style.setProperty('--slide-bg1', outcome.cssVars['--slide-bg1']);
            if(typeof outcome.cssVars['--slide-bg2'] === 'string') document.documentElement.style.setProperty('--slide-bg2', outcome.cssVars['--slide-bg2']);
          }
        }catch(err){
          // fall back to legacy local computation below
          const s1 = (typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) ? normalizeHex(CONFIG.slideBg1) : null;
          const s2 = (typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) ? normalizeHex(CONFIG.slideBg2) : null;
          if(s1){ const c = hexToRgb(s1); if(c) document.documentElement.style.setProperty('--slide-bg1', `rgba(${c.r},${c.g},${c.b},${o1})`); else document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); } else { document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); }
          if(s2){ const c = hexToRgb(s2); if(c) document.documentElement.style.setProperty('--slide-bg2', `rgba(${c.r},${c.g},${c.b},${o2})`); else document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); } else { document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
        }
      } else {
        const s1 = (typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) ? normalizeHex(CONFIG.slideBg1) : null;
        const s2 = (typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) ? normalizeHex(CONFIG.slideBg2) : null;
        if(s1){ const c = hexToRgb(s1); if(c) document.documentElement.style.setProperty('--slide-bg1', `rgba(${c.r},${c.g},${c.b},${o1})`); else document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); } else { document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); }
        if(s2){ const c = hexToRgb(s2); if(c) document.documentElement.style.setProperty('--slide-bg2', `rgba(${c.r},${c.g},${c.b},${o2})`); else document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); } else { document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
      }
    }catch(e){ document.documentElement.style.setProperty('--slide-bg1', `rgba(17,24,39,${o1})`); document.documentElement.style.setProperty('--slide-bg2', `rgba(17,24,39,${o2})`); }
  // Also scale blur and shadow so 0% is truly clear
  const blurPx = (8 * dec).toFixed(2) + 'px';
  // scale the alpha of the existing shadow; base shadow is rgba(0,0,0,0.25)
  const shadowAlpha = (0.25 * dec).toFixed(3);
  const shadow = `0 10px 30px rgba(0,0,0,${shadowAlpha})`;
  document.documentElement.style.setProperty('--slide-blur', blurPx);
  document.documentElement.style.setProperty('--slide-shadow', shadow);
    
    // persist in CONFIG unless caller asked not to
    if(persist !== false){ CONFIG.slideOpacity = dec; }
  return dec;
  }
  window.setSlideOpacity = setSlideOpacity;

  // Helper: normalize hex string to #rrggbb or empty string
  function normalizeHex(input){
    try{
      if(!input) return '';
      let s = String(input).trim().replace(/['"]/g,'');
      if(!s) return '';
      if(!s.startsWith('#')) s = '#'+s;
      const m = s.slice(1);
      if(/^[0-9a-f]{3}$/i.test(m)) return '#'+m.split('').map(c=>c+c).join('').toLowerCase();
      if(/^[0-9a-f]{6}$/i.test(m)) return '#'+m.toLowerCase();
    }catch{}
    return '';
  }

  function hexToRgb(hex){
    try{
      const h = normalizeHex(hex);
      if(!h) return null;
      const v = h.slice(1);
      return { r: parseInt(v.slice(0,2),16), g: parseInt(v.slice(2,4),16), b: parseInt(v.slice(4,6),16) };
    }catch{ return null; }
  }

  // Return '#000000' or '#ffffff' for best contrast against the provided hex color.
  function bestContrastForHex(hex){
    try{
      const rgb = hexToRgb(hex);
      if(!rgb) return '#000000';
      // Relative luminance (sRGB)
      const srgb = [rgb.r, rgb.g, rgb.b].map(c=>{
        const s = c/255;
        return s <= 0.03928 ? s/12.92 : Math.pow((s+0.055)/1.055, 2.4);
      });
      const L = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
      // Use white for dark backgrounds (low L), black for light backgrounds
      return (L < 0.5) ? '#ffffff' : '#000000';
    }catch(e){ return '#000000'; }
  }

  // Thumbnails are styled via CSS variables; no JS inline styling required.

  function applyConfig(){
    // Prefer runtime Theme helper to compute and apply vars when available.
    // Call the runtime shim early; existing inline logic remains as a safe fallback
    // (idempotent) until parity is proven.
    try{
      if(window.Theme && typeof window.Theme.applyConfig === 'function'){
        try{
          // Capture outcome to help debug overwrite issues where the runtime
          // compute returns a value but the page-level apply path later
          // ends up with a different CSS var in the DOM.
          const __theme_outcome = window.Theme.applyConfig(CONFIG);
          try{
            const __computed_text = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
            // (debug instrumentation removed) capture remained for historical debugging but not exposed in CI
          }catch(logErr){ console.log('[THEME_DEBUG] applyConfig logging failed', String(logErr)); }
        }catch(e){}
      }
    }catch(e){}

    // Prefer runtime Theme helper to compute vars consistently when available
    let primaryVal, accentVal, textVal, btnTextVal;
    try{
      if(window.Theme && typeof window.Theme.computeThemeCssVars === 'function'){
        const vars = window.Theme.computeThemeCssVars({
          primary: CONFIG.primary,
          accent: CONFIG.accent,
          textColor: CONFIG.textColor,
          btnTextColor: CONFIG.btnTextColor,
          slideOpacity: CONFIG.slideOpacity
        }) || {};
        primaryVal = CONFIG.primary || vars['--primary'] || getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        accentVal  = CONFIG.accent  || vars['--accent']  || getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
        textVal    = CONFIG.textColor || vars['--text'] || getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        btnTextVal = CONFIG.btnTextColor || vars['--btn-text'] || textVal;
      }
    }catch{}
  if(!primaryVal){ primaryVal = CONFIG.primary||getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(); }
  if(!accentVal){  accentVal  = CONFIG.accent ||getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(); }
  // Theme.applyConfig handles derived CSS variables (btn-bg, btn-text, --text, etc.).
  // Ensure brand-badge reflects computed vars (no inline CSS set here).
  try{ const bb = document.querySelector('.brand-badge'); if(bb) bb.style.removeProperty('background'); }catch(e){}
    // No-op: if runtime Theme helper exists, exercise it without modifying behavior
    try{ if(window.Theme && typeof window.Theme.computeThemeCssVars === 'function'){ window.Theme.computeThemeCssVars({
      primary: CONFIG.primary, accent: CONFIG.accent, textColor: CONFIG.textColor, btnTextColor: CONFIG.btnTextColor, slideOpacity: CONFIG.slideOpacity
    }); } }catch{}
  appNameEl.textContent = (CONFIG.appName||CONFIG.brand||'SlideApp');
  // Keep document.title in sync; deck name takes precedence when present
  try{
    const deckNm = (window.__deckAppName && String(window.__deckAppName).trim()) || '';
    const cfgNm = (CONFIG.appName||CONFIG.brand||'SlideApp');
    document.title = (deckNm || cfgNm || 'SlideApp').toString();
  }catch{}
  // Apply app background colors and effect color if configured
    try{
  // Theme.applyConfig will set app background/effect/text CSS vars.
    }catch{}
    // Refresh bg-gradient visibility to reflect current bgMode preference
  try{ if(bgMode === 'gradient'){ document.querySelector('.bg-gradient').style.display = 'block'; bgCanvas.style.display='none'; } else if(bgMode === 'particles'){ document.querySelector('.bg-gradient').style.display='none'; bgCanvas.style.display='block'; if(window && window.Particles && typeof window.Particles.start === 'function') window.Particles.start({ prefersReduced }); } else { document.querySelector('.bg-gradient').style.display='none'; bgCanvas.style.display='none'; } }catch{}
    // If slide background colors changed, update computed slide CSS vars immediately
    try{
      // If CONFIG.slideBg1/2 are set, prefer runtime helper to compute rgba with current opacity; fall back to direct hex assignment
      try{
        if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
          const outcome = window.Theme.computeApplyConfigOutcome({ slideBg1: CONFIG.slideBg1, slideBg2: CONFIG.slideBg2, slideOpacity: CONFIG.slideOpacity });
          if(outcome && outcome.cssVars){
            if(typeof outcome.cssVars['--slide-bg1'] === 'string') document.documentElement.style.setProperty('--slide-bg1', outcome.cssVars['--slide-bg1']);
            else if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim());
            if(typeof outcome.cssVars['--slide-bg2'] === 'string') document.documentElement.style.setProperty('--slide-bg2', outcome.cssVars['--slide-bg2']);
            else if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim());
          }
        } else {
          if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()){
            document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim());
          }
          if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()){
            document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim());
          }
        }
      }catch(e){ if(typeof CONFIG.slideBg1 === 'string' && CONFIG.slideBg1.trim()) document.documentElement.style.setProperty('--slide-bg1', CONFIG.slideBg1.trim()); if(typeof CONFIG.slideBg2 === 'string' && CONFIG.slideBg2.trim()) document.documentElement.style.setProperty('--slide-bg2', CONFIG.slideBg2.trim()); }
    }catch{}
    // apply slide opacity if present; prefer runtime shim when available
    if(typeof CONFIG.slideOpacity === 'number'){
      try{
        if(window.Theme && typeof window.Theme.setSlideOpacity === 'function'){
          // Theme.setSlideOpacity accepts decimal 0..1 or percentage; pass decimal
          window.Theme.setSlideOpacity(CONFIG.slideOpacity);
        }else{
          // fallback: legacy call expects percent
          setSlideOpacity(CONFIG.slideOpacity * 100, false);
        }
      }catch(e){}
    }
  // Apply outline visibility
  document.body.classList.toggle('border-off', CONFIG.slideBorderOn===false);
  // Apply outline width, typography and overlay sizes via runtime helper when available.
  try{
    const partial = {
      slideBorderWidth: (typeof CONFIG.slideBorderWidth === 'number' && isFinite(CONFIG.slideBorderWidth)) ? Math.max(0, Math.min(20, Math.round(CONFIG.slideBorderWidth))) : 3,
      fontPrimary: CONFIG.fontPrimary || undefined,
      fontSecondary: CONFIG.fontSecondary || undefined,
      overlayTitleSize: (typeof CONFIG.overlayTitleSize === 'number') ? Math.max(12, Math.min(64, Math.round(CONFIG.overlayTitleSize))) : undefined,
      overlaySubtitleSize: (typeof CONFIG.overlaySubtitleSize === 'number') ? Math.max(10, Math.min(48, Math.round(CONFIG.overlaySubtitleSize))) : undefined
    };
    // Prefer runtime helper to apply outline/font/overlay sizes. If it throws, apply a minimal fallback
    try{
      if(window.Theme && typeof window.Theme.applyFontOutline === 'function'){
        window.Theme.applyFontOutline(partial);
      } else {
        // minimal fallback: apply outline width only
        const w = partial.slideBorderWidth;
        try{ document.documentElement.style.setProperty('--outline-w', `${w}px`); }catch{}
      }
    }catch(e){ try{ document.documentElement.style.setProperty('--outline-w', `${partial.slideBorderWidth}px`); }catch{} }
  }catch(e){
    // Best-effort fallback in case of errors
    try{ const w = (typeof CONFIG.slideBorderWidth === 'number' && isFinite(CONFIG.slideBorderWidth)) ? CONFIG.slideBorderWidth : 3; document.documentElement.style.setProperty('--outline-w', `${Math.max(0, Math.min(20, Math.round(w)))}px`); }catch{}
    try{ document.documentElement.style.setProperty('--font-primary', CONFIG.fontPrimary||'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'); }catch{}
    try{ document.documentElement.style.setProperty('--font-secondary', CONFIG.fontSecondary||'Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif'); }catch{}
    try{ const ts = Math.max(12, Math.min(64, Math.round(CONFIG.overlayTitleSize||22))); document.documentElement.style.setProperty('--title-size', `${ts}px`);}catch{}
    try{ const ss = Math.max(10, Math.min(48, Math.round(CONFIG.overlaySubtitleSize||16))); document.documentElement.style.setProperty('--subtitle-size', `${ss}px`);}catch{}
  }
  // Thumbnails are CSS-driven; no explicit JS refresh required here.
  // Ensure active thumbnail gradient reflects current theme in engines where computed style may not resolve CSS vars reliably
  try{ updateActiveThumbGradient(); }catch{}
  }
    // Also apply text color to specific UI elements (immediate effect)
  try{
    // Let CSS handle color via variables; ensure derived --muted exists for label contrast
    const currentText = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || getComputedStyle(document.documentElement).getPropertyValue('--text');
    try{
      // Prefer runtime computation for derived vars when available
      if(window.Theme && typeof window.Theme.computeApplyConfigOutcome === 'function'){
        try{
          const outcome = window.Theme.computeApplyConfigOutcome({ textColor: currentText });
          if(outcome && outcome.cssVars && typeof outcome.cssVars['--muted'] === 'string'){
            document.documentElement.style.setProperty('--muted', outcome.cssVars['--muted']);
          }
        }catch(e){ /* fallthrough to local computation below */ }
      } else {
        // compute a simple muted fallback based on luminance of --text when it's a hex; otherwise keep existing --muted
        const rgb = hexToRgb(currentText);
        if(rgb){
          const lin = (c)=>{ const s=c/255; return s<=0.03928? s/12.92 : Math.pow((s+0.055)/1.055, 2.4); };
          const L = 0.2126*lin(rgb.r) + 0.7152*lin(rgb.g) + 0.0722*lin(rgb.b);
          if(L > 0.5){ document.documentElement.style.setProperty('--muted', 'rgba(11,18,32,0.55)'); }
          else { document.documentElement.style.setProperty('--muted', 'rgba(255,255,255,0.55)'); }
        }
      }
    }catch(e){}
    // Clear inline colors so CSS variables control visuals; remove inline style.color where present
  [...document.querySelectorAll('.thumb, .deck-header .btn, .deck-footer .btn, #drawerBtn, #bgBtn, #notesBtn, #cfgModal .btn')].forEach(el=>{ el.style.removeProperty('color'); });
    // Ensure brand-badge text color follows vars
    try{ const bb=document.querySelector('.brand-badge'); if(bb) bb.style.removeProperty('color'); }catch{}
  }catch{}

  // ===== Markdown + Front-matter =====
  function parseFrontmatter(text){
      const fm={};
      const src = text.replace(/\r\n?/g,'\n');
      const trimmedStart = src.trimStart();
      // Only treat a leading --- block as frontmatter
      if(!trimmedStart.startsWith('---')) return { fm:{}, body: src.trim() };
      const lines = trimmedStart.split('\n');
      let endIndex=-1;
      for(let i=1;i<lines.length;i++){
        const rawLine = lines[i];
        const t = rawLine.trim();
        // Only treat a closing fence if it starts at the true line start (no leading indentation).
        // This prevents indented '---' inside a multiline frontmatter value (for example in notes)
        // from being interpreted as the end of the frontmatter block.
        if((rawLine.startsWith('---') || rawLine.startsWith('...')) && (t==='---' || t==='...')){ endIndex=i; break; }
      }
      if(endIndex<=0) return { fm:{}, body: src.trim() };
      // Parse key: value lines between the fences, allow leading spaces and continuations
      let key=null, val=[];
      for(let i=1;i<endIndex;i++){
        const raw=lines[i];
        const m = raw.match(/^\s*([^:\s][^:]*)\s*:\s*(.*)$/);
        if(m){
          // Commit previous key
          if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
          key = m[1].trim();
          val = [ (m[2]||'').trim() ];
        } else if(key){
          val.push(raw.trim());
        }
      }
      if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
      const body = lines.slice(endIndex+1).join('\n').trim();
      return { fm, body };
    }

  function escapeHtml(s){return s.replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));}

  function parseMarkdown(md, opts={allowColumns:true}){
      // Extract code fences into placeholders so inner backticks don't get processed
      // Support fences like ``` or ~~~ with optional language info; preserve leading newline
      const CODE_BLOCKS = [];
      md = md.replace(/(^|\n)(`{3,}|~{3,})([^\n]*)\n([\s\S]*?)\n\2(?:\n|$)/g, (m, pre, fence, info, code) => {
        const lang = (info||'').trim().split(/\s+/)[0];
        const cls = lang ? ` class="lang-${escapeHtml(lang)}"` : '';
        const html = `${pre}<pre><code${cls}>${escapeHtml(code)}</code></pre>`;
        const key = `@@CODE_BLOCK_${CODE_BLOCKS.length}@@`;
        CODE_BLOCKS.push(html);
        return key;
      });

      // Handle inline code (safe now that code fences are placeholders)
      md = md.replace(/`([^`]+)`/g, (m, code) => `<code>${escapeHtml(code)}</code>`);
      // Strikethrough
      md = md.replace(/~~([^~\n]+)~~/g, '<del>$1</del>');
      
      // Custom shortcodes (columns, admonitions)
      if(opts.allowColumns){
        const lines = md.split('\n');
        const out = [];
        for(let i = 0; i < lines.length; i++){
          const cur = lines[i].trim();
          if(/^:::\s*columns\b/i.test(cur)){
            const block = [];
            i++; // skip the :::columns line
            while(i < lines.length && lines[i].trim() !== ':::'){
              block.push(lines[i]);
              i++;
            }
            // Parse columns separated by :::col
            const cols = [];
            let buf = [];
            for(const ln of block){
              if(ln.trim().toLowerCase() === ':::col'){
                cols.push(buf.join('\n'));
                buf = [];
              } else {
                buf.push(ln);
              }
            }
            cols.push(buf.join('\n')); // last column
            const htmlCols = cols.map(c => `<div class="col">${parseMarkdown(c.trim(), {allowColumns:false})}</div>`).join('');
            out.push(`<div class="cols">${htmlCols}</div>`);
            continue;
          } else if(/^:::\s*(note|tip|warning)\b/i.test(cur)){
            const kind = cur.split(/\s+/)[1].toLowerCase();
            const block = [];
            i++;
            while(i < lines.length && lines[i].trim() !== ':::'){
              block.push(lines[i]);
              i++;
            }
            const inner = parseMarkdown(block.join('\n').trim(), {allowColumns:false});
            const title = kind.charAt(0).toUpperCase() + kind.slice(1);
            out.push(`<div class="admonition ${kind}"><div class="admonition-title">${title}</div><div class="admonition-body">${inner}</div></div>`);
            continue;
          }
          out.push(lines[i]);
        }
        md = out.join('\n');
      }
      
      // Handle headings with ids for anchors
      const slug = (s)=>s.toLowerCase().trim().replace(/<[^>]+>/g,'').replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-');
      md=md.replace(/^# (.*)$/gm,(m,t)=>`<h1 id="${slug(t)}">${t}</h1>`)
           .replace(/^## (.*)$/gm,(m,t)=>`<h2 id="${slug(t)}">${t}</h2>`)
           .replace(/^### (.*)$/gm,(m,t)=>`<h3 id="${slug(t)}">${t}</h3>`);
      
      // Handle blockquotes
      md = md.replace(/^> (.*)$/gm, '<blockquote>$1</blockquote>');
      
  // Handle images BEFORE links so the link regex doesn't consume image syntax
  md = md.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%;height:auto;border-radius:8px;margin:16px 0;">');

  // Handle links (after images)
  md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      
      // Handle tables (GFM style): header | separator | rows
      (function(){
        const lines = md.split('\n');
        const out = [];
        let i = 0;
        function splitRow(line){
          let s = line.trim();
          if(s.startsWith('|')) s = s.slice(1);
          if(s.endsWith('|')) s = s.slice(0, -1);
          return s.split('|').map(c => c.trim());
        }
        function isSep(line){
          let s = line.trim();
          if(s.startsWith('|')) s = s.slice(1);
          if(s.endsWith('|')) s = s.slice(0, -1);
          const parts = s.split('|').map(p => p.trim());
          return parts.length > 0 && parts.every(p => /^:?-{3,}:?$/.test(p));
        }
        function alignFrom(token){
          token = token.trim();
          const left = token.startsWith(':');
          const right = token.endsWith(':');
          if(left && right) return 'center';
          if(right) return 'right';
          return 'left';
        }
        while (i < lines.length) {
          const line = lines[i];
          const nextLine = lines[i+1];
          
          if (line && line.includes('|') && nextLine && isSep(nextLine)) {
            const headers = splitRow(line);
            const aligns = splitRow(nextLine).map(alignFrom);
            i += 2; // skip header and separator
            
            const rows = [];
            while (i < lines.length) {
              const row = lines[i];
              if (!row || !row.includes('|') || isSep(row)) break;
              rows.push(splitRow(row));
              i++;
            }
            
            const colCount = Math.max(headers.length, aligns.length, ...rows.map(r => r.length));
            const getAlign = (idx) => aligns[idx] || 'left';
            
            let html = '<table><thead><tr>';
            for (let c = 0; c < colCount; c++) {
              html += `<th style="text-align:${getAlign(c)}">${headers[c] || ''}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            for (const row of rows) {
              html += '<tr>';
              for (let c = 0; c < colCount; c++) {
                html += `<td style="text-align:${getAlign(c)}">${row[c] || ''}</td>`;
              }
              html += '</tr>';
            }
            html += '</tbody></table>';
            
            out.push(html);
            continue;
          }
          
          out.push(line);
          i++;
        }
        md = out.join('\n');
      })();
      
  // Handle lists (unordered and ordered)
      const lines = md.split('\n');
      let listType = null; // 'ul' | 'ol' | null
      const result = [];
      const ulRe = /^[\*\-]\s+(.+)$/;
      const olRe = /^\d+\.\s+(.+)$/;

      function open(type){ result.push(type==='ul' ? '<ul>' : '<ol>'); listType = type; }
      function close(){ if(listType){ result.push(listType==='ul' ? '</ul>' : '</ol>'); listType = null; } }

      for (let line of lines) {
        const ulMatch = line.match(ulRe);
        const olMatch = line.match(olRe);

        if (ulMatch) {
          if (listType !== 'ul') {
            close();
            open('ul');
          }
          const task = ulMatch[1].match(/^\[( |x|X)\]\s+(.*)$/);
          if(task){
            const checked = /x/i.test(task[1]);
            const txt = task[2];
            result.push(`<li class="task">${checked? '☑' : '☐'} ${txt}</li>`);
          } else {
            result.push(`<li>${ulMatch[1]}</li>`);
          }
          continue;
        }
        
        if (olMatch) {
          if (listType !== 'ol') {
            close();
            open('ol');
          }
          result.push(`<li>${olMatch[1]}</li>`);
          continue;
        }
        
        // Not a list item; close any open list before adding the line
        close();
        result.push(line);
      }
      close();
      md = result.join('\n');
      
      // Handle bold and italic
      md=md.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
      md=md.replace(/\*([^*\n]+)\*/g,'<em>$1</em>');
      
  // Handle paragraphs: split by double newlines, but avoid wrapping existing block elements
      md = md.split(/\n{2,}/).map(chunk => {
        const trimmed = chunk.trim();
        if (!trimmed) return '';

        // If this chunk is a code block placeholder (we stored them as @@CODE_BLOCK_n@@),
        // return it as-is so it remains a top-level block element and isn't wrapped in <p>.
        if (/^@@CODE_BLOCK_\d+@@$/.test(trimmed)) {
          return trimmed;
        }

        // Don't wrap block-level elements
        if (/^\s*<(h\d|ul|ol|pre|blockquote|p|table|div|img)/i.test(trimmed)) {
          return trimmed;
        }

        // Wrap in paragraph
        return `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
      }).join('\n');
  // Restore code blocks placeholders
  md = md.replace(/@@CODE_BLOCK_(\d+)@@/g, (m, idx) => CODE_BLOCKS[Number(idx)] || '');
      
      return md;
    }

  function splitSlides(md){
      // Normalize newlines and strip BOM
      md = md.replace(/\r\n?/g,'\n');
      if(md.startsWith('\uFEFF')) md = md.slice(1);
      // Extract deck-level frontmatter at file start and remove it from md
      let __deckFM = {};
      try{
        const lead = md.trimStart();
        if(lead.startsWith('---\n')){
          const m = lead.match(/^---\n([\s\S]*?)\n(---|\.\.\.)\s*(\n|$)/);
          if(m){
            const block = m[1] || '';
            const fm = {};
            let key=null, val=[];
            for(const raw of block.split('\n')){
              const mm = raw.match(/^\s*([^:\s][^:]*)\s*:\s*(.*)$/);
              if(mm){ if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); } key=mm[1].trim(); val=[(mm[2]||'').trim()]; }
              else if(key){ val.push(raw.trim()); }
            }
            if(key){ fm[key.toLowerCase()] = val.join(' ').trim(); }
            // Only treat as deck-level FM if it includes known deck keys; otherwise
            // leave content intact (e.g., when the leading block is just slide text like title/notes).
            const keys = Object.keys(fm).map(k=>k.toLowerCase());
            const hasKnown = keys.some(k => (
              k==='app-name' || k==='appname' || k==='brand' ||
              k==='primary' || k==='accent' || k==='textcolor' || k==='text-color' || k==='text' ||
              k==='theme-primary' || k==='theme-accent' || k==='theme-text' ||
              k==='background' || k==='effect-color' || k==='ui' ||
              k==='font-primary' || k==='font-secondary' ||
              k==='opacity' || k==='slideopacity' || k==='appbg1' || k==='app-bg1' || k==='appbg2' || k==='app-bg2' ||
              k.startsWith('defaults-')
            ));
            if(hasKnown){
              __deckFM = fm;
              md = lead.slice(m[0].length);
            }
          }
        }
      }catch{}
      const lines = md.split('\n');
      const slides=[];
      let buf=[];
      let atSlideStart=true; // true until a non-empty, non-whitespace line is seen in current slide
      let inFM=false; // inside frontmatter block at the start of the slide

      // Helper: line is just a row of 4+ hyphens (common for HR or separators in notes/messages)
      const isHr = (t)=>/^-{4,}$/.test(t);
      // Track fenced code blocks so we don't split on '---' inside them
      let inFence = false; // ``` or ~~~
      let fenceToken = '';
      function fenceToggles(t){
        const m = t.match(/^(```+|~~~+)/);
        if(!m) return false;
        const token = m[1].startsWith('`') ? '```' : '~~~';
        if(!inFence){ inFence=true; fenceToken=token; return true; }
        if(inFence && token===fenceToken){ inFence=false; fenceToken=''; return true; }
        return false;
      }
      // Track HTML comments and simple HTML blocks (<pre|code|script|style>) so --- inside
      // them doesn't act as a slide separator/frontmatter fence
      let inHtmlComment=false;
      let inHtmlBlock=false; // pre/code/script/style
      const htmlBlockStart=/^(<\s*(pre|code|script|style)\b)/i;
      const htmlBlockEnd=/<\s*\/\s*(pre|code|script|style)\s*>/i;
      function commentToggle(line){
        const hasOpen = line.includes('<!--');
        const hasClose = line.includes('-->');
        if(hasOpen && !hasClose){ inHtmlComment=true; return true; }
        if(hasClose && inHtmlComment){ inHtmlComment=false; return true; }
        return false;
      }
      function htmlBlockToggle(t){
        if(htmlBlockStart.test(t) && !inHtmlBlock){ inHtmlBlock=true; return true; }
        if(inHtmlBlock && htmlBlockEnd.test(t)){ inHtmlBlock=false; return true; }
        return false;
      }
      // Helper: when we see a '---' not at true start, detect if a frontmatter block follows soon
      function looksLikeFrontmatter(startIdx){
        // Look ahead up to 40 lines for a closing '---'
        let sawKeyLine=false;
        let fence=false, token='';
        let hComment=false, hBlock=false;
        for(let j=startIdx+1; j<Math.min(lines.length, startIdx+41); j++){
          const raw = lines[j];
          const tj = raw.trim();
          // Skip regions inside code fences in the lookahead
          const fm = tj.match(/^(```+|~~~+)/);
          if(fm){ const tok=fm[1].startsWith('`')?'```':'~~~'; if(!fence){ fence=true; token=tok; continue; } if(tok===token){ fence=false; token=''; continue; } }
          // HTML comments / blocks
          if(raw.includes('<!--') && !raw.includes('-->')){ hComment=true; continue; }
          if(raw.includes('-->') && hComment){ hComment=false; continue; }
          if(htmlBlockStart.test(tj) && !hBlock){ hBlock=true; continue; }
          if(hBlock && htmlBlockEnd.test(tj)){ hBlock=false; continue; }
          if(fence || hComment || hBlock) continue;
          if(tj==='---' || tj==='...'){ return sawKeyLine; }
          if(!tj) continue;
          // a simple key: value detector (no leading indentation required)
          if(/^[^\s][^:]*:\s*.*$/.test(tj)) sawKeyLine = true;
        }
        return false;
      }

      const pushSlide=()=>{
        const content = buf.join('\n').trim();
        if(content) slides.push(content);
        buf=[]; atSlideStart=true; inFM=false;
      };

      for(let i=0; i<lines.length; i++){
  const line = lines[i];
  const t = line.trim();
  // Track fenced code regions globally so separators inside are ignored
  if(fenceToggles(t)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
  // Track HTML comments / simple HTML blocks; ignore separators within
  if(commentToggle(line)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
  if(htmlBlockToggle(t)) { buf.push(line); if(t!=='') atSlideStart=false; continue; }
        if(inFM){
          buf.push(line);
    if(t==='---' || t==='...'){ inFM=false; }
          continue;
        }
  if(t==='---' && !inFence && !inHtmlComment && !inHtmlBlock){
          // If at the true start of a slide, this opens frontmatter
          if(atSlideStart){ inFM=true; buf.push(line); continue; }
          // If not at start and a valid frontmatter block follows, end current slide
          // and immediately start a new slide with frontmatter (consume this fence for the next slide)
          if(looksLikeFrontmatter(i)){
            pushSlide();
            buf=[]; atSlideStart=true; inFM=true; buf.push(line); // FM start for next slide
            continue;
          }
          // Otherwise this is just a slide separator
          pushSlide();
          continue;
        }
        // Ignore leading HR lines at a fresh slide start (they often come from pasted separators)
        if(atSlideStart && isHr(t)){
          // do not mark start as non-start, simply skip
          continue;
        }
        buf.push(line);
        if(t!=='') atSlideStart=false;
      }
      // Last slide
      pushSlide();

      dlog(`splitSlides: found ${slides.length} slides`);
      // Map to renderable objects
      const __mapped = slides.map((slideContent)=>{
        const { fm, body } = parseFrontmatter(slideContent);
        // Extract notes fenced as ```notes
        let processedBody = body;
        const noteMatches = [...processedBody.matchAll(/```notes\n([\s\S]*?)```/g)];
        for(const m of noteMatches){ fm.notes = (fm.notes? fm.notes+'\n\n' : '') + m[1].trim(); processedBody = processedBody.replace(m[0],''); }
        return { html: `<div class="md">${parseMarkdown(processedBody.trim())}</div>`, fm };
      });
      try{
        if(__mapped.length > 0 && __deckFM && Object.keys(__deckFM).length){
          __mapped[0].fm = Object.assign({}, __deckFM, __mapped[0].fm || {});
        }
        Object.defineProperty(__mapped, 'deckFM', { value: __deckFM, enumerable: false });
      }catch{}
      return __mapped;
    }

  // ===== Sanitizer (allow-list + safe href/src) =====
  function sanitizeHTML(html){ const ALLOWED=new Set(['class','href','src','alt','title','target','rel','style','id']); const SAFE_STYLE_PROPS=new Set(['display','gap','align-items','justify-content','flex','flex-grow','flex-shrink','flex-basis','min-width','max-width','min-height','max-height','width','height','border-radius','box-shadow','color','background','background-color','margin','margin-left','margin-right','margin-top','margin-bottom','padding','padding-left','padding-right','padding-top','padding-bottom','text-align','font-size','line-height','opacity']); const temp=document.createElement('div'); temp.innerHTML=html; temp.querySelectorAll('script,style,iframe,object,embed').forEach(n=>n.remove()); temp.querySelectorAll('*').forEach(el=>{ [...el.attributes].forEach(a=>{ const n=a.name.toLowerCase(); if(n.startsWith('on') || !ALLOWED.has(n)) { el.removeAttribute(a.name); return; } if(n==='style'){ const cleaned=[]; const parts=(a.value||'').split(';'); for(const part of parts){ const [kRaw,...vParts]=part.split(':'); if(!kRaw) continue; const k=kRaw.trim().toLowerCase(); const v=vParts.join(':').trim(); if(!v) continue; if(SAFE_STYLE_PROPS.has(k)){ cleaned.push(`${k}: ${v}`); } } if(cleaned.length){ el.setAttribute('style', cleaned.join('; ')); } else { el.removeAttribute('style'); } } }); if(el.tagName.toLowerCase()==='img'){ const v=(el.getAttribute('src')||'').trim(); const ok=/^https?:\/\//i.test(v)||/^data:image\//i.test(v); if(!ok) el.removeAttribute('src'); }
    if(el.tagName.toLowerCase()==='a'){ let href=(el.getAttribute('href')||'').trim(); // normalize bare links
      if(/^www\./i.test(href)) href='https://'+href; if(/^\/\//.test(href)) href='https:'+href; // update attribute
      if(href) el.setAttribute('href', href);
      const safe=/^(https?:|mailto:|tel:|#)/i.test(href); if(!safe) el.removeAttribute('href'); if(!href.startsWith('#')){ el.setAttribute('target','_blank'); el.setAttribute('rel','noopener'); } } }); return temp.innerHTML; }

  // ===== Render & Navigation =====
  let current=0, slidesHTML=[];
  function renderSlides(list){ slidesRoot.innerHTML=''; thumbsRoot.innerHTML=''; if(!Array.isArray(list)||!list.length){ current=0; document.getElementById('progress').style.width='0%'; document.getElementById('slideNo').textContent='0/0'; return; } list.forEach((obj,i)=>{ const node=document.createElement('section'); node.className='slide';
    // Per-slide background override via front matter: slidebg1/slidebg2 (hex)
    try{
      const fm = obj?.fm || {};
      const hRe = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;
      const unq = (s)=> s.replace(/^['"]|['"]$/g,'');
      const raw1 = (fm.slidebg1 || fm['slide-bg1'] || '').toString().trim();
      const raw2 = (fm.slidebg2 || fm['slide-bg2'] || '').toString().trim();
      const b1 = unq(raw1);
      const b2 = unq(raw2);
      const c1 = hRe.test(b1) ? b1 : null;
      const c2 = hRe.test(b2) ? b2 : null;
      if(c1 || c2){
        const left = c1 || 'var(--slide-bg1)';
        const right = c2 || 'var(--slide-bg2)';
        node.style.background = `linear-gradient(180deg, ${left}, ${right})`;
        // Mark override for testing/inspection
        try{
          node.setAttribute('data-slide-bg-override', '1');
          if(c1) node.setAttribute('data-slidebg1', c1);
          if(c2) node.setAttribute('data-slidebg2', c2);
        }catch{}
  }
    }catch{}
  node.innerHTML=sanitizeHTML(obj.html);
  // Wrap content in a scroll container so overlay and outline are not clipped
  try{
    const wrap = document.createElement('div');
    wrap.className = 'content-scroll';
    // Move all current children into the wrapper (e.g., .md)
    while(node.firstChild){ wrap.appendChild(node.firstChild); }
    node.appendChild(wrap);
    // Apply content position: per-slide FM > deck FM (merged into first slide fm) > CONFIG > default (tl)
    try{
      const fm = obj?.fm || {};
      const raw = String(fm['content-pos'] || fm.contentpos || (slidesHTML?.deckFM?.['content-pos']) || CONFIG.contentPos || 'tl').toLowerCase();
      const map = { t:{y:'flex-start'}, m:{y:'center'}, b:{y:'flex-end'} };
      const mapx = { l:'flex-start', m:'center', r:'flex-end' };
      let y='flex-start', x='flex-start';
      if(/^[tmb][lmr]$/.test(raw)){
        const row = raw[0]; const col = raw[1];
        y = (map[row]?.y) || 'flex-start';
        x = mapx[col] || 'flex-start';
      }
      wrap.style.setProperty('--content-x', x);
      wrap.style.setProperty('--content-y', y);
    }catch{}
  }catch{}
  // Enhance headings with anchor links
  try{
    const hs = node.querySelectorAll('h1[id],h2[id],h3[id]');
    hs.forEach(h=>{
      if(h.querySelector('.anchor-link')) return;
      const id = h.getAttribute('id');
      if(!id) return;
      const a = document.createElement('a');
      a.className='anchor-link'; a.href = '#'+id; a.title = 'Copy link'; a.textContent = '#';
      a.addEventListener('click', (e)=>{
        try{
          e.preventDefault();
          const base = location.href.split('#')[0];
          const url = base + '#' + id;
          if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(url); showToast && showToast('Link copied'); }
          else { location.hash = id; }
        }catch{}
      });
      h.appendChild(a);
    });
  }catch{}
  slidesRoot.append(node);
  const thumb=document.createElement('div');
  thumb.className='thumb';
  const t=(obj.fm.title||'').toString().trim();
  thumb.textContent = t || `Slide ${i+1}`;
  // Accessibility: keyboard focus and activation
  thumb.setAttribute('tabindex','0');
  thumb.setAttribute('role','button');
  thumb.setAttribute('aria-label', t ? `Slide ${i+1}: ${t}` : `Slide ${i+1}`);
  thumb.onclick = () => setActive(i);
  thumb.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); setActive(i); } });
  // Thumbnails are styled via CSS using --app-bg1/2 and other CSS vars. No inline styles needed.
      thumbsRoot.append(thumb); }); setActive(0); 
    // Apply current opacity to newly rendered slides
    if(typeof CONFIG.slideOpacity==='number'){ 
      try{
        if(window.Theme && typeof window.Theme.setSlideOpacity === 'function'){
          window.Theme.setSlideOpacity(CONFIG.slideOpacity);
        }else{
          setSlideOpacity(CONFIG.slideOpacity * 100);
        }
      }catch(e){}
    }
    // Build overlays if enabled
    try{
      const slides = [...document.querySelectorAll('.slide')];
      slides.forEach(s=>{ const old=s.querySelector('.slide-overlay'); if(old) old.remove(); });
      if(CONFIG.overlayOn===true){
        slides.forEach((slideEl, idx)=>{
          const fm = list[idx]?.fm || {};
          // per-slide overrides
          const slideOverlayFlagVal = (typeof fm.overlay !== 'undefined') ? String(fm.overlay).trim()
            : (typeof fm['overlay-pos'] !== 'undefined' || typeof fm['title-size'] !== 'undefined' || typeof fm['subtitle-size'] !== 'undefined') ? 'on' : undefined;
          const slideOverlayFlag = (typeof slideOverlayFlagVal !== 'undefined') ? /^(1|on|true)$/i.test(slideOverlayFlagVal) : true;
          if(!slideOverlayFlag) return;
          const pos = (fm['overlay-pos'] || fm.overlaypos || CONFIG.overlayPos || 'tl').toString().toLowerCase();
          const tSizeRaw = (typeof fm['title-size'] !== 'undefined') ? fm['title-size'] : fm.titlesize;
          const sSizeRaw = (typeof fm['subtitle-size'] !== 'undefined') ? fm['subtitle-size'] : fm.subtitlesize;
          const tSize = isFinite(Number(tSizeRaw)) ? Math.max(12, Math.min(64, Math.round(Number(tSizeRaw)))) : CONFIG.overlayTitleSize;
          const sSize = isFinite(Number(sSizeRaw)) ? Math.max(10, Math.min(48, Math.round(Number(sSizeRaw)))) : CONFIG.overlaySubtitleSize;
          const titleTxt = (fm.title||'').toString().trim() || `Slide ${idx+1}`;
          const subtitleTxt = (fm.subtitle||'').toString().trim();
          const wrap = document.createElement('div');
          wrap.className = `slide-overlay pos-${pos}`;
          // per-slide size overrides via inline style
          if(tSize) wrap.style.setProperty('--title-size', `${tSize}px`);
          if(sSize) wrap.style.setProperty('--subtitle-size', `${sSize}px`);
          const tEl = document.createElement('div'); tEl.className='slide-title'; tEl.textContent = titleTxt; wrap.appendChild(tEl);
          if(CONFIG.overlaySubtitleOn===true && subtitleTxt){ const sEl=document.createElement('div'); sEl.className='slide-subtitle'; sEl.textContent=subtitleTxt; if((CONFIG.overlaySubtitleColor||'primary')==='accent'){ sEl.classList.add('accent-subtitle'); } wrap.appendChild(sEl);} 
          wrap.setAttribute('aria-hidden','true');
          slideEl.appendChild(wrap);
        });
      }
    }catch{}
  }

  function setActive(i, direction = 'none'){
    const all = [...document.querySelectorAll('.slide')];
    all.forEach(s => s.classList.remove('active', 'prev', 'slide-in-right', 'slide-in-left', 'slide-out-left', 'slide-out-right'));
    
    if (all[i]) {
      if (direction === 'next') {
        all[i].classList.add('slide-in-right');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            all[i].classList.remove('slide-in-right');
          });
        });
      } else if (direction === 'prev') {
        all[i].classList.add('slide-in-left');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            all[i].classList.remove('slide-in-left');
          });
        });
      }
      
      all[i].classList.add('active');
      all[i].setAttribute('tabindex', '-1');
      all[i].focus({ preventScroll: true });
      try{
        const sc = all[i].querySelector('.content-scroll');
        if(sc) sc.scrollTop = 0;
      }catch{}
    }
    
    if (all[i - 1]) all[i - 1].classList.add('prev');
    
    current = i;
    document.getElementById('progress').style.width = ((i + 1) / all.length * 100) + '%';
    document.getElementById('slideNo').textContent = `${i + 1}/${all.length}`;
    
    const thumbs = [...document.querySelectorAll('.thumb')];
    thumbs.forEach((t, j) => t.classList.toggle('active', j === i));
  // Ensure computed backgroundImage on the active thumb reflects the theme gradient (WebKit compat for tests)
    try{
      const cs = getComputedStyle(document.documentElement);
      const primary = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accent = (CONFIG.accent && String(CONFIG.accent).trim()) || (cs.getPropertyValue('--accent')||'').trim();
      thumbs.forEach((t, j)=>{
        if(j === i){
          const grad = `linear-gradient(135deg, ${primary}, ${accent})`;
      // Use !important to win over stylesheet !important and ensure getComputedStyle reflects the gradient
      try{ t.style.setProperty('background-image', grad, 'important'); }catch{ t.style.backgroundImage = grad; }
      try{ t.style.setProperty('background', grad, 'important'); }catch{ t.style.background = grad; }
        } else {
      t.style.removeProperty('background-image');
      t.style.removeProperty('background');
        }
      });
    }catch{}
  // Thumbnails are CSS-driven; no inline style toggling required here.
    
    const notesMd = slidesHTML[i]?.fm?.notes || '';
    notesEl.innerHTML = notesMd ? sanitizeHTML(`<div class="md">${parseMarkdown(notesMd, {allowColumns: false})}</div>`) : `<em>[No notes for slide ${i + 1}]</em>`;
    
    try {
      history.replaceState(null, '', `#/${i + 1}`);
    } catch {}
    
    slidesRoot.setAttribute('aria-label', `Slide ${i + 1} of ${all.length}`);
  // As a final step, enforce active thumb gradient for engines with odd computed style timing
  try{ updateActiveThumbGradient(/*retry*/true); }catch{}
  }

  const next=()=>{ if(current<slidesHTML.length-1) setActive(++current,'next'); };
  const prev=()=>{ if(current>0) setActive(--current,'prev'); };

  // Update the active thumbnail's backgroundImage gradient to match current theme
  function updateActiveThumbGradient(retry=false){
    try{
      const active = document.querySelector('.thumb.active');
      if(!active) return;
      const cs = getComputedStyle(document.documentElement);
      // Normalize theme colors to rgb(r,g,b) to match computed style shape in tests
      function toRgbStr(val){
        if(!val) return '';
        const s = String(val).trim();
        // Already rgb(a)
        if(/^rgba?\(/i.test(s)) return s;
        // Hex -> rgb
        const h = (s.startsWith('#') ? s : ('#'+s)).toLowerCase();
        const m3 = /^#([0-9a-f]{3})$/i.exec(h);
        const m6 = /^#([0-9a-f]{6})$/i.exec(h);
        let r,g,b;
        if(m3){
          const v=m3[1]; r=parseInt(v[0]+v[0],16); g=parseInt(v[1]+v[1],16); b=parseInt(v[2]+v[2],16);
        } else if(m6){
          const v=m6[1]; r=parseInt(v.slice(0,2),16); g=parseInt(v.slice(2,4),16); b=parseInt(v.slice(4,6),16);
        }
        if(r==null||g==null||b==null) return s;
        return `rgb(${r},${g},${b})`;
      }
      const primaryRaw = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accentRaw  = (CONFIG.accent  && String(CONFIG.accent ).trim()) || (cs.getPropertyValue('--accent') ||'').trim();
      const primary = toRgbStr(primaryRaw);
      const accent  = toRgbStr(accentRaw);
      if(primary && accent){
        const grad = `linear-gradient(135deg, ${primary}, ${accent})`;
        const apply = ()=>{
          // Temporarily disable background transition so computed style reflects immediately after navigation
          try{
            active.style.setProperty('transition-property', 'transform, box-shadow, border-color', 'important');
          }catch{}
          try{ active.style.setProperty('background-image', grad, 'important'); }catch{ active.style.backgroundImage = grad; }
          try{ active.style.setProperty('background', grad, 'important'); }catch{ active.style.background = grad; }
          // Restore transition properties on next microtask
          try{ setTimeout(()=>{ active.style.removeProperty('transition-property'); }, 0); }catch{}
          try{ document.documentElement.style.setProperty('--thumb-active-bg', grad); }catch{}
          // Also enforce via a dynamic stylesheet so computed styles consistently reflect the gradient across engines
          try{
            let tag = document.getElementById('thumb-active-style');
            const css = `.thumb.active{background:${grad} !important;background-image:${grad} !important;}`;
            if(!tag){
              tag = document.createElement('style');
              tag.id = 'thumb-active-style';
              tag.setAttribute('data-owned','slideapp');
              tag.textContent = css;
              document.head.appendChild(tag);
            } else {
              tag.textContent = css;
            }
          }catch{}
        };
        apply();
        // Retry on next frame and shortly after to win races with transitions/layout
        if(retry){
          try{ requestAnimationFrame(()=>{ apply(); setTimeout(apply, 60); }); }catch{}
        }
      }
    }catch{}
  }

  // Ensure the CSS var used by .thumb.active reflects current CONFIG immediately
  function setThumbActiveBgFromConfig(){
    try{
      const cs = getComputedStyle(document.documentElement);
      const primaryRaw = (CONFIG.primary && String(CONFIG.primary).trim()) || (cs.getPropertyValue('--primary')||'').trim();
      const accentRaw  = (CONFIG.accent  && String(CONFIG.accent ).trim()) || (cs.getPropertyValue('--accent') ||'').trim();
      if(primaryRaw && accentRaw){
        const grad = `linear-gradient(135deg, ${primaryRaw}, ${accentRaw})`;
        document.documentElement.style.setProperty('--thumb-active-bg', grad);
      }
    }catch{}
  }

  document.getElementById('btnPrev').addEventListener('click',prev);
  document.getElementById('btnNext').addEventListener('click',next);
  function toggleNotes(){ const now = notesEl.classList.toggle('show'); try{ showToast(now ? 'Notes: shown' : 'Notes: hidden'); }catch{} }
  document.getElementById('notesBtn').addEventListener('click',toggleNotes);
  document.getElementById('bgBtn').addEventListener('click',cycleBackground);
  function toggleFullscreen(){ const el=document.documentElement; if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }
  document.getElementById('fsBtn').addEventListener('click',(e)=>{ e.preventDefault(); toggleFullscreen(); });

  // Respect focus: don't hijack keys inside inputs/contenteditable
  function toggleOutline(){
    CONFIG.slideBorderOn = !(CONFIG.slideBorderOn===true) ? true : false; // invert
    document.body.classList.toggle('border-off', CONFIG.slideBorderOn===false);
    try{ showToast(CONFIG.slideBorderOn===false ? 'Outline: hidden' : 'Outline: shown'); }catch{}
    // sync Style checkbox if open
    try{ const cb=document.getElementById('cfgSlideOutline'); if(cb) cb.checked = (CONFIG.slideBorderOn!==false); }catch{}
  }
  document.addEventListener('keydown',e=>{ const tag=(e.target&&e.target.tagName||'').toLowerCase(); if(tag==='input'||tag==='textarea'||e.target.isContentEditable) return; if(e.key==='ArrowRight'||e.key===' ') next(); if(e.key==='ArrowLeft') prev(); const k=e.key.toLowerCase(); if(k==='b') cycleBackground(); if(k==='n') toggleNotes(); if(k==='s') toggleDrawer(); if(k==='f'){ e.preventDefault(); toggleFullscreen(); } if(k==='u'){ e.preventDefault(); cycleUi(); } if(k==='p'){ e.preventDefault(); toggleProgress(); } if(k==='t'){ e.preventDefault(); toggleOpacity(); } if(k==='o'){ e.preventDefault(); toggleOutline(); } if(k==='y'){ e.preventDefault(); const b=document.getElementById('overlayBtn'); if(b) b.click(); } });

  // Drawer thumbnails (overlay on small screens)
  const drawerKey='drawerCollapsed'; const isOverlay=()=>innerWidth<1024; function setDrawerUI(){ const collapsed=localStorage.getItem(drawerKey)==='1'; const open=localStorage.getItem('drawerOpen')==='1'; const overlay=isOverlay(); thumbsRoot.classList.remove('collapsed','overlay','open'); if(overlay){ thumbsRoot.classList.add('overlay'); if(open) thumbsRoot.classList.add('open'); scrimEl.style.display = open ? 'block' : 'none'; drawerBtn.textContent='🧭 Slides'; drawerBtn.title = open?'Hide slides':'Show slides'; } else { thumbsRoot.classList.toggle('collapsed',collapsed); scrimEl.style.display='none'; drawerBtn.textContent='🧭 Slides'; drawerBtn.title = collapsed?'Show slides':'Hide slides'; } }
  function toggleDrawer(){ if(isOverlay()){ const open=!(localStorage.getItem('drawerOpen')==='1'); localStorage.setItem('drawerOpen', open?'1':'0'); setDrawerUI(); try{ showToast(open ? 'Slides: opened' : 'Slides: hidden'); }catch{} } else { const collapsed=!(localStorage.getItem(drawerKey)==='1'); localStorage.setItem(drawerKey, collapsed?'1':'0'); setDrawerUI(); try{ showToast(collapsed ? 'Slides: hidden' : 'Slides: shown'); }catch{} } }
  // Enhance: allow toggling slides while UI is off by overriding hide-slides class when opening
  (function enhanceDrawerToggle(){
    const origToggle = toggleDrawer;
    window.toggleDrawer = function(){
      const overlay = isOverlay();
      // Determine current intent: will result be open or closed?
      let willOpen = false;
      if(overlay){
        const open = !(localStorage.getItem('drawerOpen')==='1');
        willOpen = open; // toggled state after click
      } else {
        const currentlyCollapsed = (localStorage.getItem(drawerKey)==='1');
        willOpen = currentlyCollapsed; // toggling will open when currently collapsed
      }
      // If UI is off and slides are configured to hide, remove hide-slides when opening
      const hideSlidesCfg = (CONFIG.hideSlidesWithUi !== false);
      if(document.body.classList.contains('ui-off') && hideSlidesCfg){
        if(willOpen){
          document.body.classList.remove('hide-slides');
        }
      }
      // Perform original toggle
      origToggle();
      // If closing while UI off and configured to hide, re-apply hide-slides
      if(document.body.classList.contains('ui-off') && hideSlidesCfg){
        if(!willOpen){
          document.body.classList.add('hide-slides');
        }
      }
    }
  })();
  drawerBtn.addEventListener('click',toggleDrawer); scrimEl.addEventListener('click',()=>{localStorage.setItem('drawerOpen','0'); setDrawerUI();}); window.addEventListener('resize', setDrawerUI);

  // UI visibility (header/footer on/off)
  function readUiMode(){
    const raw = localStorage.getItem('uiMode');
    if(raw === null) return 0;
    const v = String(raw).toLowerCase().trim();
    if(v === '1' || v === 'true') return 1;
    if(v === '0' || v === 'false') return 0;
    return 0; // sanitize unknown legacy values
  }
  let uiMode = readUiMode();
  function setUiButtonState(){
    const b=document.getElementById('uiBtn');
    if(!b) return;
    const on = uiMode === 1;
    b.setAttribute('aria-pressed', on ? 'true':'false');
    b.title = on ? 'Show UI' : 'Hide UI';
    b.textContent = on ? '👁️ UI (off)' : '👁️ UI';
  }
  function applyUiMode(){
    // Inline styles for backward compatibility, plus body class for robustness
    const on = uiMode === 1;
    document.querySelector('.deck-header').style.display= on ? 'none':'flex';
    document.body.classList.toggle('ui-off', on);
  // Clear any temporary progress overrides when UI mode changes
  document.body.classList.remove('progress-on','progress-off');
    const hideSlides = (CONFIG.hideSlidesWithUi !== false);
    const hideProgress = (CONFIG.hideProgressWithUi !== false);
    document.body.classList.toggle('hide-slides', on && hideSlides);
    document.body.classList.toggle('hide-progress', on && hideProgress);
    // When hiding slides, ensure overlay closed
    if(on && hideSlides){
      localStorage.setItem('drawerOpen','0');
      thumbsRoot.classList.remove('open');
      scrimEl.style.display='none';
    }
    // If UI is turned off, ensure drawer overlay is considered closed
    if(on){
      localStorage.setItem('drawerOpen','0');
    }
    setUiButtonState();
  }
  function cycleUi(){ uiMode = uiMode===1 ? 0 : 1; localStorage.setItem('uiMode', uiMode ? '1':'0'); applyUiMode(); try{ showToast(uiMode===1 ? 'UI: hidden' : 'UI: shown'); }catch{} }
  (function bindUiButton(){
    const b=document.getElementById('uiBtn');
    if(!b) return;
    const handler=(e)=>{ e.preventDefault(); e.stopPropagation(); cycleUi(); };
    b.addEventListener('click', handler);
    b.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' || e.key===' '){ handler(e); }
    });
  })();

  // Style modal
  const cfgOverlay=document.getElementById('cfgOverlay'); const cfgModal=document.getElementById('cfgModal'); document.getElementById('styleBtn').addEventListener('click',()=>{
  cfgOverlay.style.display='block'; cfgModal.style.display='flex';
  document.getElementById('cfgName').value=(CONFIG.appName||CONFIG.brand||'');
  try{ const pNorm = normalizeHex(CONFIG.primary||'') || '#01B4E1'; document.getElementById('cfgPrimary').value = pNorm; }catch{}
  try{ const aNorm = normalizeHex(CONFIG.accent||'') || '#64FFFC'; document.getElementById('cfgAccent').value = aNorm; }catch{}
    // Initialize background pickers from CONFIG or computed CSS vars
    try{
  const appBg1 = normalizeHex(CONFIG.appBg1) || normalizeHex(getComputedStyle(document.documentElement).getPropertyValue('--app-bg1').trim()) || '#0f172a';
  const appBg2 = normalizeHex(CONFIG.appBg2) || normalizeHex(getComputedStyle(document.documentElement).getPropertyValue('--app-bg2').trim()) || '#1e293b';
  const slideBg1 = normalizeHex(CONFIG.slideBg1) || '#111827';
  const slideBg2 = normalizeHex(CONFIG.slideBg2) || '#111827';
      const elApp1 = document.getElementById('cfgAppBg1'); if(elApp1) elApp1.value = appBg1;
      const elApp2 = document.getElementById('cfgAppBg2'); if(elApp2) elApp2.value = appBg2;
      const elS1 = document.getElementById('cfgSlideBg1'); if(elS1) elS1.value = slideBg1;
      const elS2 = document.getElementById('cfgSlideBg2'); if(elS2) elS2.value = slideBg2;
    }catch(e){}
    // Initialize text color picker from CONFIG or computed --text
    try{
  const txt = normalizeHex(CONFIG.textColor) || normalizeHex(getComputedStyle(document.documentElement).getPropertyValue('--text').trim()) || '#e2e8f0';
  const elText = document.getElementById('cfgTextColor'); if(elText) elText.value = txt;
    // Button text color mode + picker
    try{
      const modeSel = document.getElementById('cfgBtnTextMode');
      const btnClr = document.getElementById('cfgBtnTextColor');
      const vRaw = (CONFIG.btnTextColor||'auto');
      const v = typeof vRaw==='string' ? vRaw.trim().toLowerCase() : '';
      const isAuto = (v === 'auto' || !v);
      modeSel.value = isAuto ? 'auto' : 'custom';
      if(!isAuto){ const n = normalizeHex(String(CONFIG.btnTextColor)); btnClr.value = n || '#ffffff'; }
      btnClr.disabled = isAuto;
      modeSel.onchange = ()=>{ btnClr.disabled = (modeSel.value==='auto'); };
    }catch{}
    // Button fill
    try{ const bf=document.getElementById('cfgBtnFill'); bf.value = (CONFIG.btnFill==='outline'?'outline':'solid'); }catch{}
    }catch{}
    // Live-preview bindings for color pickers: update CONFIG and applyConfig immediately
    try{
  const bindLive=(id,key,norm)=>{ const el=document.getElementById(id); if(!el) return; el.oninput=(ev)=>{ const v=(ev.target.value||'').toString(); try{ if(norm){ const n=normalizeHex(v); if(n) CONFIG[key]=n; else delete CONFIG[key]; } else { CONFIG[key]=v; } }catch{} try{ if(window.Theme && typeof window.Theme.applyConfig === 'function'){ try{ window.Theme.applyConfig(CONFIG); }catch{} } else { applyConfig(); } }catch{} }; };
      bindLive('cfgPrimary','primary', false);
      bindLive('cfgAccent','accent', false);
      bindLive('cfgTextColor','textColor', true);
      // live: custom button text color only when custom mode is active
      try{
        const modeSel = document.getElementById('cfgBtnTextMode');
        const btnClr = document.getElementById('cfgBtnTextColor');
        btnClr.oninput = ()=>{ if(modeSel.value==='custom'){ const n=normalizeHex(btnClr.value||''); if(n) CONFIG.btnTextColor = n; try{ window.Theme && window.Theme.applyConfig && window.Theme.applyConfig(CONFIG); }catch{} } };
        modeSel.onchange = ()=>{ if(modeSel.value==='auto'){ CONFIG.btnTextColor = 'auto'; } else { const n=normalizeHex(btnClr.value||''); if(n) CONFIG.btnTextColor = n; }
          try{ window.Theme && window.Theme.applyConfig && window.Theme.applyConfig(CONFIG); }catch{} };
        const fillSel = document.getElementById('cfgBtnFill');
        fillSel.onchange = ()=>{ const v=String(fillSel.value||'solid').toLowerCase(); CONFIG.btnFill = (v==='outline'?'outline':'solid'); try{ window.Theme && window.Theme.applyConfig && window.Theme.applyConfig(CONFIG); }catch{} };
      }catch{}
      bindLive('cfgAppBg1','appBg1', true);
      bindLive('cfgAppBg2','appBg2', true);
      bindLive('cfgSlideBg1','slideBg1', true);
      bindLive('cfgSlideBg2','slideBg2', true);
    }catch(e){}
    const row=document.getElementById('presetRow'); row.innerHTML='';
    // Build compact segmented preset buttons (behaves like overlay-position selector)
    const makeGroup = (title)=>{
      const container=document.createElement('div'); container.style.display='flex'; container.style.flexDirection='column'; container.style.gap='6px';
  const label=document.createElement('label'); label.style.fontSize='12px'; label.textContent=title;
      const group=document.createElement('div'); group.style.display='flex'; group.style.gap='6px'; group.setAttribute('role','toolbar');
      container.appendChild(label); container.appendChild(group);
      return {container, group};
    };
    const darkGroup = makeGroup('Dark presets');
    const lightGroup = makeGroup('Light presets');

    // Active state helper (single active at a time across all presets)
    const setActivePreset = (idx)=>{
      [...row.querySelectorAll('button.preset-btn')].forEach(b=>{ const on = b.dataset.presetIndex===String(idx); b.classList.toggle('active', on); b.setAttribute('aria-pressed', on? 'true':'false'); });
    };

    PRESETS.forEach((p,idx)=>{
      const b=document.createElement('button'); b.className='btn preset-btn'; b.textContent=p.name; b.title = `Apply ${p.name}`;
  // Use CSS-driven button background; no inline gradient so it matches other controls
      b.dataset.presetIndex = String(idx);
      b.setAttribute('aria-pressed','false');
      try{ b.style.removeProperty('color'); }catch{}
      try{ b.style.borderColor = 'rgba(255,255,255,0.06)'; }catch{}
      b.onclick = ()=>{
        // populate inputs
        try{ document.getElementById('cfgPrimary').value = p.primary; }catch{}
        try{ document.getElementById('cfgAccent').value = p.accent; }catch{}
        try{ if(p.textColor) document.getElementById('cfgTextColor').value = p.textColor; }catch{}
        try{ if(p.appBg1) document.getElementById('cfgAppBg1').value = p.appBg1; }catch{}
        try{ if(p.appBg2) document.getElementById('cfgAppBg2').value = p.appBg2; }catch{}
        try{ if(p.slideBg1) document.getElementById('cfgSlideBg1').value = p.slideBg1; }catch{}
        try{ if(p.slideBg2) document.getElementById('cfgSlideBg2').value = p.slideBg2; }catch{}
        // apply immediately (update CONFIG and set CSS vars for instant preview)
        try{
          // normalize and store
          const nPrimary = normalizeHex(p.primary) || p.primary;
          const nAccent = normalizeHex(p.accent) || p.accent;
          CONFIG.primary = nPrimary;
          CONFIG.accent = nAccent;
          if(p.textColor){ const nt = normalizeHex(p.textColor) || p.textColor; CONFIG.textColor = nt; } else { delete CONFIG.textColor; }
          if(p.appBg1) CONFIG.appBg1 = normalizeHex(p.appBg1) || p.appBg1; else delete CONFIG.appBg1;
          if(p.appBg2) CONFIG.appBg2 = normalizeHex(p.appBg2) || p.appBg2; else delete CONFIG.appBg2;
          if(p.slideBg1) CONFIG.slideBg1 = normalizeHex(p.slideBg1) || p.slideBg1; else delete CONFIG.slideBg1;
          if(p.slideBg2) CONFIG.slideBg2 = normalizeHex(p.slideBg2) || p.slideBg2; else delete CONFIG.slideBg2;
          // set CSS vars explicitly so modal and UI reflect the preset immediately
          // Theme.applyConfig will manage these CSS vars; no inline writes here.
          // Recompute derived values and update UI (use non-persisting opacity preview)
          try{ if(window.Theme && typeof window.Theme.applyConfig === 'function'){ try{ window.Theme.applyConfig(CONFIG); }catch{} } else { applyConfig(); } }catch{}
          setSlideOpacity(typeof CONFIG.slideOpacity==='number' ? Math.round(CONFIG.slideOpacity*100) : 100, false);
        }catch{}
        // set active visual state
        setActivePreset(idx);
        try{ showToast(`Preset: ${p.name}`);}catch{}
      };
      if(p.group==='dark') darkGroup.group.appendChild(b); else lightGroup.group.appendChild(b);
    });

    if(darkGroup.group.children.length){ row.appendChild(darkGroup.container); }
    if(lightGroup.group.children.length){ row.appendChild(lightGroup.container); }

    // If no saved config present, mark the Default preset active for clarity
    try{
      const raw = localStorage.getItem('slideapp.config');
      if(!raw){ const defaultIdx = PRESETS.findIndex(p=>p.name && p.name.toLowerCase()==='default'); if(defaultIdx>=0) setActivePreset(defaultIdx); }
    }catch(e){}
    // init slide opacity slider
    const slider = document.getElementById('cfgSlideOpacity');
    const readout = document.getElementById('cfgSlideOpacityVal');
    const val = typeof CONFIG.slideOpacity==='number'? Math.round(CONFIG.slideOpacity*100):100;
    slider.value = String(val);
    readout.textContent = `(${val}%)`;
    slider.oninput = (e)=>{
      const pct = Number(e.target.value)||0; readout.textContent = `(${pct}%)`;
      setSlideOpacity(pct);
    };
    // UI visibility checkboxes
    const chkSlides = document.getElementById('cfgHideSlidesWithUi');
    const chkProgress = document.getElementById('cfgHideProgressWithUi');
    const chkOutline = document.getElementById('cfgSlideOutline');
    chkSlides.checked = (CONFIG.hideSlidesWithUi !== false); // default true
    chkProgress.checked = (CONFIG.hideProgressWithUi !== false); // default true
    chkOutline.checked = (CONFIG.slideBorderOn !== false); // default true
    chkOutline.onchange = ()=>{
      CONFIG.slideBorderOn = chkOutline.checked;
      document.body.classList.toggle('border-off', CONFIG.slideBorderOn===false);
      try{ showToast(CONFIG.slideBorderOn===false ? 'Outline: hidden' : 'Outline: shown'); }catch{}
    };
    // Outline width control
    const ow = document.getElementById('cfgOutlineWidth');
    const owVal = document.getElementById('cfgOutlineWidthVal');
    const owDefault = (typeof CONFIG.slideBorderWidth === 'number' && isFinite(CONFIG.slideBorderWidth)) ? Math.round(CONFIG.slideBorderWidth) : 3;
    ow.value = String(owDefault);
    owVal.textContent = `(${owDefault}px)`;
    ow.oninput = (e)=>{
      const px = Math.max(0, Math.min(8, Math.round(Number(e.target.value)||0)));
      owVal.textContent = `(${px}px)`;
      document.documentElement.style.setProperty('--outline-w', `${px}px`);
    };
    // Remember deck controls
    const chkRemember = document.getElementById('cfgRememberDeck');
    chkRemember.checked = (CONFIG.rememberLastDeck === true);
    const btnForget = document.getElementById('cfgForgetDeck');
    btnForget.onclick = ()=>{
      try{
        sessionStorage.removeItem('slideapp.session.deck');
        localStorage.removeItem('slideapp.persist.deck');
        showToast('Forgot last deck');
      }catch{}
    };
    // Bind Clear button next to slider
    const clearBtn = document.getElementById('btnClearOpacity');
    if(clearBtn){
      clearBtn.onclick = ()=>{
        slider.value = '0';
        readout.textContent = '(0%)';
        setSlideOpacity(0);
        try{ showToast('Clear'); }catch{}
      };
    }
    // Overlay controls init
    try{
      const cbTitle = document.getElementById('cfgOverlayTitleOn'); cbTitle.checked = (CONFIG.overlayOn===true);
  const cbSub = document.getElementById('cfgOverlaySubtitleOn'); cbSub.checked = (CONFIG.overlaySubtitleOn!==false);
  const ts = document.getElementById('cfgTitleSize'); const tsVal=document.getElementById('cfgTitleSizeVal'); const tsDefault = Math.max(12, Math.min(64, Math.round(CONFIG.overlayTitleSize||22))); ts.value=String(tsDefault); tsVal.textContent = `(${tsDefault}px)`; ts.oninput=(e)=>{ const px=Math.max(12, Math.min(64, Math.round(Number(e.target.value)||22))); tsVal.textContent=`(${px}px)`; try{ document.documentElement.style.setProperty('--title-size', `${px}px`); }catch(e){} };
  const ss = document.getElementById('cfgSubtitleSize'); const ssVal=document.getElementById('cfgSubtitleSizeVal'); const ssDefault = Math.max(10, Math.min(48, Math.round(CONFIG.overlaySubtitleSize||16))); ss.value=String(ssDefault); ssVal.textContent = `(${ssDefault}px)`; ss.oninput=(e)=>{ const px=Math.max(10, Math.min(48, Math.round(Number(e.target.value)||16))); ssVal.textContent=`(${px}px)`; try{ document.documentElement.style.setProperty('--subtitle-size', `${px}px`); }catch(e){} };
  const sc = document.getElementById('cfgSubtitleColor'); sc.value = (CONFIG.overlaySubtitleColor||'primary');
      const posWrap = document.getElementById('cfgOverlayPos');
      const posHint = document.getElementById('cfgOverlayPosHint');
      const setActive=(p)=>{ [...posWrap.querySelectorAll('button')].forEach(b=>{ const on=(b.dataset.pos===p); b.classList.toggle('active', on); b.setAttribute('aria-pressed', on? 'true':'false'); }); };
      const cur=(CONFIG.overlayPos||'tl').toLowerCase(); setActive(cur);
      const setPosDisabled = (off)=>{
        const disable = !!off;
        [...posWrap.querySelectorAll('button')].forEach(b=>{ if(disable){ b.setAttribute('disabled',''); b.setAttribute('aria-disabled','true'); } else { b.removeAttribute('disabled'); b.setAttribute('aria-disabled','false'); } });
        if(posHint){ posHint.style.display = disable ? 'inline' : 'none'; }
      };
      const setSizeDisabled = (off)=>{
        const disable = !!off; if(ts){ ts.disabled = disable; } if(ss){ ss.disabled = disable; }
      };
      const setSubtitleControlsDisabled = (off)=>{
        const disable = !!off; if(cbSub){ cbSub.disabled = disable; } if(sc){ sc.disabled = disable; }
      };
      setPosDisabled(!(CONFIG.overlayOn===true));
      setSizeDisabled(!(CONFIG.overlayOn===true));
      setSubtitleControlsDisabled(!(CONFIG.overlayOn===true));
      cbTitle.onchange = ()=>{
        // update disabled state and preview if turned on
        const on = cbTitle.checked;
        setPosDisabled(!on);
        setSizeDisabled(!on);
        setSubtitleControlsDisabled(!on);
        // if user turns overlay on while modal is open, show preview
        CONFIG.overlayOn = on; // reflect intent temporarily; Save will persist real value
        if(on){ try{ rebuildOverlays(window.__tempOverlayPos || cur); }catch{} } else { try{ rebuildOverlays(); }catch{} }
      };
      posWrap.querySelectorAll('button').forEach(btn=>{
        btn.setAttribute('aria-pressed', btn.dataset.pos===cur ? 'true' : 'false');
        btn.onclick=()=>{
          const pos = btn.dataset.pos;
          setActive(pos);
          // store a temporary selection used for live preview; persist on Save only
          try{ window.__tempOverlayPos = pos; }catch{}
          try{ showToast(`Title position: ${pos.toUpperCase()}`);}catch{}
          // live preview if overlay is currently ON
          if(CONFIG.overlayOn===true){
            try{ rebuildOverlays(pos); }catch{}
          }
        };
      });
      const fp = document.getElementById('cfgFontPrimary'); const fs = document.getElementById('cfgFontSecondary'); fp.value = CONFIG.fontPrimary||''; fs.value = CONFIG.fontSecondary||'';
    }catch{}

    // Content position controls
    try{
      const group = document.getElementById('cfgContentPos');
      if(group){
        const setActive=(p)=>{ [...group.querySelectorAll('button')].forEach(b=>{ const on=(b.dataset.pos===p); b.classList.toggle('active', on); b.setAttribute('aria-pressed', on? 'true':'false'); }); };
        const current = (CONFIG.contentPos || 'tl').toLowerCase(); setActive(current);
        const applyPreview=(p)=>{
          const sc = document.querySelector('.slide.active .content-scroll');
          if(!sc) return;
          const mapRow = { t:'flex-start', m:'center', b:'flex-end' };
          const mapCol = { l:'flex-start', m:'center', r:'flex-end' };
          if(/^[tmb][lmr]$/.test(p)){
            sc.style.setProperty('--content-y', mapRow[p[0]]);
            sc.style.setProperty('--content-x', mapCol[p[1]]);
          }
        };
        group.querySelectorAll('button').forEach(btn=>{
          btn.onclick=()=>{ const pos=(btn.dataset.pos||'tl').toLowerCase(); setActive(pos); try{ window.__tempContentPos = pos; }catch{} applyPreview(pos); };
          btn.addEventListener('keydown',(e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); btn.click(); }});
        });
        // Initial preview
        applyPreview(current);
      }
    }catch{}

    // External config controls
    try{
      const persistChk = document.getElementById('cfgPersistConfig'); if(persistChk){ persistChk.checked = !!PERSIST_CONFIG; persistChk.onchange = ()=>{ PERSIST_CONFIG = !!persistChk.checked; try{ localStorage.setItem('slideapp.config.persist', PERSIST_CONFIG ? '1':'0'); showToast(PERSIST_CONFIG? 'Persist: on':'Persist: off'); }catch{} }; }
      const urlInput = document.getElementById('cfgConfigUrl');
      const btnLoad = document.getElementById('cfgLoadUrl'); if(btnLoad){ btnLoad.onclick = async ()=>{ const u=(urlInput?.value||'').trim(); if(!u){ try{ showToast('Enter a URL'); }catch{} return; } await loadConfigFromUrl(u); } }
      const fileInput = document.getElementById('cfgImportFile');
      const importBtn = document.getElementById('cfgImportBtn');
      if(importBtn && fileInput){ importBtn.onclick = ()=>{ try{ fileInput.click(); }catch{} }; }
      if(fileInput){ fileInput.onchange = async (e)=>{ try{ const f=e.target.files && e.target.files[0]; if(!f) return; if(f.size > 2*1024*1024){ alert('File too large (max 2MB)'); e.target.value=''; return; } const text = await f.text(); const data = JSON.parse(text); mergeConfig(data, 'merge'); if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} } try{ showToast('Config imported'); }catch{} e.target.value=''; }catch(err){ console.error('Import failed',err); alert('Import failed: '+(err?.message||err)); e.target.value=''; } } }
      const btnExport = document.getElementById('cfgExport'); if(btnExport){ btnExport.onclick = ()=>{ try{ exportConfigBlob(); }catch(e){ alert('Export failed: '+(e?.message||e)); } } }
    }catch(e){ console.error('External config controls failed', e); }

    // Ensure Save button is in view for small viewports/tests
    try{ setTimeout(()=>{ document.getElementById('cfgSave')?.scrollIntoView({block:'center'}); }, 0); }catch{}
  }); document.getElementById('cfgClose').addEventListener('click',()=>{ cfgOverlay.style.display=cfgModal.style.display='none'; try{ delete window.__tempOverlayPos; }catch{} try{ rebuildOverlays(); }catch{} }); document.getElementById('cfgSave').addEventListener('click',()=>{ CONFIG.brand=document.getElementById('cfgName').value.trim(); CONFIG.primary=document.getElementById('cfgPrimary').value; CONFIG.accent=document.getElementById('cfgAccent').value; // persist slide opacity
    const slider=document.getElementById('cfgSlideOpacity'); let pct=Number(slider.value); if(!Number.isFinite(pct)) pct=100; pct=Math.round(Math.max(0, Math.min(100, pct))); CONFIG.slideOpacity = pct/100;
  // Save under new key appName (keep legacy brand for compatibility)
  const nm = document.getElementById('cfgName').value.trim();
  CONFIG.appName = nm; if(!CONFIG.brand) CONFIG.brand = nm; // keep brand populated once for older versions
  // Persist background pickers (normalize hex values)
  try{
    const ra = (document.getElementById('cfgAppBg1')?.value || '').toString(); const na = normalizeHex(ra);
    const rb = (document.getElementById('cfgAppBg2')?.value || '').toString(); const nb = normalizeHex(rb);
    if(na) CONFIG.appBg1 = na; else delete CONFIG.appBg1;
    if(nb) CONFIG.appBg2 = nb; else delete CONFIG.appBg2;
    const rs1 = (document.getElementById('cfgSlideBg1')?.value || '').toString(); const ns1 = normalizeHex(rs1);
    const rs2 = (document.getElementById('cfgSlideBg2')?.value || '').toString(); const ns2 = normalizeHex(rs2);
    if(ns1) CONFIG.slideBg1 = ns1; else delete CONFIG.slideBg1;
    if(ns2) CONFIG.slideBg2 = ns2; else delete CONFIG.slideBg2;
  // text color
  try{ const rt = (document.getElementById('cfgTextColor')?.value || '').toString(); const nt = normalizeHex(rt); if(nt) CONFIG.textColor = nt; else delete CONFIG.textColor; }catch{}
  // Button text color mode/value
  try{
    const modeSel = document.getElementById('cfgBtnTextMode');
    const btnClr = document.getElementById('cfgBtnTextColor');
    if(modeSel && btnClr){
      if(modeSel.value==='auto'){ CONFIG.btnTextColor = 'auto'; }
      else { const n = normalizeHex(String(btnClr.value||'')); if(n) CONFIG.btnTextColor = n; else delete CONFIG.btnTextColor; }
    }
  }catch{}
  // Button fill
  try{ const bf=document.getElementById('cfgBtnFill'); const v=(bf?.value||'').toString().toLowerCase(); CONFIG.btnFill = (v==='outline'?'outline':'solid'); }catch{}
  }catch(e){}
  // Save UI visibility checkboxes
  CONFIG.hideSlidesWithUi = document.getElementById('cfgHideSlidesWithUi').checked;
  CONFIG.hideProgressWithUi = document.getElementById('cfgHideProgressWithUi').checked;
  // Save outline checkbox
  CONFIG.slideBorderOn = document.getElementById('cfgSlideOutline').checked;
  // Save outline width
  const owSave = document.getElementById('cfgOutlineWidth');
  let px = Math.max(0, Math.min(8, Math.round(Number(owSave.value)||0)));
  CONFIG.slideBorderWidth = px;
  // Remember last deck toggle
  CONFIG.rememberLastDeck = document.getElementById('cfgRememberDeck').checked;
  // Overlay & typography saves
  CONFIG.overlayOn = document.getElementById('cfgOverlayTitleOn').checked;
  CONFIG.overlaySubtitleOn = document.getElementById('cfgOverlaySubtitleOn').checked;
  const ts = Math.max(12, Math.min(64, Math.round(Number(document.getElementById('cfgTitleSize').value)||22)));
  const ss = Math.max(10, Math.min(48, Math.round(Number(document.getElementById('cfgSubtitleSize').value)||16)));
  CONFIG.overlayTitleSize = ts; CONFIG.overlaySubtitleSize = ss;
  CONFIG.overlaySubtitleColor = (document.getElementById('cfgSubtitleColor').value === 'accent') ? 'accent' : 'primary';
  const fp = document.getElementById('cfgFontPrimary').value.trim(); const fs = document.getElementById('cfgFontSecondary').value.trim(); if(fp) CONFIG.fontPrimary = fp; if(fs) CONFIG.fontSecondary = fs;
  // Persist a temporary overlay position preview if present
  try{ if(window.__tempOverlayPos){ CONFIG.overlayPos = window.__tempOverlayPos; delete window.__tempOverlayPos; } }catch{}
  // Persist content position selection if previewed
  try{ if(window.__tempContentPos){ CONFIG.contentPos = window.__tempContentPos; delete window.__tempContentPos; } }catch{}
  // Persist only if enabled
  if(PERSIST_CONFIG){ try{ localStorage.setItem('slideapp.config', JSON.stringify(CONFIG)); }catch{} } else { try{ localStorage.removeItem('slideapp.config'); }catch{} }
  try{ if(window.Theme && typeof window.Theme.applyConfig === 'function'){ try{ window.Theme.applyConfig(CONFIG); }catch{} } else { applyConfig(); } }catch{}
  // Ensure brand label reflects saved name immediately even when Theme.applyConfig handled CSS only
  try{ const el=document.getElementById('appName'); if(el){ el.textContent = (CONFIG.appName||CONFIG.brand||'SlideApp'); } }catch{}
  // Update tab title only if deck did not provide a name (deck takes precedence)
  try{ if(!(window.__deckAppName && String(window.__deckAppName).trim())){ const nm=(CONFIG.appName||CONFIG.brand||'SlideApp'); if(nm && nm.trim()) document.title = nm.trim(); } }catch{}
  try{ updateActiveThumbGradient(); }catch{}
  cfgOverlay.style.display=cfgModal.style.display='none';
  // Notify with a summary of settings
  try{ const app=CONFIG.appName||CONFIG.brand||'SlideApp'; const primary=CONFIG.primary||'#01B4E1'; const accent=CONFIG.accent||'#64FFFC'; const outline=CONFIG.slideBorderOn!==false?'on':'off'; showToast(`Saved: ${app} • ${primary} / ${accent} • Opacity ${pct}% • Outline ${outline} ${px}px`);}catch{}
  // Update baseline after save so T toggles to the saved value
  BASE_OPACITY = CONFIG.slideOpacity;
  // Rebuild overlays on existing slides according to new settings
  try{
    if(Array.isArray(slidesHTML) && slidesHTML.length){
      const slides = [...document.querySelectorAll('.slide')];
      slides.forEach(s=>{ const old=s.querySelector('.slide-overlay'); if(old) old.remove(); });
      if(CONFIG.overlayOn===true){
        slides.forEach((slideEl, idx)=>{
          const fm = slidesHTML[idx]?.fm || {};
          const slideOverlayFlag = (typeof fm.overlay !== 'undefined') ? /^(1|on|true)$/i.test(String(fm.overlay).trim()) : true;
          if(!slideOverlayFlag) return;
          const pos = (fm.overlaypos || CONFIG.overlayPos || 'tl').toString().toLowerCase();
          const tSize = isFinite(Number(fm.titlesize)) ? Math.max(12, Math.min(64, Math.round(Number(fm.titlesize)))) : CONFIG.overlayTitleSize;
          const sSize = isFinite(Number(fm.subtitlesize)) ? Math.max(10, Math.min(48, Math.round(Number(fm.subtitlesize)))) : CONFIG.overlaySubtitleSize;
          const titleTxt = (fm.title||'').toString().trim() || `Slide ${idx+1}`;
          const subtitleTxt = (fm.subtitle||'').toString().trim();
          const wrap = document.createElement('div');
          wrap.className = `slide-overlay pos-${pos}`;
          if(tSize) wrap.style.setProperty('--title-size', `${tSize}px`);
          if(sSize) wrap.style.setProperty('--subtitle-size', `${sSize}px`);
          const tEl = document.createElement('div'); tEl.className='slide-title'; tEl.textContent = titleTxt; wrap.appendChild(tEl);
    if(CONFIG.overlaySubtitleOn===true && subtitleTxt){ const sEl=document.createElement('div'); sEl.className='slide-subtitle'; sEl.textContent=subtitleTxt; if((CONFIG.overlaySubtitleColor||'primary')==='accent'){ sEl.classList.add('accent-subtitle'); } wrap.appendChild(sEl);} 
          wrap.setAttribute('aria-hidden','true');
          slideEl.appendChild(wrap);
        });
      }
    }
  }catch{}
  // Update content position across slides using per-slide FM or new CONFIG default
  try{
    if(Array.isArray(slidesHTML) && slidesHTML.length){
      const slides = [...document.querySelectorAll('.slide')];
      slides.forEach((slideEl, idx)=>{
        const sc = slideEl.querySelector('.content-scroll');
        if(!sc) return;
        const fm = slidesHTML[idx]?.fm || {};
        const raw = String(fm['content-pos'] || fm.contentpos || CONFIG.contentPos || 'tl').toLowerCase();
        const mapRow = { t:'flex-start', m:'center', b:'flex-end' };
        const mapCol = { l:'flex-start', m:'center', r:'flex-end' };
        if(/^[tmb][lmr]$/.test(raw)){
          sc.style.setProperty('--content-y', mapRow[raw[0]]);
          sc.style.setProperty('--content-x', mapCol[raw[1]]);
        } else {
          sc.style.setProperty('--content-y', 'flex-start');
          sc.style.setProperty('--content-x', 'flex-start');
        }
      });
    }
  }catch{}
  }); document.getElementById('cfgReset').addEventListener('click',()=>{ 
    // Clear saved style config (keep persist preference for backward compatibility)
    try{ localStorage.removeItem('slideapp.config'); }catch{}
    // Also forget any remembered decks (session + persistent)
    try{ sessionStorage.removeItem('slideapp.session.deck'); }catch{}
    try{ localStorage.removeItem('slideapp.persist.deck'); }catch{}
    // Reset opacity baseline
    BASE_OPACITY = 1; 
    try{ showToast('Settings reset to defaults', 1000);}catch{} 
    setTimeout(()=>location.reload(), 400); 
  });

  // File loader
  document.getElementById('fileInput').addEventListener('change',async e=>{ const f=e.target.files[0]; if(!f) return; try{
    // Test-only deterministic guard: if tests opt-in, clear persisted bgMode and prefer gradient
    try{ if(typeof window.__isDeterministicTestMode === 'function' && window.__isDeterministicTestMode()){ try{ localStorage.removeItem('bgMode'); }catch{} bgMode = 'gradient'; setBackgroundMode('gradient'); } }catch{}
  // debug hooks removed
    if(f.size > 5*1024*1024){ alert('File too large. Max 5MB.'); return; } const valid=['text/markdown','text/plain','application/octet-stream']; if(!valid.includes(f.type) && !/\.(md|markdown|txt)$/i.test(f.name)){ alert('Please select a Markdown file (.md/.markdown/.txt)'); return; } const text=await f.text(); if(!text.trim()){ alert('File appears empty.'); return; } slidesHTML=splitSlides(text); if(!slidesHTML.length){ alert('No slides found. Separate slides with a line containing only ---'); return; } renderSlides(slidesHTML);
    // Apply deck-level frontmatter settings
    try{
  const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {}));
  // Expose parsed frontmatter for debug/tests
  // debug hook removed
  // If the loaded deck does not specify a background, ensure we reset to the default
  // so we don't accidentally preserve a previous bgMode from localStorage/session.
  try{ if(!fm.background && !fm.bg){ if(typeof window.__isDeterministicTestMode === 'function' && window.__isDeterministicTestMode()){ setBackgroundMode('gradient'); } } }catch(e){}
  applyDeckFrontmatter(fm);
        // Ensure background button label reflects any programmatic change
        try{ setBgButtonLabel(); }catch{}
      }catch{}
    // Store deck for session restore; optionally persist if configured
    try{
      const payload = { deckContent: text, fileName: f.name||'', loadedAt: Date.now() };
      // Guard very large decks (~2.5MB)
      if((text||'').length <= 2.5*1024*1024){
        sessionStorage.setItem('slideapp.session.deck', JSON.stringify(payload));
        if(CONFIG.rememberLastDeck === true){
          localStorage.setItem('slideapp.persist.deck', JSON.stringify(payload));
        }
      } else {
        showToast('Deck too large to remember');
      }
    }catch{}
    try{ showToast(`Deck loaded: ${f.name||'file'}`);}catch{}
    e.target.value=''; }catch(err){ console.error('Load failed',err); alert('Failed to load file: '+(err?.message||err)); } });

  // Hash deep-link
  window.addEventListener('hashchange',()=>{ const m=location.hash.match(/#\/(\d+)/); if(m){ const idx=parseInt(m[1],10)-1; if(idx>=0 && idx<slidesHTML.length) setActive(idx); } });

  // Boot
  function setBgFromPrefs(){ setBgButtonLabel(); if(prefersReduced && bgMode==='particles') bgMode='gradient'; setBackgroundMode(bgMode); }
  async function boot(){
    // Try session restore first
    try{
      const raw = sessionStorage.getItem('slideapp.session.deck');
      if(raw){
        const data = JSON.parse(raw);
        if(data && typeof data.deckContent === 'string' && data.deckContent.trim()){
          slidesHTML = splitSlides(data.deckContent);
          renderSlides(slidesHTML);
          try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
          try{ showToast('Restored last deck (session)'); }catch{}
          return;
        }
      }
    }catch{}
    // Then try persistent restore if enabled
    try{
      if(CONFIG.rememberLastDeck === true){
        const raw = localStorage.getItem('slideapp.persist.deck');
        if(raw){
          const data = JSON.parse(raw);
          if(data && typeof data.deckContent === 'string' && data.deckContent.trim()){
            slidesHTML = splitSlides(data.deckContent);
            renderSlides(slidesHTML);
            try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
            try{ showToast('Restored last deck'); }catch{}
            return;
          }
        }
      }
    }catch{}
    // Try to load bundled sample; if it fails (file:// or missing), fall back to demo
    try{
      const res = await fetch('sample_presentation.md');
  if(res.ok){
    const text = await res.text();
    slidesHTML = splitSlides(text);
  renderSlides(slidesHTML);
  // Apply deck-level frontmatter (sample)
  try{ const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {})); try{ if(!fm.background && !fm.bg){ if(typeof __isDeterministicTestMode === 'function' && __isDeterministicTestMode()){ setBackgroundMode('gradient'); } } }catch{}; applyDeckFrontmatter(fm); try{ setBgButtonLabel(); }catch{} }catch{}
    return;
  }
    }catch{}
  const DEMO_MD = `---
app-name: SlideApp
theme-primary: "#01B4E1"
theme-accent: "#64FFFC"
theme-text: "#e2e8f0"
background: particles
ui: on
---

# SlideApp
Super‑jazzy demos + user guide

## Quick Controls

- 🎨 Style: colors, overlays, backgrounds, content position (3×3)
- Keys: B (background) · T (opacity) · U (UI) · O (outline) · S (slides) · N (notes)
- Presets: fast theme swaps · Reset restores defaults

---

title: Content Position — Deck Default (MM)
subtitle: Centered by default (deck)
---

## Centered Content
The Markdown block is anchored to the middle (MM).

Use frontmatter <code>content-pos: mm</code> (deck) or the Style UI to change.

---

title: Content Position — TL
content-pos: tl
---

## Top‑Left (TL)
Per‑slide override via <code>content-pos: tl</code>.

---

title: Content Position — MR
content-pos: mr
---

## Middle‑Right (MR)
Great for balancing text with visuals.

---

title: Content Position — BR
content-pos: br
---

## Bottom‑Right (BR)
Perfect for quick callouts.

---

title: Overlays — Deck ON
overlay: on
overlay-pos: tr
title-size: 30
overlay-subtitle: true
overlay-subtitle-size: 16
overlay-subtitle-color: accent
---

## Title & Subtitle Overlay
Overlay ON by default from here. Subtitle uses accent color.

---

title: Overlays — Per‑Slide BL
overlay-pos: bl
title-size: 28
overlay-subtitle-size: 14
---

## Bottom‑Left Overlay
Per‑slide overlay position + sizes.

---

title: Overlay OFF here
overlay: off
---

## No Overlay
Per‑slide override hides the overlay.

---

## Markdown Goodies

- Strikethrough: ~~deprecated~~ → modern
- Task lists:
  - [ ] Collect feedback
  - [x] Ship 1.2.0
- Autolink: https://example.com

::: note
Heads up: Admonitions render with a clean style.
:::

::: tip
Pro tip: Use the TOC (📑) to jump between sections.
:::

::: warning
Warning: Don’t overuse effects; clarity wins.
:::

## Headings & Anchors

### Getting Started
Click the “#” to copy a direct link to this heading.

## Columns

::: columns

### Column A
- Alpha
- Beta

:::col

### Column B
1. One
2. Two

:::col

### Column C
- One
- Two

:::

## Tables

| Feature        | Basic | Pro |
|----------------|:-----:|:---:|
| Bullet Support | ✅    | ✅  |
| Code Blocks    | ✅    | ✅  |
| Tables         | ❌    | ✅  |

## Shortcuts (One‑hand friendly)

- Background: B cycles modes; label shows current
- Slides drawer: S toggles thumbnails (works with UI off)
- Notes panel: N toggles speaker notes
- Fullscreen: F on/off
- UI mode: U hide/show header & footer
- Progress: P toggles bar/arrows/count
- Opacity: T toggles 0% ⇄ saved baseline
- Outline: O toggles accent outline
- Title overlay: Y toggles title/subtitle overlay

## Image + Text (Example)
<p class="muted-lead">A clean visual + talking points layout.</p>

<div style="display:flex; gap:24px; align-items:center;">
  <div style="flex:1; min-width:0;">
    <img src="https://images.unsplash.com/photo-1482192596544-9eb780fc7f66?w=1000" alt="Dashboard preview" style="width:100%;height:auto;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25);" />
  </div>
  <div style="flex:1; min-width:0;">
    <h3>Why this layout works</h3>
    <ul>
      <li>Even balance between image and copy</li>
      <li>Great for highlights and callouts</li>
      <li>Responsive: stacks on small screens</li>
    </ul>
  </div>

</div>

---

title: Columns Shortcode Demo
subtitle: Markdown-only columns
notes: Use ::: columns with :::col separators. Pure Markdown authoring.
---

# Columns Shortcode
## Another way to do columns

::: columns

### Column A
- Alpha
- Beta
- Gamma

:::col

### Column B
1. One
2. Two
3. Three

:::col

### Column C
- One
- Two
- Three
- Four

:::

---

title: Table Example
subtitle: GFM tables with alignment
notes: Demonstrates table rendering with alignment.
---

## Feature Comparison

| Feature        | Basic | Pro | Enterprise |
|----------------|:-----:|:---:|:----------:|
| Bullet Support | ✅    | ✅  | ✅         |
| Code Blocks    | ✅    | ✅  | ✅         |
| Tables         | ❌    | ✅  | ✅         |
| Notes Panel    | ✅    | ✅  | ✅         |

---

title: Embedded SVG (Offline)
subtitle: Inline SVG data URI
notes: Inline SVG data URI for offline testing.
---

![Embedded SVG](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='220' height='120'><rect width='100%25' height='100%25' rx='12' fill='%230ea5e9'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='white' font-size='18'>Embedded SVG</text></svg>)

---

title: Code & Formatting
subtitle: Blocks, inline, and emphasis
notes: Demo of code blocks and emphasis styles.
---

## Code Sample

<pre><code>function greet(name){
  return 'Hello, ' + name + '!';
}
console.log(greet('World'));</code></pre>

- Supports <strong>bold</strong> and <em>italic</em> and <code>inline code</code>

---

title: Print & Accessibility
subtitle: Clean PDFs and reduced motion
notes: Print strips backgrounds and UI for clean PDFs; reduced motion is respected.
---

## Print & Accessibility

- Print to PDF via the 📄 PDF button
- Print removes backgrounds and UI for clarity
- Respects “Reduce motion” and falls back to Gradient

---

title: Title & Subtitle Overlay
subtitle: Titles on slides, your way
notes: Overlay shows the slide title (frontmatter or fallback) and an optional subtitle. Toggle globally via toolbar, hotkey, or Style. Override per slide with frontmatter.
---

## Overlay quick guide

- Toggle overlay: Toolbar "🏷️ Title" button or press Y
- Style options: Position TL/TR/BL/BR; Title size; Subtitle on/off; Subtitle size; Subtitle color (Primary/Accent); Fonts (primary/secondary)
- Per-slide overrides (frontmatter):
  - overlay: on|off — show/hide overlay
  - overlaypos: tl|tr|bl|br — position
  - titlesize: 12..64 · subtitlesize: 10..48
  - title: and subtitle: values
- Deck-level defaults (frontmatter):
  - overlay, overlaypos, overlaysubtitle, overlaysubtitlesize, overlaysubtitlecolor, primaryfont, secondaryfont

Pro tip: Keep subtitles concise; they’re intentionally thinner for hierarchy.

Tip: Subtitle is intentionally thinner than the title for hierarchy.

---

title: Front matter reference
subtitle: Deck-level and per-slide keys
notes: Quick reference listing all supported front matter keys, including aliases and accepted ranges. Boolean-like values are case-insensitive; strings are trimmed; numeric values are clamped to valid ranges.
---
::: columns

### Deck-level (whole deck)

- background | bg: gradient | particles | off
- appname | app-name | brand: string (sets app/brand label)
- primary | color: hex color (#RGB or #RRGGBB)
- accent: hex color (#RGB or #RRGGBB)
- appbg1 | app-bg1 | app-bg-1: hex color — app background start
- appbg2 | app-bg2 | app-bg-2: hex color — app background end
- effectcolor | effect-color: hex color — particles/efffect accent
- opacity | slideopacity: percentage (e.g., 75 or "75%") or decimal 0..1 (e.g., 0.75)
- primaryfont: string (font family name)
- secondaryfont: string (font family name)
- overlay | titleoverlay: on | off | true | false | 1 | 0
- overlaypos | titleposition: tl | tr | bl | br
- titlesize: integer, clamped 12..64 (px)
- overlaysubtitle | subtitleenabled: on | off | true | false | 1 | 0
- overlaysubtitlesize | subtitlesize: integer, clamped 10..48 (px)
- overlaysubtitlecolor: primary | accent
- ui: on | show | true | 1 (show UI) or off | hide | false | 0 (hide UI)

:::col

### Per-slide (single slide)

- overlay: on | off | true | false | 1 | 0
- overlaypos: tl | tr | bl | br
- titlesize: integer, clamped 12..64 (px)
- subtitlesize: integer, clamped 10..48 (px)
- title: string (used for overlay and thumbnails)
- subtitle: string (shown if non-empty and subtitle is enabled)
- slidebg1 | slide-bg1: hex color — slide background start (overrides)
- slidebg2 | slide-bg2: hex color — slide background end (overrides)

:::

Notes:
- Boolean-like values are case-insensitive; strings are trimmed
- Values outside ranges are clamped to the stated mins/maxes

Everything else in front matter is ignored by the app.`;
    slidesHTML = splitSlides(DEMO_MD);
    renderSlides(slidesHTML);
  // Apply deck-level frontmatter if present
  try{ const fm = slidesHTML[0]?.fm || {}; applyDeckFrontmatter(fm); }catch{}
  }

  // Initialize everything
  // Toast helper
  let toastTimer=null; function showToast(msg, ms=1800){ const t=document.getElementById('toast'); if(!t) return; t.textContent=msg; if(prefersReduced) t.classList.add('no-anim'); t.style.display='block'; t.classList.add('show'); clearTimeout(toastTimer); toastTimer=setTimeout(()=>{ t.classList.remove('show'); const hideDelay=prefersReduced?0:220; setTimeout(()=>{ t.style.display='none'; }, hideDelay); }, ms); }

  // Announce fullscreen changes
  document.addEventListener('fullscreenchange',()=>{ showToast(document.fullscreenElement?'Entered fullscreen':'Exited fullscreen'); });

  async function maybeLoadConfigFromQuery(){
    try{
      const sp = new URLSearchParams(location.search);
      const url = sp.get('config');
      if(url && url.trim()){
        await loadConfigFromUrl(url.trim());
      }
    }catch(e){ console.warn('Query config load failed', e); }
  }

  // Static Site Mode helpers
  let __manifest = null;
  async function loadManifest(){
    try{
      const tryUrls = ['slides.json','content/slides.json'];
      for(const u of tryUrls){
        try{
          const res = await fetch(u, { credentials: 'omit' });
          if(res.ok){ const json = await res.json(); if(json && Array.isArray(json.decks)) return json; }
        }catch{}
      }
    }catch{}
    return null;
  }
  async function loadDeckFromPath(path){
    try{
      const res = await fetch(path, { credentials: 'omit' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      slidesHTML = splitSlides(text);
      // Apply deck-level frontmatter BEFORE rendering so initial UI + active thumb use correct theme
      try{
        const fm = (slidesHTML && slidesHTML.deckFM && Object.keys(slidesHTML.deckFM||{}).length ? slidesHTML.deckFM : (slidesHTML[0]?.fm || {}));
        applyDeckFrontmatter(fm);
        // Pre-set the active thumb gradient var from CONFIG to avoid first-frame mismatch
        try{ setThumbActiveBgFromConfig(); }catch{}
        try{ setBgButtonLabel(); }catch{}
      }catch{}
      renderSlides(slidesHTML);
      // Ensure active thumbnail gradient matches theme immediately after first render
      try{ setThumbActiveBgFromConfig(); updateActiveThumbGradient(true); }catch{}
      // Update URL param without reload
      try{
        const url = new URL(location.href);
        url.searchParams.set('deck', path);
        history.replaceState(null,'',url.toString());
      }catch{}
      try{ showToast('Deck loaded'); }catch{}
    }catch(err){ console.error('Deck load failed', err); alert('Failed to load deck: '+(err?.message||err)); }
  }
  function showDeckPicker(){
    try{
      if(!__manifest || !Array.isArray(__manifest.decks) || __manifest.decks.length===0) return;
      // Build simple picker modal
      let overlay = document.getElementById('deckPickerOverlay');
      let modal = document.getElementById('deckPickerModal');
      if(!overlay){
        overlay = document.createElement('div'); overlay.id='deckPickerOverlay'; overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,0.35)'; overlay.style.zIndex='40'; overlay.style.display='none';
        document.body.appendChild(overlay);
      }
      if(!modal){
        modal = document.createElement('div'); modal.id='deckPickerModal'; modal.style.position='fixed'; modal.style.top='50%'; modal.style.left='50%'; modal.style.transform='translate(-50%,-50%)'; modal.style.width='min(520px, 92vw)'; modal.style.maxHeight='70vh'; modal.style.overflow='auto'; modal.style.background='var(--card)'; modal.style.border='1px solid rgba(255,255,255,0.12)'; modal.style.borderRadius='12px'; modal.style.boxShadow='var(--shadow)'; modal.style.padding='16px'; modal.style.zIndex='41'; modal.style.display='none';
        const h = document.createElement('div'); h.style.fontWeight='700'; h.style.margin='0 0 10px 0'; h.textContent='Select a Deck'; modal.appendChild(h);
        const list = document.createElement('div'); list.id='deckPickerList'; list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='8px'; modal.appendChild(list);
        const close = document.createElement('button'); close.className='btn'; close.textContent='Close'; close.style.marginTop='12px'; close.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; };
        modal.appendChild(close);
        document.body.appendChild(modal);
        overlay.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; };
      }
      const list = modal.querySelector('#deckPickerList');
      list.innerHTML='';
      __manifest.decks.forEach(it=>{
        const btn=document.createElement('button'); btn.className='btn'; btn.textContent=(it.title||it.path||'Deck'); btn.onclick=()=>{ overlay.style.display='none'; modal.style.display='none'; loadDeckFromPath(it.path); };
        list.appendChild(btn);
      });
      overlay.style.display='block'; modal.style.display='flex'; modal.style.flexDirection='column';
    }catch(e){ console.warn('Deck picker failed', e); }
  }

  (async function init() {
    dlog('SlideApp v0.91 initializing...');
    setDrawerUI(); 
  applyUiMode();
    setBgFromPrefs(); 
    await maybeLoadConfigFromQuery();
    applyConfig(); 
    // Try Static Site Mode (opt-in) via query (?static=1 or ?deck=...) or GitHub Pages host; otherwise fall back
    try{
      const sp = new URLSearchParams(location.search);
      const deckParam = (sp.get('deck')||'').trim();
      const staticParam = (sp.get('static')||'').trim();
      const onPages = /\.github\.io$/i.test(location.hostname);
      const enableStatic = !!deckParam || staticParam === '1' || onPages;
      if(enableStatic){
        if(deckParam){
          await loadDeckFromPath(deckParam);
        } else {
          __manifest = await loadManifest();
          if(__manifest && Array.isArray(__manifest.decks) && __manifest.decks.length){
            // Show Decks button
            try{ const b=document.getElementById('decksBtn'); if(b){ b.style.display='inline-block'; b.onclick=()=>showDeckPicker(); } }catch{}
            if(__manifest.decks.length===1){
              await loadDeckFromPath(__manifest.decks[0].path);
            } else {
              showDeckPicker();
            }
          } else {
            await boot();
          }
        }
      } else {
        await boot();
      }
    }catch(e){ console.warn('Static mode bootstrap failed, falling back', e); await boot(); }
    dlog('SlideApp initialization complete.');
  })();

  // Opacity toggle (T key): 0% <-> last saved opacity (baseline)
  function toggleOpacity(){
    try{
      // Determine current value from CONFIG (decimal 0..1) and compute baseline from persisted settings
      let dec = (typeof CONFIG.slideOpacity === 'number' && isFinite(CONFIG.slideOpacity)) ? CONFIG.slideOpacity : 1;
      let base = (typeof BASE_OPACITY === 'number' && isFinite(BASE_OPACITY)) ? BASE_OPACITY : 1;
      if(base <= 0) base = 1; // guard against degenerate baseline of 0
      const pct = Math.round(dec * 100);
      const nextPct = pct > 0 ? 0 : Math.round(base * 100);
      setSlideOpacity(nextPct);
      // Sync Style modal controls if present
      const slider = document.getElementById('cfgSlideOpacity');
      const readout = document.getElementById('cfgSlideOpacityVal');
      if(slider){ slider.value = String(nextPct); }
      if(readout){ readout.textContent = `(${nextPct}%)`; }
      // Toast
      try{ showToast(nextPct===0 ? 'Opacity: clear' : `Opacity: ${nextPct}%`); }catch{}
    }catch{}
  }

  // Progress visibility toggle (P key)
  function toggleProgress(){
    try{
      const body = document.body;
      const prog = document.querySelector('.deck-footer .progress');
      if(!prog) return;
      const hasOn = body.classList.contains('progress-on');
      const hasOff = body.classList.contains('progress-off');
      if(hasOn){
        body.classList.remove('progress-on');
        body.classList.add('progress-off');
        try{ showToast('Progress: hidden'); }catch{}
        return;
      }
      if(hasOff){
        body.classList.remove('progress-off');
        body.classList.add('progress-on');
        try{ showToast('Progress: shown'); }catch{}
        return;
      }
      // Default state: determine current visibility and flip
      const visible = getComputedStyle(prog).display !== 'none';
      if(visible){
        body.classList.add('progress-off');
        try{ showToast('Progress: hidden'); }catch{}
      } else {
        body.classList.add('progress-on');
        try{ showToast('Progress: shown'); }catch{}
      }
    }catch{}
  }

  // ===== Overlay toggle button =====
  (function bindOverlayToggle(){
    const btn = document.getElementById('overlayBtn');
    if(!btn) return;
  const rebuild = ()=>{ rebuildOverlays(); };
    const setLabel=()=>{ btn.textContent = CONFIG.overlayOn===true ? '🏷️ Title (on)' : '🏷️ Title'; };
    setLabel();
    btn.addEventListener('click',()=>{
  CONFIG.overlayOn = !(CONFIG.overlayOn===true);
  // Do not auto-persist full CONFIG here; Save in the Style modal is the explicit persistence action.
      setLabel();
      rebuild();
      try{ showToast(CONFIG.overlayOn ? 'Overlay: shown' : 'Overlay: hidden'); }catch{}
      // Sync Style checkbox if open
  try{ const cb=document.getElementById('cfgOverlayTitleOn'); if(cb) cb.checked = (CONFIG.overlayOn===true); }catch{}
      // If Style modal is open, also update position buttons disabled state and hint
      try{
        const posWrap=document.getElementById('cfgOverlayPos');
        const posHint=document.getElementById('cfgOverlayPosHint');
        const ts=document.getElementById('cfgTitleSize');
        const ss=document.getElementById('cfgSubtitleSize');
        const cbSub=document.getElementById('cfgOverlaySubtitleOn');
        const sc=document.getElementById('cfgSubtitleColor');
        if(posWrap){
          const disable = !(CONFIG.overlayOn===true);
          [...posWrap.querySelectorAll('button')].forEach(b=>{ if(disable){ b.setAttribute('disabled',''); b.setAttribute('aria-disabled','true'); } else { b.removeAttribute('disabled'); b.setAttribute('aria-disabled','false'); } });
          if(posHint){ posHint.style.display = disable ? 'inline' : 'none'; }
          if(ts) ts.disabled = disable;
          if(ss) ss.disabled = disable;
          if(cbSub) cbSub.disabled = disable;
          if(sc) sc.disabled = disable;
        }
      }catch{}
  });

  // ===== In-app Deck Validator =====
  (function initValidator(){
    const valOverlay = document.getElementById('valOverlay');
    const valModal = document.getElementById('valModal');
    const valBody = document.getElementById('valBody');
    const open = () => { valOverlay.style.display='block'; valModal.style.display='flex'; };
    const close = () => { valOverlay.style.display='none'; valModal.style.display='none'; };
    document.getElementById('valClose').addEventListener('click', close);
    document.getElementById('valOk').addEventListener('click', close);
    document.getElementById('validateBtn').addEventListener('click', ()=>{
      const warnings = (()=>{
        const allowedDeck = new Set([
          'app-name','appname','brand',
          'theme-primary','theme-accent','theme-text','primary','accent','textcolor','text-color','text',
          'background','effect-color','effectcolor','effect','ui','font-primary','font-secondary','primaryfont','secondaryfont',
          'defaults-overlay','defaults-overlay-pos','defaults-title-size','defaults-subtitle-size','defaults-slide-opacity','defaults-slide-bg1','defaults-slide-bg2',
          'appbg1','appbg2','app-bg1','app-bg2','app-bg-1','app-bg-2','opacity','slideopacity',
          // Newer deck-level keys
          'content-pos','overlay-subtitle-size','overlay-subtitle-color','overlaysubtitlecolor','overlaysubtitle','subtitleenabled',
          'button-text-color','btn-text-color','button-fill'
        ]);
        const allowedSlide = new Set([
          'title','subtitle','notes','overlay','overlay-pos','overlaypos','title-size','titlesize','subtitle-size','subtitlesize','slide-bg1','slide-bg2','slidebg1','slidebg2',
          // New per-slide keys
          'content-pos','overlay-subtitle','overlay-subtitle-size','overlay-subtitle-color','overlaysubtitle','overlaysubtitlecolor'
        ]);
        const migrate = new Map(Object.entries({
          primary:'theme-primary', accent:'theme-accent', textcolor:'theme-text', 'text-color':'theme-text', text:'theme-text', effectcolor:'effect-color', effect:'effect-color', appname:'app-name', brand:'app-name', appbg1:'defaults-slide-bg1', 'app-bg1':'defaults-slide-bg1', 'app-bg-1':'defaults-slide-bg1', appbg2:'defaults-slide-bg2', 'app-bg2':'defaults-slide-bg2', 'app-bg-2':'defaults-slide-bg2', slideopacity:'defaults-slide-opacity', opacity:'defaults-slide-opacity', primaryfont:'font-primary', secondaryfont:'font-secondary', overlaypos:'overlay-pos', titlesize:'title-size', subtitlesize:'subtitle-size', slidebg1:'slide-bg1', slidebg2:'slide-bg2'
        }));
        const isHex=(s)=>/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test((s||'').toString().trim().replace(/^['"]|['"]$/g,''));
        const isBg=(s)=>['gradient','particles','off'].includes((s||'').toString().trim().toLowerCase());
        const isBool=(s)=>/^(on|off|show|hide|true|false|1|0)$/i.test((s||'').toString().trim());
        const isPos=(s)=>['tl','tr','bl','br'].includes((s||'').toString().trim().toLowerCase());
        const isContentPos=(s)=>/^[tmb][lmr]$/i.test((s||'').toString().trim());
        const isSubtitleColor=(s)=>/^(accent|primary)$/i.test((s||'').toString().trim());
        const isButtonFill=(s)=>/^(solid|outline)$/i.test((s||'').toString().trim());
        const clamp=(n,lo,hi)=>{ n=Number(n); if(!isFinite(n)) return null; return Math.max(lo, Math.min(hi, n)); };
        const parseOpacity=(raw)=>{ const s=(raw||'').toString().trim(); if(!s) return null; if(/%$/.test(s)) return clamp(parseFloat(s),0,100); const num=parseFloat(s); if(!isFinite(num)) return null; if(num<=1) return clamp(num*100,0,100); return clamp(num,0,100); };
        const out=[];
        try{
          const deckFM = (Array.isArray(slidesHTML) && slidesHTML.length) ? (slidesHTML[0]?.fm || {}) : {};
          for(const [kRaw,v] of Object.entries(deckFM)){
            const k = String(kRaw).trim().toLowerCase();
            if(!allowedDeck.has(k)){
              const sug = migrate.get(k);
              out.push(`Deck: unknown key '${kRaw}'${sug? ` (did you mean '${sug}'?)`: ''}`);
            }
            if(migrate.has(k)) out.push(`Deck: legacy key '${kRaw}' — prefer '${migrate.get(k)}'`);
            switch(k){
              case 'theme-primary': case 'theme-accent': case 'theme-text':
              case 'primary': case 'accent': case 'textcolor': case 'text-color': case 'text':
              case 'effect-color': case 'effectcolor': case 'effect':
              case 'defaults-slide-bg1': case 'defaults-slide-bg2':
              case 'appbg1': case 'appbg2': case 'app-bg1': case 'app-bg2': case 'app-bg-1': case 'app-bg-2':
                if(!isHex(v)) out.push(`Deck: '${kRaw}' expects hex color, got '${v}'`);
                break;
              case 'background': if(!isBg(v)) out.push(`Deck: 'background' must be gradient|particles|off, got '${v}'`); break;
              case 'ui': if(!isBool(v)) out.push(`Deck: 'ui' must be on|off|show|hide|true|false|1|0, got '${v}'`); break;
              case 'defaults-overlay': if(!isBool(v)) out.push(`Deck: 'defaults-overlay' must be true|false|on|off|1|0, got '${v}'`); break;
              case 'defaults-overlay-pos': if(!isPos(v)) out.push(`Deck: 'defaults-overlay-pos' must be tl|tr|bl|br, got '${v}'`); break;
              case 'defaults-title-size': if(clamp(v,12,64)===null) out.push(`Deck: 'defaults-title-size' must be 12..64, got '${v}'`); break;
              case 'defaults-subtitle-size': if(clamp(v,10,48)===null) out.push(`Deck: 'defaults-subtitle-size' must be 10..48, got '${v}'`); break;
              case 'defaults-slide-opacity': case 'opacity': case 'slideopacity': if(parseOpacity(v)===null) out.push(`Deck: '${kRaw}' must be 0..100, 0..1, or a percent string, got '${v}'`); break;
              case 'content-pos': if(!isContentPos(v)) out.push(`Deck: 'content-pos' must be one of tl|tm|tr|ml|mm|mr|bl|bm|br, got '${v}'`); break;
              case 'overlay-subtitle-size': if(clamp(v,10,48)===null) out.push(`Deck: 'overlay-subtitle-size' must be 10..48, got '${v}'`); break;
              case 'overlay-subtitle-color': case 'overlaysubtitlecolor': if(!isSubtitleColor(v)) out.push(`Deck: '${kRaw}' must be primary|accent, got '${v}'`); break;
              case 'overlaysubtitle': case 'subtitleenabled': if(!isBool(v)) out.push(`Deck: '${kRaw}' must be true|false|on|off|1|0, got '${v}'`); break;
              case 'button-text-color': case 'btn-text-color': { const t=String(v).trim(); if(!/^auto$/i.test(t)){ if(!isHex(v)) out.push(`Deck: '${kRaw}' expects hex or 'auto', got '${v}'`); } break; }
              case 'button-fill': if(!isButtonFill(v)) out.push(`Deck: 'button-fill' must be solid|outline, got '${v}'`); break;
            }
          }
          // Per-slide
          (slidesHTML||[]).slice(1).forEach((s,idx)=>{
            const fm = s?.fm || {}; const n=idx+1;
            for(const [kRaw,v] of Object.entries(fm)){
              const k = String(kRaw).trim().toLowerCase();
              if(!allowedSlide.has(k)){
                const sug = migrate.get(k);
                out.push(`Slide ${n}: unknown key '${kRaw}'${sug? ` (did you mean '${sug}'?)`: ''}`);
              }
              if(migrate.has(k)) out.push(`Slide ${n}: legacy key '${kRaw}' — prefer '${migrate.get(k)}'`);
              switch(k){
                case 'slide-bg1': case 'slide-bg2': case 'slidebg1': case 'slidebg2': if(!isHex(v)) out.push(`Slide ${n}: '${kRaw}' expects hex color, got '${v}'`); break;
                case 'overlay': if(!isBool(v)) out.push(`Slide ${n}: 'overlay' must be true|false|on|off|1|0, got '${v}'`); break;
                case 'overlay-pos': case 'overlaypos': if(!isPos(v)) out.push(`Slide ${n}: '${kRaw}' must be tl|tr|bl|br, got '${v}'`); break;
                case 'title-size': case 'titlesize': if(clamp(v,12,64)===null) out.push(`Slide ${n}: '${kRaw}' must be 12..64, got '${v}'`); break;
                case 'subtitle-size': case 'subtitlesize': if(clamp(v,10,48)===null) out.push(`Slide ${n}: '${kRaw}' must be 10..48, got '${v}'`); break;
                case 'content-pos': if(!isContentPos(v)) out.push(`Slide ${n}: 'content-pos' must be tl|tm|tr|ml|mm|mr|bl|bm|br, got '${v}'`); break;
                case 'overlay-subtitle': if(!isBool(v)) out.push(`Slide ${n}: 'overlay-subtitle' must be true|false|on|off|1|0, got '${v}'`); break;
                case 'overlay-subtitle-size': if(clamp(v,10,48)===null) out.push(`Slide ${n}: 'overlay-subtitle-size' must be 10..48, got '${v}'`); break;
                case 'overlay-subtitle-color': case 'overlaysubtitlecolor': if(!isSubtitleColor(v)) out.push(`Slide ${n}: '${kRaw}' must be primary|accent, got '${v}'`); break;
              }
            }
          });
        }catch(e){ out.push('Validator error: '+(e&&e.message)); }
        return out;
      })();
      // Render
      if(!warnings.length){ valBody.innerHTML='<p style="margin:0">✅ No issues found.</p>'; }
      else {
        const list = warnings.map(w=>`<li>${w.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</li>`).join('');
        valBody.innerHTML = `<p style="margin-top:0">⚠ Found ${warnings.length} warning(s):</p><ul style="margin:8px 0 0 18px;">${list}</ul>`;
      }
      open();
    });
  })();

  // ===== In-app TOC =====
  (function initToc(){
    const tocOverlay = document.getElementById('tocOverlay');
    const tocModal = document.getElementById('tocModal');
    const tocBody = document.getElementById('tocBody');
    function layoutPanel(){
      const wide = innerWidth >= 1280;
      if(wide){
        tocOverlay.style.display='none';
        tocModal.style.display='flex';
        tocModal.style.top='60px'; tocModal.style.bottom='20px'; tocModal.style.left='auto'; tocModal.style.right='20px'; tocModal.style.width='320px';
      } else {
        tocModal.style.top='40px'; tocModal.style.bottom='40px'; tocModal.style.left='40px'; tocModal.style.right='40px'; tocModal.style.width='auto';
      }
      return wide;
    }
    const open = () => { const wide=layoutPanel(); tocOverlay.style.display= wide ? 'none':'block'; tocModal.style.display='flex'; };
    const close = () => { tocOverlay.style.display='none'; tocModal.style.display='none'; };
    document.getElementById('tocClose').addEventListener('click', close);
    document.getElementById('tocOk').addEventListener('click', close);
    const build = ()=>{
      const items = [];
      try{
        const slides = Array.from(document.querySelectorAll('.slide'));
        slides.forEach((s, idx)=>{
          const hs = Array.from(s.querySelectorAll('h1, h2, h3'));
          hs.forEach(h=>{
            const level = h.tagName.toLowerCase();
            const text = (h.textContent||'').trim();
            items.push({ idx, level, text });
          });
        });
      }catch{}
      if(!items.length){ tocBody.innerHTML = '<p style="margin:0">No headings found.</p>'; return; }
      const rows = items.map(it=>{
        const pad = it.level==='h1'? '' : it.level==='h2'? '&nbsp;&nbsp;' : '&nbsp;&nbsp;&nbsp;&nbsp;';
        return `<div style=\"padding:4px 0; cursor:pointer;\" data-idx=\"${it.idx}\">${pad}${it.text.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</div>`;
      }).join('');
      tocBody.innerHTML = rows;
      Array.from(tocBody.children).forEach((el)=>{
        el.addEventListener('click', ()=>{ const i = Number(el.getAttribute('data-idx')); if(Number.isFinite(i)){ try{ setActive(i); }catch{} close(); }});
      });
    };
    document.getElementById('tocBtn').addEventListener('click', ()=>{ build(); open(); });
    window.addEventListener('resize', ()=>{ if(tocModal.style.display!=='none'){ open(); } });
  })();
  })();

  // ===== Deck-level frontmatter application =====
  function applyDeckFrontmatter(fm){
    if(!fm || typeof fm !== 'object') return;
  function setDocumentTitle(){
    try{
      const deckNm = (typeof window.__deckAppName === 'string' && window.__deckAppName.trim()) ? window.__deckAppName.trim() : '';
      const cfgNm = (typeof CONFIG.appName === 'string' && CONFIG.appName.trim()) ? CONFIG.appName.trim() : '';
      const title = deckNm || cfgNm || 'SlideApp';
      document.title = title;
    }catch{}
  }
  // Reset temporary progress overrides when applying a new deck's settings
  try{ document.body.classList.remove('progress-on','progress-off'); }catch{}
    // Background mode
    try{
      const bg = String(fm.background || fm.bg || '').trim().toLowerCase();
      if(bg && ['gradient','particles','off'].includes(bg)) { setBackgroundMode(bg); try{ showToast(`Deck background: ${bg}`);}catch{} }
    }catch{}
    // App name (brand legacy)
    try{
      const nm = (fm.appname || fm['app-name'] || fm.brand || '').toString().trim();
      if(nm){ CONFIG.appName = nm; CONFIG.brand = CONFIG.brand || nm; try{ window.__deckAppName = nm; }catch{} }
    }catch{}
    // Colors (hex)
    const hexRe = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;
      const strip = s=> (s||'').toString().trim().replace(/^['"]|['"]$/g,'');
      try{
        const pRaw = strip(fm.primary||fm.color|| fm['theme-primary'] || '');
        const p = normalizeHex(pRaw);
        if(p) CONFIG.primary = p;
      }catch{}
      try{
        const aRaw = strip(fm.accent|| fm['theme-accent'] || '');
        const a = normalizeHex(aRaw);
        if(a) CONFIG.accent = a;
      }catch{}
    // Theme text color
    try{
      const tRaw = strip(fm['theme-text'] || '');
      const t = normalizeHex(tRaw);
      if(t) CONFIG.textColor = t;
    }catch{}
    // App background colors (hex)
    try{
      const ab1Raw = strip(fm.appbg1 || fm['app-bg1'] || fm['app-bg-1'] || '');
      const ab1 = normalizeHex(ab1Raw);
      if(ab1) CONFIG.appBg1 = ab1;
    }catch{}
    try{
      const ab2Raw = strip(fm.appbg2 || fm['app-bg2'] || fm['app-bg-2'] || '');
      const ab2 = normalizeHex(ab2Raw);
      if(ab2) CONFIG.appBg2 = ab2;
    }catch{}
    // Defaults slide background (deck-level defaults for slides)
    try{
      const sb1Raw = strip(fm['defaults-slide-bg1'] || '');
      const sb1 = normalizeHex(sb1Raw);
      if(sb1) CONFIG.slideBg1 = sb1;
    }catch{}
    try{
      const sb2Raw = strip(fm['defaults-slide-bg2'] || '');
      const sb2 = normalizeHex(sb2Raw);
      if(sb2) CONFIG.slideBg2 = sb2;
    }catch{}
    // Effect color (hex) used by particles/gradients
    try{
      const ecRaw = strip(fm.effectcolor || fm['effect-color'] || fm.effect || '');
      const ec = normalizeHex(ecRaw);
      if(ec) CONFIG.effectColor = ec;
    }catch{}
    // Text color (legacy)
    try{
      const tcRaw = strip(fm.textcolor || fm['text-color'] || fm.text || '');
      const tc = normalizeHex(tcRaw);
      if(tc) CONFIG.textColor = tc;
    }catch{}
    // Button text color and fill
    try{
      const btcRaw = (fm['button-text-color'] || fm['btn-text-color'] || '').toString().trim();
      if(btcRaw){
        if(/^auto$/i.test(btcRaw)) CONFIG.btnTextColor = 'auto';
        else { const n = normalizeHex(btcRaw); if(n) CONFIG.btnTextColor = n; }
      }
    }catch{}
    try{
      const bfRaw = (fm['button-fill'] || '').toString().trim().toLowerCase();
      if(bfRaw && /^(solid|outline)$/.test(bfRaw)) CONFIG.btnFill = bfRaw;
    }catch{}
    // Opacity (percent 0-100 or decimal 0-1 or with %)
    let hasOpacity=false; let decOpacity=null;
    try{
      const raw = strip(fm.opacity || fm.slideopacity || fm['defaults-slide-opacity'] || '');
      if(raw){
        hasOpacity = true;
        let pct;
        if(/%$/.test(raw)){
          pct = parseFloat(raw.replace(/%/g,''));
        } else {
          const num = parseFloat(raw);
          if(isFinite(num) && num <= 1){ pct = num * 100; }
          else { pct = num; }
        }
        if(!isFinite(pct)) pct = 100;
        pct = Math.round(Math.max(0, Math.min(100, pct)));
        decOpacity = pct/100;
        CONFIG.slideOpacity = decOpacity;
      }
    }catch{}
  // Apply brand/colors and opacity via existing helper
  try{ if(window.Theme && typeof window.Theme.applyConfig === 'function'){ try{ window.Theme.applyConfig(CONFIG); }catch{} } else { applyConfig(); } }catch{}
    if(hasOpacity){
      try{ setSlideOpacity(decOpacity * 100); }catch{}
    }
  // Typography and overlays
  try{ if(typeof fm.primaryfont==='string' && fm.primaryfont.trim()) CONFIG.fontPrimary = fm.primaryfont.trim(); }catch{}
  try{ if(typeof fm['font-primary']==='string' && fm['font-primary'].trim()) CONFIG.fontPrimary = fm['font-primary'].trim(); }catch{}
  try{ if(typeof fm.secondaryfont==='string' && fm.secondaryfont.trim()) CONFIG.fontSecondary = fm.secondaryfont.trim(); }catch{}
  try{ if(typeof fm['font-secondary']==='string' && fm['font-secondary'].trim()) CONFIG.fontSecondary = fm['font-secondary'].trim(); }catch{}
  // overlay (new) and legacy + namespaced defaults-
  try{ if(typeof fm.overlay!=='undefined'){ const v=String(fm.overlay).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } else if(typeof fm.titleoverlay!=='undefined'){ const v=String(fm.titleoverlay).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } else if(typeof fm['defaults-overlay']!=='undefined'){ const v=String(fm['defaults-overlay']).trim().toLowerCase(); CONFIG.overlayOn = (v==='true'||v==='1'||v==='on'); } }catch{}
  try{ const p=(fm['overlay-pos']||fm.overlaypos||fm.titleposition||fm['defaults-overlay-pos']||'').toString().toLowerCase(); if(['tl','tr','bl','br'].includes(p)) CONFIG.overlayPos=p; }catch{}
  // Content position default for deck
  try{ const c=(fm['content-pos']||fm.contentpos||'').toString().toLowerCase(); if(/^[tmb][lmr]$/.test(c)) CONFIG.contentPos = c; }catch{}
  try{ const tRaw = (typeof fm['title-size']!=='undefined') ? fm['title-size'] : (typeof fm.titlesize!=='undefined' ? fm.titlesize : fm['defaults-title-size']); const n=Math.round(Number(tRaw)); if(isFinite(n)) CONFIG.overlayTitleSize = Math.max(12, Math.min(64, n)); }catch{}
  try{ if(typeof fm.overlaysubtitle!=='undefined'){ const v=String(fm.overlaysubtitle).trim().toLowerCase(); CONFIG.overlaySubtitleOn = !(v==='false'||v==='0'||v==='off'); } else if(typeof fm.subtitleenabled!=='undefined'){ const v=String(fm.subtitleenabled).trim().toLowerCase(); CONFIG.overlaySubtitleOn = !(v==='false'||v==='0'||v==='off'); } else if(typeof fm['defaults-overlay']!=='undefined'){ /* already handled by overlayOn */ } }catch{}
  try{ const sRaw = (typeof fm['overlay-subtitle-size']!=='undefined') ? fm['overlay-subtitle-size'] : (typeof fm.subtitlesize!=='undefined' ? fm.subtitlesize : fm['defaults-subtitle-size']); const n=Math.round(Number(sRaw)); if(isFinite(n)) CONFIG.overlaySubtitleSize = Math.max(10, Math.min(48, n)); }catch{}
  try{ const c=((fm.overlaysubtitlecolor||'') || (fm['overlay-subtitle-color']||'') ).toString().toLowerCase(); if(c==='accent'||c==='primary') CONFIG.overlaySubtitleColor=c; }catch{}
    applyConfig();
  // Ensure tab title reflects deck/app precedence (deck > style config)
    try{ setDocumentTitle(); }catch{}
  // Rebuild overlays for current slides
    try{
      if(Array.isArray(slidesHTML) && slidesHTML.length){
        const slides = [...document.querySelectorAll('.slide')];
        slides.forEach(s=>{ const old=s.querySelector('.slide-overlay'); if(old) old.remove(); });
    if(CONFIG.overlayOn===true){
          slides.forEach((slideEl, idx)=>{
            const fm2 = slidesHTML[idx]?.fm || {};
      const slideOverlayFlag = (typeof fm2.overlay !== 'undefined') ? /^(1|on|true)$/i.test(String(fm2.overlay).trim()) : true;
      if(!slideOverlayFlag) return;
      const pos = (fm2.overlaypos || CONFIG.overlayPos || 'tl').toString().toLowerCase();
      const tSize = isFinite(Number(fm2.titlesize)) ? Math.max(12, Math.min(64, Math.round(Number(fm2.titlesize)))) : CONFIG.overlayTitleSize;
      const sSize = isFinite(Number(fm2.subtitlesize)) ? Math.max(10, Math.min(48, Math.round(Number(fm2.subtitlesize)))) : CONFIG.overlaySubtitleSize;
      const titleTxt = (fm2.title||'').toString().trim() || `Slide ${idx+1}`;
      const subtitleTxt = (fm2.subtitle||'').toString().trim();
      const wrap = document.createElement('div');
      wrap.className = `slide-overlay pos-${pos}`;
      if(tSize) wrap.style.setProperty('--title-size', `${tSize}px`);
      if(sSize) wrap.style.setProperty('--subtitle-size', `${sSize}px`);
      const tEl = document.createElement('div'); tEl.className='slide-title'; tEl.textContent = titleTxt; wrap.appendChild(tEl);
  if(CONFIG.overlaySubtitleOn===true && subtitleTxt){ const sEl=document.createElement('div'); sEl.className='slide-subtitle'; sEl.textContent=subtitleTxt; if((CONFIG.overlaySubtitleColor||'primary')==='accent'){ sEl.classList.add('accent-subtitle'); } wrap.appendChild(sEl);} 
            wrap.setAttribute('aria-hidden','true');
            slideEl.appendChild(wrap);
          });
        }
      }
    }catch{}
    // UI mode (on/off, show/hide, 1/0, true/false)
    try{
      if(typeof fm.ui !== 'undefined'){
        let v = String(fm.ui).trim().toLowerCase();
        let on;
        if(v==='on' || v==='show' || v==='true' || v==='1'){ on = 0; } // on => ui visible => uiMode 0
        else if(v==='off' || v==='hide' || v==='false' || v==='0'){ on = 1; } // off => hide UI => uiMode 1
        if(typeof on === 'number'){
          uiMode = on; localStorage.setItem('uiMode', on ? '1':'0'); applyUiMode();
        }
      }
  }catch{}
  // Refresh background button label in case background mode was changed above
  try{ setBgButtonLabel(); }catch{}
  }

  // ===== Self-tests (non-intrusive) =====
  (function selfTests(){
    try{
      // Minimal checks to avoid heavy literals in inline script
      console.assert(typeof setSlideOpacity === 'function', 'setSlideOpacity exists');
  // Preserve current opacity (stored as decimal 0..1)
  const prev = (typeof CONFIG.slideOpacity === 'number') ? CONFIG.slideOpacity : 1;
  // Expect clamping at the low end
  const low = setSlideOpacity(-5); // -5% -> 0
  console.assert(low === 0, 'opacity clamp low');
  // Expect clamping at the high end (100%)
  const high = setSlideOpacity(100);
  console.assert(high === 1, 'opacity clamp high');
  const o1 = getComputedStyle(document.documentElement).getPropertyValue('--slide-bg1').trim();
  const o2 = getComputedStyle(document.documentElement).getPropertyValue('--slide-bg2').trim();
      console.assert(o1 && o2, 'opacity CSS vars set');
      console.log('[SlideApp tests] OK');
  // Restore previous opacity so tests don't affect UI state
  setSlideOpacity(prev * 100);
    }catch(e){ console.error('[SlideApp tests] FAIL', e); }
  })();
  </script>
</body>
</html>
